(**************************************************************************)
(*  This file is part of BINSEC.                                          *)
(*                                                                        *)
(*  Copyright (C) 2016-2018                                               *)
(*    CEA (Commissariat à l'énergie atomique et aux énergies              *)
(*         alternatives)                                                  *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

(** Load traces generated by Pinsec *)

open Trace_type

(** Read a trace chunk in the given channel. It
    first read an int64 representing the size of
    the chunk then read the chunk and parse it
    with the Piqi structure.
    @return [None] if there is no chunk anymore *)
val parse_chunk: in_channel -> Trace_piqi.chunk_t option

(** [complete_partial_trace trace chunk keep] complete [trace]
    with the chunk [chunk]. [keep] indicates either or not to
    keep old instruction in the trace. Set to [true] if the
    whole trace cannot fit in memory *)
val complete_partial_trace: trace -> Trace_piqi.chunk_t -> bool -> trace

(** read all chunks in the channel and put them in the trace *)
val complete_all_partial_trace: trace -> in_channel -> trace

(** start reading a trace from the given channel. It first
    parse the trace header and load the first chunk. [?load_all]
    indicates either to load all the chunks or not *)
val load_partial_trace_from_file : ?load_all:bool -> in_channel -> trace

(** [load_partial_trace_from_string header fst_chunk] create a trace
    from the raw header [header] and a first chunk [chunk] *)
val load_partial_trace_from_string : string -> string -> trace

(** print the whole trace *)
val print_trace: Trace_config.trace_format -> unit

(** [get_load_content addr ~esp_value size infos] return the
    runtime data read in memory at [addr] of size [size] in
    the instruction concrete informations [info]

    Warning:Do not modify [esp_value]*)
val get_load_content: int64 -> ?esp_value:int64 -> int -> conc_infos -> string


val as_cfg : Trace_config.t -> Instr_cfg.t
val view_cfg : Trace_config.t -> unit

.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "QEMU-QMP-REF.7 7"
.TH QEMU-QMP-REF.7 7 "2019-09-18" " " " "
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
qemu\-qmp\-ref \- QEMU QMP Reference Manual
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Introduction"
.IX Subsection "Introduction"
This document describes all commands currently supported by \s-1QMP.\s0
.PP
Most of the time their usage is exactly the same as in the user Monitor, this
means that any other document which also describe commands (the manpage,
\&\s-1QEMU\s0's manual, etc) can and should be consulted.
.PP
\&\s-1QMP\s0 has two types of commands: regular and query commands. Regular commands
usually change the Virtual Machine's state someway, while query commands just
return information. The sections below are divided accordingly.
.PP
It's important to observe that all communication examples are formatted in
a reader-friendly way, so that they're easier to understand. However, in real
protocol usage, they're emitted as a single line.
.PP
Also, the following notation is used to denote data flow:
.PP
Example:
.PP
.Vb 1
\&        \-> data issued by the Client
\&
\&
\&        
\&        <\- Server data response
.Ve
.PP
Please, refer to the \s-1QMP\s0 specification (docs/interop/qmp\-spec.txt) for
detailed information on the Server command and response formats.
.SS "Stability Considerations"
.IX Subsection "Stability Considerations"
The current \s-1QMP\s0 command set (described in this file) may be useful for a
number of use cases, however it's limited and several commands have bad
defined semantics, specially with regard to command completion.
.PP
These problems are going to be solved incrementally in the next \s-1QEMU\s0 releases
and we're going to establish a deprecation policy for badly defined commands.
.PP
If you're planning to adopt \s-1QMP,\s0 please observe the following:
.IP "1." 4
The deprecation policy will take effect and be documented soon, please
check the documentation of each used command as soon as a new release of
\&\s-1QEMU\s0 is available
.IP "2." 4
\&\s-1DO NOT\s0 rely on anything which is not explicit documented
.IP "3." 4
Errors, in special, are not documented. Applications should \s-1NOT\s0 check
for specific errors classes or data (it's strongly recommended to only
check for the \*(L"error\*(R" key)
.SS "\s-1QAPI\s0 common definitions"
.IX Subsection "QAPI common definitions"
\&\fBQapiErrorClass\fR (Enum)
.PP
\&\s-1QEMU\s0 error classes
.PP
\&\fBValues:\fR
.ie n .IP """GenericError""" 4
.el .IP "\f(CWGenericError\fR" 4
.IX Item "GenericError"
this is used for errors that don't require a specific error
class. This should be the default case for most errors
.ie n .IP """CommandNotFound""" 4
.el .IP "\f(CWCommandNotFound\fR" 4
.IX Item "CommandNotFound"
the requested command has not been found
.ie n .IP """DeviceNotActive""" 4
.el .IP "\f(CWDeviceNotActive\fR" 4
.IX Item "DeviceNotActive"
a device has failed to be become active
.ie n .IP """DeviceNotFound""" 4
.el .IP "\f(CWDeviceNotFound\fR" 4
.IX Item "DeviceNotFound"
the requested device has not been found
.ie n .IP """KVMMissingCap""" 4
.el .IP "\f(CWKVMMissingCap\fR" 4
.IX Item "KVMMissingCap"
the requested operation can't be fulfilled because a
required \s-1KVM\s0 capability is missing
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBVersionTriple\fR (Object)
.PP
A three-part version number.
.PP
\&\fBMembers:\fR
.ie n .IP """major: int""" 4
.el .IP "\f(CWmajor: int\fR" 4
.IX Item "major: int"
The major version number.
.ie n .IP """minor: int""" 4
.el .IP "\f(CWminor: int\fR" 4
.IX Item "minor: int"
The minor version number.
.ie n .IP """micro: int""" 4
.el .IP "\f(CWmicro: int\fR" 4
.IX Item "micro: int"
The micro version number.
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBVersionInfo\fR (Object)
.PP
A description of \s-1QEMU\s0's version.
.PP
\&\fBMembers:\fR
.ie n .IP """qemu: VersionTriple""" 4
.el .IP "\f(CWqemu: VersionTriple\fR" 4
.IX Item "qemu: VersionTriple"
The version of \s-1QEMU. \s0 By current convention, a micro
version of 50 signifies a development branch.  A micro version
greater than or equal to 90 signifies a release candidate for
the next minor version.  A micro version of less than 50
signifies a stable release.
.ie n .IP """package: string""" 4
.el .IP "\f(CWpackage: string\fR" 4
.IX Item "package: string"
\&\s-1QEMU\s0 will always set this field to an empty string.  Downstream
versions of \s-1QEMU\s0 should set this to a non-empty string.  The
exact format depends on the downstream however it highly
recommended that a unique name is used.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBquery-version\fR  (Command)
Returns the current version of \s-1QEMU.\s0
.PP
\&\fBReturns:\fR
A \f(CW\*(C`VersionInfo\*(C'\fR object describing the current version of \s-1QEMU.\s0
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 11
\&        \-> { "execute": "query\-version" }
\&        <\- {
\&              "return":{
\&                 "qemu":{
\&                    "major":0,
\&                    "minor":11,
\&                    "micro":5
\&                 },
\&                 "package":""
\&              }
\&           }
.Ve
.PP
\&\fBCommandInfo\fR (Object)
.PP
Information about a \s-1QMP\s0 command
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
The command name
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBquery-commands\fR  (Command)
Return a list of supported \s-1QMP\s0 commands by this server
.PP
\&\fBReturns:\fR
A list of \f(CW\*(C`CommandInfo\*(C'\fR for all supported commands
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 11
\&        \-> { "execute": "query\-commands" }
\&        <\- {
\&             "return":[
\&                {
\&                   "name":"query\-balloon"
\&                },
\&                {
\&                   "name":"system_powerdown"
\&                }
\&             ]
\&           }
.Ve
.PP
\&\fBNote:\fR
This example has been shortened as the real response is too long.
.PP
\&\fBOnOffAuto\fR (Enum)
.PP
An enumeration of three options: on, off, and auto
.PP
\&\fBValues:\fR
.ie n .IP """auto""" 4
.el .IP "\f(CWauto\fR" 4
.IX Item "auto"
\&\s-1QEMU\s0 selects the value between on and off
.ie n .IP """on""" 4
.el .IP "\f(CWon\fR" 4
.IX Item "on"
Enabled
.ie n .IP """off""" 4
.el .IP "\f(CWoff\fR" 4
.IX Item "off"
Disabled
.PP
\&\fBSince:\fR
2.2
.PP
\&\fBOnOffSplit\fR (Enum)
.PP
An enumeration of three values: on, off, and split
.PP
\&\fBValues:\fR
.ie n .IP """on""" 4
.el .IP "\f(CWon\fR" 4
.IX Item "on"
Enabled
.ie n .IP """off""" 4
.el .IP "\f(CWoff\fR" 4
.IX Item "off"
Disabled
.ie n .IP """split""" 4
.el .IP "\f(CWsplit\fR" 4
.IX Item "split"
Mixed
.PP
\&\fBSince:\fR
2.6
.SS "\s-1QAPI\s0 crypto definitions"
.IX Subsection "QAPI crypto definitions"
\&\fBQCryptoTLSCredsEndpoint\fR (Enum)
.PP
The type of network endpoint that will be using the credentials.
Most types of credential require different setup / structures
depending on whether they will be used in a server versus a
client.
.PP
\&\fBValues:\fR
.ie n .IP """client""" 4
.el .IP "\f(CWclient\fR" 4
.IX Item "client"
the network endpoint is acting as the client
.ie n .IP """server""" 4
.el .IP "\f(CWserver\fR" 4
.IX Item "server"
the network endpoint is acting as the server
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBQCryptoSecretFormat\fR (Enum)
.PP
The data format that the secret is provided in
.PP
\&\fBValues:\fR
.ie n .IP """raw""" 4
.el .IP "\f(CWraw\fR" 4
.IX Item "raw"
raw bytes. When encoded in \s-1JSON\s0 only valid \s-1UTF\-8\s0 sequences can be used
.ie n .IP """base64""" 4
.el .IP "\f(CWbase64\fR" 4
.IX Item "base64"
arbitrary base64 encoded binary data
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoHashAlgorithm\fR (Enum)
.PP
The supported algorithms for computing content digests
.PP
\&\fBValues:\fR
.ie n .IP """md5""" 4
.el .IP "\f(CWmd5\fR" 4
.IX Item "md5"
\&\s-1MD5.\s0 Should not be used in any new code, legacy compat only
.ie n .IP """sha1""" 4
.el .IP "\f(CWsha1\fR" 4
.IX Item "sha1"
\&\s-1SHA\-1.\s0 Should not be used in any new code, legacy compat only
.ie n .IP """sha224""" 4
.el .IP "\f(CWsha224\fR" 4
.IX Item "sha224"
\&\s-1SHA\-224. \s0(since 2.7)
.ie n .IP """sha256""" 4
.el .IP "\f(CWsha256\fR" 4
.IX Item "sha256"
\&\s-1SHA\-256.\s0 Current recommended strong hash.
.ie n .IP """sha384""" 4
.el .IP "\f(CWsha384\fR" 4
.IX Item "sha384"
\&\s-1SHA\-384. \s0(since 2.7)
.ie n .IP """sha512""" 4
.el .IP "\f(CWsha512\fR" 4
.IX Item "sha512"
\&\s-1SHA\-512. \s0(since 2.7)
.ie n .IP """ripemd160""" 4
.el .IP "\f(CWripemd160\fR" 4
.IX Item "ripemd160"
\&\s-1RIPEMD\-160. \s0(since 2.7)
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoCipherAlgorithm\fR (Enum)
.PP
The supported algorithms for content encryption ciphers
.PP
\&\fBValues:\fR
.ie n .IP """aes\-128""" 4
.el .IP "\f(CWaes\-128\fR" 4
.IX Item "aes-128"
\&\s-1AES\s0 with 128 bit / 16 byte keys
.ie n .IP """aes\-192""" 4
.el .IP "\f(CWaes\-192\fR" 4
.IX Item "aes-192"
\&\s-1AES\s0 with 192 bit / 24 byte keys
.ie n .IP """aes\-256""" 4
.el .IP "\f(CWaes\-256\fR" 4
.IX Item "aes-256"
\&\s-1AES\s0 with 256 bit / 32 byte keys
.ie n .IP """des\-rfb""" 4
.el .IP "\f(CWdes\-rfb\fR" 4
.IX Item "des-rfb"
\&\s-1RFB\s0 specific variant of single \s-1DES.\s0 Do not use except in \s-1VNC.\s0
.ie n .IP """3des""" 4
.el .IP "\f(CW3des\fR" 4
.IX Item "3des"
3DES(\s-1EDE\s0) with 192 bit / 24 byte keys (since 2.9)
.ie n .IP """cast5\-128""" 4
.el .IP "\f(CWcast5\-128\fR" 4
.IX Item "cast5-128"
Cast5 with 128 bit / 16 byte keys
.ie n .IP """serpent\-128""" 4
.el .IP "\f(CWserpent\-128\fR" 4
.IX Item "serpent-128"
Serpent with 128 bit / 16 byte keys
.ie n .IP """serpent\-192""" 4
.el .IP "\f(CWserpent\-192\fR" 4
.IX Item "serpent-192"
Serpent with 192 bit / 24 byte keys
.ie n .IP """serpent\-256""" 4
.el .IP "\f(CWserpent\-256\fR" 4
.IX Item "serpent-256"
Serpent with 256 bit / 32 byte keys
.ie n .IP """twofish\-128""" 4
.el .IP "\f(CWtwofish\-128\fR" 4
.IX Item "twofish-128"
Twofish with 128 bit / 16 byte keys
.ie n .IP """twofish\-192""" 4
.el .IP "\f(CWtwofish\-192\fR" 4
.IX Item "twofish-192"
Twofish with 192 bit / 24 byte keys
.ie n .IP """twofish\-256""" 4
.el .IP "\f(CWtwofish\-256\fR" 4
.IX Item "twofish-256"
Twofish with 256 bit / 32 byte keys
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoCipherMode\fR (Enum)
.PP
The supported modes for content encryption ciphers
.PP
\&\fBValues:\fR
.ie n .IP """ecb""" 4
.el .IP "\f(CWecb\fR" 4
.IX Item "ecb"
Electronic Code Book
.ie n .IP """cbc""" 4
.el .IP "\f(CWcbc\fR" 4
.IX Item "cbc"
Cipher Block Chaining
.ie n .IP """xts""" 4
.el .IP "\f(CWxts\fR" 4
.IX Item "xts"
\&\s-1XEX\s0 with tweaked code book and ciphertext stealing
.ie n .IP """ctr""" 4
.el .IP "\f(CWctr\fR" 4
.IX Item "ctr"
Counter (Since 2.8)
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoIVGenAlgorithm\fR (Enum)
.PP
The supported algorithms for generating initialization
vectors for full disk encryption. The 'plain' generator
should not be used for disks with sector numbers larger
than 2^32, except where compatibility with pre-existing
Linux dm-crypt volumes is required.
.PP
\&\fBValues:\fR
.ie n .IP """plain""" 4
.el .IP "\f(CWplain\fR" 4
.IX Item "plain"
64\-bit sector number truncated to 32\-bits
.ie n .IP """plain64""" 4
.el .IP "\f(CWplain64\fR" 4
.IX Item "plain64"
64\-bit sector number
.ie n .IP """essiv""" 4
.el .IP "\f(CWessiv\fR" 4
.IX Item "essiv"
64\-bit sector number encrypted with a hash of the encryption key
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoBlockFormat\fR (Enum)
.PP
The supported full disk encryption formats
.PP
\&\fBValues:\fR
.ie n .IP """qcow""" 4
.el .IP "\f(CWqcow\fR" 4
.IX Item "qcow"
QCow/QCow2 built-in AES-CBC encryption. Use only
for liberating data from old images.
.ie n .IP """luks""" 4
.el .IP "\f(CWluks\fR" 4
.IX Item "luks"
\&\s-1LUKS\s0 encryption format. Recommended for new images
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoBlockOptionsBase\fR (Object)
.PP
The common options that apply to all full disk
encryption formats
.PP
\&\fBMembers:\fR
.ie n .IP """format: QCryptoBlockFormat""" 4
.el .IP "\f(CWformat: QCryptoBlockFormat\fR" 4
.IX Item "format: QCryptoBlockFormat"
the encryption format
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoBlockOptionsQCow\fR (Object)
.PP
The options that apply to QCow/QCow2 AES-CBC encryption format
.PP
\&\fBMembers:\fR
.ie n .IP """key\-secret: string"" (optional)" 4
.el .IP "\f(CWkey\-secret: string\fR (optional)" 4
.IX Item "key-secret: string (optional)"
the \s-1ID\s0 of a QCryptoSecret object providing the
decryption key. Mandatory except when probing image for
metadata only.
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoBlockOptionsLUKS\fR (Object)
.PP
The options that apply to \s-1LUKS\s0 encryption format
.PP
\&\fBMembers:\fR
.ie n .IP """key\-secret: string"" (optional)" 4
.el .IP "\f(CWkey\-secret: string\fR (optional)" 4
.IX Item "key-secret: string (optional)"
the \s-1ID\s0 of a QCryptoSecret object providing the
decryption key. Mandatory except when probing image for
metadata only.
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoBlockCreateOptionsLUKS\fR (Object)
.PP
The options that apply to \s-1LUKS\s0 encryption format initialization
.PP
\&\fBMembers:\fR
.ie n .IP """cipher\-alg: QCryptoCipherAlgorithm"" (optional)" 4
.el .IP "\f(CWcipher\-alg: QCryptoCipherAlgorithm\fR (optional)" 4
.IX Item "cipher-alg: QCryptoCipherAlgorithm (optional)"
the cipher algorithm for data encryption
Currently defaults to 'aes'.
.ie n .IP """cipher\-mode: QCryptoCipherMode"" (optional)" 4
.el .IP "\f(CWcipher\-mode: QCryptoCipherMode\fR (optional)" 4
.IX Item "cipher-mode: QCryptoCipherMode (optional)"
the cipher mode for data encryption
Currently defaults to 'cbc'
.ie n .IP """ivgen\-alg: QCryptoIVGenAlgorithm"" (optional)" 4
.el .IP "\f(CWivgen\-alg: QCryptoIVGenAlgorithm\fR (optional)" 4
.IX Item "ivgen-alg: QCryptoIVGenAlgorithm (optional)"
the initialization vector generator
Currently defaults to 'essiv'
.ie n .IP """ivgen\-hash\-alg: QCryptoHashAlgorithm"" (optional)" 4
.el .IP "\f(CWivgen\-hash\-alg: QCryptoHashAlgorithm\fR (optional)" 4
.IX Item "ivgen-hash-alg: QCryptoHashAlgorithm (optional)"
the initialization vector generator hash
Currently defaults to 'sha256'
.ie n .IP """hash\-alg: QCryptoHashAlgorithm"" (optional)" 4
.el .IP "\f(CWhash\-alg: QCryptoHashAlgorithm\fR (optional)" 4
.IX Item "hash-alg: QCryptoHashAlgorithm (optional)"
the master key hash algorithm
Currently defaults to 'sha256'
.ie n .IP """iter\-time: int"" (optional)" 4
.el .IP "\f(CWiter\-time: int\fR (optional)" 4
.IX Item "iter-time: int (optional)"
number of milliseconds to spend in
\&\s-1PBKDF\s0 passphrase processing. Currently defaults
to 2000. (since 2.8)
.ie n .IP "The members of ""QCryptoBlockOptionsLUKS""" 4
.el .IP "The members of \f(CWQCryptoBlockOptionsLUKS\fR" 4
.IX Item "The members of QCryptoBlockOptionsLUKS"
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoBlockOpenOptions\fR (Object)
.PP
The options that are available for all encryption formats
when opening an existing volume
.PP
\&\fBMembers:\fR
.ie n .IP "The members of ""QCryptoBlockOptionsBase""" 4
.el .IP "The members of \f(CWQCryptoBlockOptionsBase\fR" 4
.IX Item "The members of QCryptoBlockOptionsBase"
.PD 0
.ie n .IP "The members of ""QCryptoBlockOptionsQCow"" when ""format"" is ""qcow""" 4
.el .IP "The members of \f(CWQCryptoBlockOptionsQCow\fR when \f(CWformat\fR is ``qcow''" 4
.IX Item "The members of QCryptoBlockOptionsQCow when format is qcow"
.ie n .IP "The members of ""QCryptoBlockOptionsLUKS"" when ""format"" is ""luks""" 4
.el .IP "The members of \f(CWQCryptoBlockOptionsLUKS\fR when \f(CWformat\fR is ``luks''" 4
.IX Item "The members of QCryptoBlockOptionsLUKS when format is luks"
.PD
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoBlockCreateOptions\fR (Object)
.PP
The options that are available for all encryption formats
when initializing a new volume
.PP
\&\fBMembers:\fR
.ie n .IP "The members of ""QCryptoBlockOptionsBase""" 4
.el .IP "The members of \f(CWQCryptoBlockOptionsBase\fR" 4
.IX Item "The members of QCryptoBlockOptionsBase"
.PD 0
.ie n .IP "The members of ""QCryptoBlockOptionsQCow"" when ""format"" is ""qcow""" 4
.el .IP "The members of \f(CWQCryptoBlockOptionsQCow\fR when \f(CWformat\fR is ``qcow''" 4
.IX Item "The members of QCryptoBlockOptionsQCow when format is qcow"
.ie n .IP "The members of ""QCryptoBlockCreateOptionsLUKS"" when ""format"" is ""luks""" 4
.el .IP "The members of \f(CWQCryptoBlockCreateOptionsLUKS\fR when \f(CWformat\fR is ``luks''" 4
.IX Item "The members of QCryptoBlockCreateOptionsLUKS when format is luks"
.PD
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBQCryptoBlockInfoBase\fR (Object)
.PP
The common information that applies to all full disk
encryption formats
.PP
\&\fBMembers:\fR
.ie n .IP """format: QCryptoBlockFormat""" 4
.el .IP "\f(CWformat: QCryptoBlockFormat\fR" 4
.IX Item "format: QCryptoBlockFormat"
the encryption format
.PP
\&\fBSince:\fR
2.7
.PP
\&\fBQCryptoBlockInfoLUKSSlot\fR (Object)
.PP
Information about the \s-1LUKS\s0 block encryption key
slot options
.PP
\&\fBMembers:\fR
.ie n .IP """active: boolean""" 4
.el .IP "\f(CWactive: boolean\fR" 4
.IX Item "active: boolean"
whether the key slot is currently in use
.ie n .IP """key\-offset: int""" 4
.el .IP "\f(CWkey\-offset: int\fR" 4
.IX Item "key-offset: int"
offset to the key material in bytes
.ie n .IP """iters: int"" (optional)" 4
.el .IP "\f(CWiters: int\fR (optional)" 4
.IX Item "iters: int (optional)"
number of \s-1PBKDF2\s0 iterations for key material
.ie n .IP """stripes: int"" (optional)" 4
.el .IP "\f(CWstripes: int\fR (optional)" 4
.IX Item "stripes: int (optional)"
number of stripes for splitting key material
.PP
\&\fBSince:\fR
2.7
.PP
\&\fBQCryptoBlockInfoLUKS\fR (Object)
.PP
Information about the \s-1LUKS\s0 block encryption options
.PP
\&\fBMembers:\fR
.ie n .IP """cipher\-alg: QCryptoCipherAlgorithm""" 4
.el .IP "\f(CWcipher\-alg: QCryptoCipherAlgorithm\fR" 4
.IX Item "cipher-alg: QCryptoCipherAlgorithm"
the cipher algorithm for data encryption
.ie n .IP """cipher\-mode: QCryptoCipherMode""" 4
.el .IP "\f(CWcipher\-mode: QCryptoCipherMode\fR" 4
.IX Item "cipher-mode: QCryptoCipherMode"
the cipher mode for data encryption
.ie n .IP """ivgen\-alg: QCryptoIVGenAlgorithm""" 4
.el .IP "\f(CWivgen\-alg: QCryptoIVGenAlgorithm\fR" 4
.IX Item "ivgen-alg: QCryptoIVGenAlgorithm"
the initialization vector generator
.ie n .IP """ivgen\-hash\-alg: QCryptoHashAlgorithm"" (optional)" 4
.el .IP "\f(CWivgen\-hash\-alg: QCryptoHashAlgorithm\fR (optional)" 4
.IX Item "ivgen-hash-alg: QCryptoHashAlgorithm (optional)"
the initialization vector generator hash
.ie n .IP """hash\-alg: QCryptoHashAlgorithm""" 4
.el .IP "\f(CWhash\-alg: QCryptoHashAlgorithm\fR" 4
.IX Item "hash-alg: QCryptoHashAlgorithm"
the master key hash algorithm
.ie n .IP """payload\-offset: int""" 4
.el .IP "\f(CWpayload\-offset: int\fR" 4
.IX Item "payload-offset: int"
offset to the payload data in bytes
.ie n .IP """master\-key\-iters: int""" 4
.el .IP "\f(CWmaster\-key\-iters: int\fR" 4
.IX Item "master-key-iters: int"
number of \s-1PBKDF2\s0 iterations for key material
.ie n .IP """uuid: string""" 4
.el .IP "\f(CWuuid: string\fR" 4
.IX Item "uuid: string"
unique identifier for the volume
.ie n .IP """slots: array of QCryptoBlockInfoLUKSSlot""" 4
.el .IP "\f(CWslots: array of QCryptoBlockInfoLUKSSlot\fR" 4
.IX Item "slots: array of QCryptoBlockInfoLUKSSlot"
information about each key slot
.PP
\&\fBSince:\fR
2.7
.PP
\&\fBQCryptoBlockInfoQCow\fR (Object)
.PP
Information about the QCow block encryption options
.PP
\&\fBSince:\fR
2.7
.PP
\&\fBQCryptoBlockInfo\fR (Object)
.PP
Information about the block encryption options
.PP
\&\fBMembers:\fR
.ie n .IP "The members of ""QCryptoBlockInfoBase""" 4
.el .IP "The members of \f(CWQCryptoBlockInfoBase\fR" 4
.IX Item "The members of QCryptoBlockInfoBase"
.PD 0
.ie n .IP "The members of ""QCryptoBlockInfoQCow"" when ""format"" is ""qcow""" 4
.el .IP "The members of \f(CWQCryptoBlockInfoQCow\fR when \f(CWformat\fR is ``qcow''" 4
.IX Item "The members of QCryptoBlockInfoQCow when format is qcow"
.ie n .IP "The members of ""QCryptoBlockInfoLUKS"" when ""format"" is ""luks""" 4
.el .IP "The members of \f(CWQCryptoBlockInfoLUKS\fR when \f(CWformat\fR is ``luks''" 4
.IX Item "The members of QCryptoBlockInfoLUKS when format is luks"
.PD
.PP
\&\fBSince:\fR
2.7
.SS "\s-1QAPI\s0 block definitions"
.IX Subsection "QAPI block definitions"
\fI\s-1QAPI\s0 block core definitions (vm unrelated)\fR
.IX Subsection "QAPI block core definitions (vm unrelated)"
.PP
\&\fBSnapshotInfo\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
unique snapshot id
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
user chosen name
.ie n .IP """vm\-state\-size: int""" 4
.el .IP "\f(CWvm\-state\-size: int\fR" 4
.IX Item "vm-state-size: int"
size of the \s-1VM\s0 state
.ie n .IP """date\-sec: int""" 4
.el .IP "\f(CWdate\-sec: int\fR" 4
.IX Item "date-sec: int"
\&\s-1UTC\s0 date of the snapshot in seconds
.ie n .IP """date\-nsec: int""" 4
.el .IP "\f(CWdate\-nsec: int\fR" 4
.IX Item "date-nsec: int"
fractional part in nano seconds to be used with date-sec
.ie n .IP """vm\-clock\-sec: int""" 4
.el .IP "\f(CWvm\-clock\-sec: int\fR" 4
.IX Item "vm-clock-sec: int"
\&\s-1VM\s0 clock relative to boot in seconds
.ie n .IP """vm\-clock\-nsec: int""" 4
.el .IP "\f(CWvm\-clock\-nsec: int\fR" 4
.IX Item "vm-clock-nsec: int"
fractional part in nano seconds to be used with vm-clock-sec
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBImageInfoSpecificQCow2EncryptionBase\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """format: BlockdevQcow2EncryptionFormat""" 4
.el .IP "\f(CWformat: BlockdevQcow2EncryptionFormat\fR" 4
.IX Item "format: BlockdevQcow2EncryptionFormat"
The encryption format
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBImageInfoSpecificQCow2Encryption\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP "The members of ""ImageInfoSpecificQCow2EncryptionBase""" 4
.el .IP "The members of \f(CWImageInfoSpecificQCow2EncryptionBase\fR" 4
.IX Item "The members of ImageInfoSpecificQCow2EncryptionBase"
.PD 0
.ie n .IP "The members of ""QCryptoBlockInfoQCow"" when ""format"" is ""aes""" 4
.el .IP "The members of \f(CWQCryptoBlockInfoQCow\fR when \f(CWformat\fR is ``aes''" 4
.IX Item "The members of QCryptoBlockInfoQCow when format is aes"
.ie n .IP "The members of ""QCryptoBlockInfoLUKS"" when ""format"" is ""luks""" 4
.el .IP "The members of \f(CWQCryptoBlockInfoLUKS\fR when \f(CWformat\fR is ``luks''" 4
.IX Item "The members of QCryptoBlockInfoLUKS when format is luks"
.PD
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBImageInfoSpecificQCow2\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """compat: string""" 4
.el .IP "\f(CWcompat: string\fR" 4
.IX Item "compat: string"
compatibility level
.ie n .IP """lazy\-refcounts: boolean"" (optional)" 4
.el .IP "\f(CWlazy\-refcounts: boolean\fR (optional)" 4
.IX Item "lazy-refcounts: boolean (optional)"
on or off; only valid for compat >= 1.1
.ie n .IP """corrupt: boolean"" (optional)" 4
.el .IP "\f(CWcorrupt: boolean\fR (optional)" 4
.IX Item "corrupt: boolean (optional)"
true if the image has been marked corrupt; only valid for
compat >= 1.1 (since 2.2)
.ie n .IP """refcount\-bits: int""" 4
.el .IP "\f(CWrefcount\-bits: int\fR" 4
.IX Item "refcount-bits: int"
width of a refcount entry in bits (since 2.3)
.ie n .IP """encrypt: ImageInfoSpecificQCow2Encryption"" (optional)" 4
.el .IP "\f(CWencrypt: ImageInfoSpecificQCow2Encryption\fR (optional)" 4
.IX Item "encrypt: ImageInfoSpecificQCow2Encryption (optional)"
details about encryption parameters; only set if image
is encrypted (since 2.10)
.PP
\&\fBSince:\fR
1.7
.PP
\&\fBImageInfoSpecificVmdk\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """create\-type: string""" 4
.el .IP "\f(CWcreate\-type: string\fR" 4
.IX Item "create-type: string"
The create type of \s-1VMDK\s0 image
.ie n .IP """cid: int""" 4
.el .IP "\f(CWcid: int\fR" 4
.IX Item "cid: int"
Content id of image
.ie n .IP """parent\-cid: int""" 4
.el .IP "\f(CWparent\-cid: int\fR" 4
.IX Item "parent-cid: int"
Parent \s-1VMDK\s0 image's cid
.ie n .IP """extents: array of ImageInfo""" 4
.el .IP "\f(CWextents: array of ImageInfo\fR" 4
.IX Item "extents: array of ImageInfo"
List of extent files
.PP
\&\fBSince:\fR
1.7
.PP
\&\fBImageInfoSpecific\fR (Object)
.PP
A discriminated record of image format specific information structures.
.PP
\&\fBMembers:\fR
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
One of \*(L"qcow2\*(R", \*(L"vmdk\*(R", \*(L"luks\*(R"
.ie n .IP """data: ImageInfoSpecificQCow2"" when ""type"" is ""qcow2""" 4
.el .IP "\f(CWdata: ImageInfoSpecificQCow2\fR when \f(CWtype\fR is ``qcow2''" 4
.IX Item "data: ImageInfoSpecificQCow2 when type is qcow2"
.PD 0
.ie n .IP """data: ImageInfoSpecificVmdk"" when ""type"" is ""vmdk""" 4
.el .IP "\f(CWdata: ImageInfoSpecificVmdk\fR when \f(CWtype\fR is ``vmdk''" 4
.IX Item "data: ImageInfoSpecificVmdk when type is vmdk"
.ie n .IP """data: QCryptoBlockInfoLUKS"" when ""type"" is ""luks""" 4
.el .IP "\f(CWdata: QCryptoBlockInfoLUKS\fR when \f(CWtype\fR is ``luks''" 4
.IX Item "data: QCryptoBlockInfoLUKS when type is luks"
.PD
.PP
\&\fBSince:\fR
1.7
.PP
\&\fBImageInfo\fR (Object)
.PP
Information about a \s-1QEMU\s0 image file
.PP
\&\fBMembers:\fR
.ie n .IP """filename: string""" 4
.el .IP "\f(CWfilename: string\fR" 4
.IX Item "filename: string"
name of the image file
.ie n .IP """format: string""" 4
.el .IP "\f(CWformat: string\fR" 4
.IX Item "format: string"
format of the image file
.ie n .IP """virtual\-size: int""" 4
.el .IP "\f(CWvirtual\-size: int\fR" 4
.IX Item "virtual-size: int"
maximum capacity in bytes of the image
.ie n .IP """actual\-size: int"" (optional)" 4
.el .IP "\f(CWactual\-size: int\fR (optional)" 4
.IX Item "actual-size: int (optional)"
actual size on disk in bytes of the image
.ie n .IP """dirty\-flag: boolean"" (optional)" 4
.el .IP "\f(CWdirty\-flag: boolean\fR (optional)" 4
.IX Item "dirty-flag: boolean (optional)"
true if image is not cleanly closed
.ie n .IP """cluster\-size: int"" (optional)" 4
.el .IP "\f(CWcluster\-size: int\fR (optional)" 4
.IX Item "cluster-size: int (optional)"
size of a cluster in bytes
.ie n .IP """encrypted: boolean"" (optional)" 4
.el .IP "\f(CWencrypted: boolean\fR (optional)" 4
.IX Item "encrypted: boolean (optional)"
true if the image is encrypted
.ie n .IP """compressed: boolean"" (optional)" 4
.el .IP "\f(CWcompressed: boolean\fR (optional)" 4
.IX Item "compressed: boolean (optional)"
true if the image is compressed (Since 1.7)
.ie n .IP """backing\-filename: string"" (optional)" 4
.el .IP "\f(CWbacking\-filename: string\fR (optional)" 4
.IX Item "backing-filename: string (optional)"
name of the backing file
.ie n .IP """full\-backing\-filename: string"" (optional)" 4
.el .IP "\f(CWfull\-backing\-filename: string\fR (optional)" 4
.IX Item "full-backing-filename: string (optional)"
full path of the backing file
.ie n .IP """backing\-filename\-format: string"" (optional)" 4
.el .IP "\f(CWbacking\-filename\-format: string\fR (optional)" 4
.IX Item "backing-filename-format: string (optional)"
the format of the backing file
.ie n .IP """snapshots: array of SnapshotInfo"" (optional)" 4
.el .IP "\f(CWsnapshots: array of SnapshotInfo\fR (optional)" 4
.IX Item "snapshots: array of SnapshotInfo (optional)"
list of \s-1VM\s0 snapshots
.ie n .IP """backing\-image: ImageInfo"" (optional)" 4
.el .IP "\f(CWbacking\-image: ImageInfo\fR (optional)" 4
.IX Item "backing-image: ImageInfo (optional)"
info of the backing image (since 1.6)
.ie n .IP """format\-specific: ImageInfoSpecific"" (optional)" 4
.el .IP "\f(CWformat\-specific: ImageInfoSpecific\fR (optional)" 4
.IX Item "format-specific: ImageInfoSpecific (optional)"
structure supplying additional format-specific
information (since 1.7)
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBImageCheck\fR (Object)
.PP
Information about a \s-1QEMU\s0 image file check
.PP
\&\fBMembers:\fR
.ie n .IP """filename: string""" 4
.el .IP "\f(CWfilename: string\fR" 4
.IX Item "filename: string"
name of the image file checked
.ie n .IP """format: string""" 4
.el .IP "\f(CWformat: string\fR" 4
.IX Item "format: string"
format of the image file checked
.ie n .IP """check\-errors: int""" 4
.el .IP "\f(CWcheck\-errors: int\fR" 4
.IX Item "check-errors: int"
number of unexpected errors occurred during check
.ie n .IP """image\-end\-offset: int"" (optional)" 4
.el .IP "\f(CWimage\-end\-offset: int\fR (optional)" 4
.IX Item "image-end-offset: int (optional)"
offset (in bytes) where the image ends, this
field is present if the driver for the image format
supports it
.ie n .IP """corruptions: int"" (optional)" 4
.el .IP "\f(CWcorruptions: int\fR (optional)" 4
.IX Item "corruptions: int (optional)"
number of corruptions found during the check if any
.ie n .IP """leaks: int"" (optional)" 4
.el .IP "\f(CWleaks: int\fR (optional)" 4
.IX Item "leaks: int (optional)"
number of leaks found during the check if any
.ie n .IP """corruptions\-fixed: int"" (optional)" 4
.el .IP "\f(CWcorruptions\-fixed: int\fR (optional)" 4
.IX Item "corruptions-fixed: int (optional)"
number of corruptions fixed during the check
if any
.ie n .IP """leaks\-fixed: int"" (optional)" 4
.el .IP "\f(CWleaks\-fixed: int\fR (optional)" 4
.IX Item "leaks-fixed: int (optional)"
number of leaks fixed during the check if any
.ie n .IP """total\-clusters: int"" (optional)" 4
.el .IP "\f(CWtotal\-clusters: int\fR (optional)" 4
.IX Item "total-clusters: int (optional)"
total number of clusters, this field is present
if the driver for the image format supports it
.ie n .IP """allocated\-clusters: int"" (optional)" 4
.el .IP "\f(CWallocated\-clusters: int\fR (optional)" 4
.IX Item "allocated-clusters: int (optional)"
total number of allocated clusters, this
field is present if the driver for the image format
supports it
.ie n .IP """fragmented\-clusters: int"" (optional)" 4
.el .IP "\f(CWfragmented\-clusters: int\fR (optional)" 4
.IX Item "fragmented-clusters: int (optional)"
total number of fragmented clusters, this
field is present if the driver for the image format
supports it
.ie n .IP """compressed\-clusters: int"" (optional)" 4
.el .IP "\f(CWcompressed\-clusters: int\fR (optional)" 4
.IX Item "compressed-clusters: int (optional)"
total number of compressed clusters, this
field is present if the driver for the image format
supports it
.PP
\&\fBSince:\fR
1.4
.PP
\&\fBMapEntry\fR (Object)
.PP
Mapping information from a virtual block range to a host file range
.PP
\&\fBMembers:\fR
.ie n .IP """start: int""" 4
.el .IP "\f(CWstart: int\fR" 4
.IX Item "start: int"
the start byte of the mapped virtual range
.ie n .IP """length: int""" 4
.el .IP "\f(CWlength: int\fR" 4
.IX Item "length: int"
the number of bytes of the mapped virtual range
.ie n .IP """data: boolean""" 4
.el .IP "\f(CWdata: boolean\fR" 4
.IX Item "data: boolean"
whether the mapped range has data
.ie n .IP """zero: boolean""" 4
.el .IP "\f(CWzero: boolean\fR" 4
.IX Item "zero: boolean"
whether the virtual blocks are zeroed
.ie n .IP """depth: int""" 4
.el .IP "\f(CWdepth: int\fR" 4
.IX Item "depth: int"
the depth of the mapping
.ie n .IP """offset: int"" (optional)" 4
.el .IP "\f(CWoffset: int\fR (optional)" 4
.IX Item "offset: int (optional)"
the offset in file that the virtual sectors are mapped to
.ie n .IP """filename: string"" (optional)" 4
.el .IP "\f(CWfilename: string\fR (optional)" 4
.IX Item "filename: string (optional)"
filename that is referred to by \f(CW\*(C`offset\*(C'\fR
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBBlockdevCacheInfo\fR (Object)
.PP
Cache mode information for a block device
.PP
\&\fBMembers:\fR
.ie n .IP """writeback: boolean""" 4
.el .IP "\f(CWwriteback: boolean\fR" 4
.IX Item "writeback: boolean"
true if writeback mode is enabled
.ie n .IP """direct: boolean""" 4
.el .IP "\f(CWdirect: boolean\fR" 4
.IX Item "direct: boolean"
true if the host page cache is bypassed (O_DIRECT)
.ie n .IP """no\-flush: boolean""" 4
.el .IP "\f(CWno\-flush: boolean\fR" 4
.IX Item "no-flush: boolean"
true if flush requests are ignored for the device
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBBlockDeviceInfo\fR (Object)
.PP
Information about the backing device for a block device.
.PP
\&\fBMembers:\fR
.ie n .IP """file: string""" 4
.el .IP "\f(CWfile: string\fR" 4
.IX Item "file: string"
the filename of the backing device
.ie n .IP """node\-name: string"" (optional)" 4
.el .IP "\f(CWnode\-name: string\fR (optional)" 4
.IX Item "node-name: string (optional)"
the name of the block driver node (Since 2.0)
.ie n .IP """ro: boolean""" 4
.el .IP "\f(CWro: boolean\fR" 4
.IX Item "ro: boolean"
true if the backing device was open read-only
.ie n .IP """drv: string""" 4
.el .IP "\f(CWdrv: string\fR" 4
.IX Item "drv: string"
the name of the block format used to open the backing device. As of
0.14.0 this can be: 'blkdebug', 'bochs', 'cloop', 'cow', 'dmg',
\&'file', 'file', 'ftp', 'ftps', 'host_cdrom', 'host_device',
\&'http', 'https', 'luks', 'nbd', 'parallels', 'qcow',
\&'qcow2', 'raw', 'vdi', 'vmdk', 'vpc', 'vvfat'
2.2: 'archipelago' added, 'cow' dropped
2.3: 'host_floppy' deprecated
2.5: 'host_floppy' dropped
2.6: 'luks' added
2.8: 'replication' added, 'tftp' dropped
2.9: 'archipelago' dropped
.ie n .IP """backing_file: string"" (optional)" 4
.el .IP "\f(CWbacking_file: string\fR (optional)" 4
.IX Item "backing_file: string (optional)"
the name of the backing file (for copy-on-write)
.ie n .IP """backing_file_depth: int""" 4
.el .IP "\f(CWbacking_file_depth: int\fR" 4
.IX Item "backing_file_depth: int"
number of files in the backing file chain (since: 1.2)
.ie n .IP """encrypted: boolean""" 4
.el .IP "\f(CWencrypted: boolean\fR" 4
.IX Item "encrypted: boolean"
true if the backing device is encrypted
.ie n .IP """encryption_key_missing: boolean""" 4
.el .IP "\f(CWencryption_key_missing: boolean\fR" 4
.IX Item "encryption_key_missing: boolean"
Deprecated; always false
.ie n .IP """detect_zeroes: BlockdevDetectZeroesOptions""" 4
.el .IP "\f(CWdetect_zeroes: BlockdevDetectZeroesOptions\fR" 4
.IX Item "detect_zeroes: BlockdevDetectZeroesOptions"
detect and optimize zero writes (Since 2.1)
.ie n .IP """bps: int""" 4
.el .IP "\f(CWbps: int\fR" 4
.IX Item "bps: int"
total throughput limit in bytes per second is specified
.ie n .IP """bps_rd: int""" 4
.el .IP "\f(CWbps_rd: int\fR" 4
.IX Item "bps_rd: int"
read throughput limit in bytes per second is specified
.ie n .IP """bps_wr: int""" 4
.el .IP "\f(CWbps_wr: int\fR" 4
.IX Item "bps_wr: int"
write throughput limit in bytes per second is specified
.ie n .IP """iops: int""" 4
.el .IP "\f(CWiops: int\fR" 4
.IX Item "iops: int"
total I/O operations per second is specified
.ie n .IP """iops_rd: int""" 4
.el .IP "\f(CWiops_rd: int\fR" 4
.IX Item "iops_rd: int"
read I/O operations per second is specified
.ie n .IP """iops_wr: int""" 4
.el .IP "\f(CWiops_wr: int\fR" 4
.IX Item "iops_wr: int"
write I/O operations per second is specified
.ie n .IP """image: ImageInfo""" 4
.el .IP "\f(CWimage: ImageInfo\fR" 4
.IX Item "image: ImageInfo"
the info of image used (since: 1.6)
.ie n .IP """bps_max: int"" (optional)" 4
.el .IP "\f(CWbps_max: int\fR (optional)" 4
.IX Item "bps_max: int (optional)"
total throughput limit during bursts,
in bytes (Since 1.7)
.ie n .IP """bps_rd_max: int"" (optional)" 4
.el .IP "\f(CWbps_rd_max: int\fR (optional)" 4
.IX Item "bps_rd_max: int (optional)"
read throughput limit during bursts,
in bytes (Since 1.7)
.ie n .IP """bps_wr_max: int"" (optional)" 4
.el .IP "\f(CWbps_wr_max: int\fR (optional)" 4
.IX Item "bps_wr_max: int (optional)"
write throughput limit during bursts,
in bytes (Since 1.7)
.ie n .IP """iops_max: int"" (optional)" 4
.el .IP "\f(CWiops_max: int\fR (optional)" 4
.IX Item "iops_max: int (optional)"
total I/O operations per second during bursts,
in bytes (Since 1.7)
.ie n .IP """iops_rd_max: int"" (optional)" 4
.el .IP "\f(CWiops_rd_max: int\fR (optional)" 4
.IX Item "iops_rd_max: int (optional)"
read I/O operations per second during bursts,
in bytes (Since 1.7)
.ie n .IP """iops_wr_max: int"" (optional)" 4
.el .IP "\f(CWiops_wr_max: int\fR (optional)" 4
.IX Item "iops_wr_max: int (optional)"
write I/O operations per second during bursts,
in bytes (Since 1.7)
.ie n .IP """bps_max_length: int"" (optional)" 4
.el .IP "\f(CWbps_max_length: int\fR (optional)" 4
.IX Item "bps_max_length: int (optional)"
maximum length of the \f(CW\*(C`bps_max\*(C'\fR burst
period, in seconds. (Since 2.6)
.ie n .IP """bps_rd_max_length: int"" (optional)" 4
.el .IP "\f(CWbps_rd_max_length: int\fR (optional)" 4
.IX Item "bps_rd_max_length: int (optional)"
maximum length of the \f(CW\*(C`bps_rd_max\*(C'\fR
burst period, in seconds. (Since 2.6)
.ie n .IP """bps_wr_max_length: int"" (optional)" 4
.el .IP "\f(CWbps_wr_max_length: int\fR (optional)" 4
.IX Item "bps_wr_max_length: int (optional)"
maximum length of the \f(CW\*(C`bps_wr_max\*(C'\fR
burst period, in seconds. (Since 2.6)
.ie n .IP """iops_max_length: int"" (optional)" 4
.el .IP "\f(CWiops_max_length: int\fR (optional)" 4
.IX Item "iops_max_length: int (optional)"
maximum length of the \f(CW\*(C`iops\*(C'\fR burst
period, in seconds. (Since 2.6)
.ie n .IP """iops_rd_max_length: int"" (optional)" 4
.el .IP "\f(CWiops_rd_max_length: int\fR (optional)" 4
.IX Item "iops_rd_max_length: int (optional)"
maximum length of the \f(CW\*(C`iops_rd_max\*(C'\fR
burst period, in seconds. (Since 2.6)
.ie n .IP """iops_wr_max_length: int"" (optional)" 4
.el .IP "\f(CWiops_wr_max_length: int\fR (optional)" 4
.IX Item "iops_wr_max_length: int (optional)"
maximum length of the \f(CW\*(C`iops_wr_max\*(C'\fR
burst period, in seconds. (Since 2.6)
.ie n .IP """iops_size: int"" (optional)" 4
.el .IP "\f(CWiops_size: int\fR (optional)" 4
.IX Item "iops_size: int (optional)"
an I/O size in bytes (Since 1.7)
.ie n .IP """group: string"" (optional)" 4
.el .IP "\f(CWgroup: string\fR (optional)" 4
.IX Item "group: string (optional)"
throttle group name (Since 2.4)
.ie n .IP """cache: BlockdevCacheInfo""" 4
.el .IP "\f(CWcache: BlockdevCacheInfo\fR" 4
.IX Item "cache: BlockdevCacheInfo"
the cache mode used for the block device (since: 2.3)
.ie n .IP """write_threshold: int""" 4
.el .IP "\f(CWwrite_threshold: int\fR" 4
.IX Item "write_threshold: int"
configured write threshold for the device.
0 if disabled. (Since 2.3)
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBBlockDeviceIoStatus\fR (Enum)
.PP
An enumeration of block device I/O status.
.PP
\&\fBValues:\fR
.ie n .IP """ok""" 4
.el .IP "\f(CWok\fR" 4
.IX Item "ok"
The last I/O operation has succeeded
.ie n .IP """failed""" 4
.el .IP "\f(CWfailed\fR" 4
.IX Item "failed"
The last I/O operation has failed
.ie n .IP """nospace""" 4
.el .IP "\f(CWnospace\fR" 4
.IX Item "nospace"
The last I/O operation has failed due to a no-space condition
.PP
\&\fBSince:\fR
1.0
.PP
\&\fBBlockDeviceMapEntry\fR (Object)
.PP
Entry in the metadata map of the device (returned by \*(L"qemu-img map\*(R")
.PP
\&\fBMembers:\fR
.ie n .IP """start: int""" 4
.el .IP "\f(CWstart: int\fR" 4
.IX Item "start: int"
Offset in the image of the first byte described by this entry
(in bytes)
.ie n .IP """length: int""" 4
.el .IP "\f(CWlength: int\fR" 4
.IX Item "length: int"
Length of the range described by this entry (in bytes)
.ie n .IP """depth: int""" 4
.el .IP "\f(CWdepth: int\fR" 4
.IX Item "depth: int"
Number of layers (0 = top image, 1 = top image's backing file, etc.)
before reaching one for which the range is allocated.  The value is
in the range 0 to the depth of the image chain \- 1.
.ie n .IP """zero: boolean""" 4
.el .IP "\f(CWzero: boolean\fR" 4
.IX Item "zero: boolean"
the sectors in this range read as zeros
.ie n .IP """data: boolean""" 4
.el .IP "\f(CWdata: boolean\fR" 4
.IX Item "data: boolean"
reading the image will actually read data from a file (in particular,
if \f(CW\*(C`offset\*(C'\fR is present this means that the sectors are not simply
preallocated, but contain actual data in raw format)
.ie n .IP """offset: int"" (optional)" 4
.el .IP "\f(CWoffset: int\fR (optional)" 4
.IX Item "offset: int (optional)"
if present, the image file stores the data for this range in
raw format at the given offset.
.PP
\&\fBSince:\fR
1.7
.PP
\&\fBDirtyBitmapStatus\fR (Enum)
.PP
An enumeration of possible states that a dirty bitmap can report to the user.
.PP
\&\fBValues:\fR
.ie n .IP """frozen""" 4
.el .IP "\f(CWfrozen\fR" 4
.IX Item "frozen"
The bitmap is currently in-use by a backup operation or block job,
and is immutable.
.ie n .IP """disabled""" 4
.el .IP "\f(CWdisabled\fR" 4
.IX Item "disabled"
The bitmap is currently in-use by an internal operation and is
read-only. It can still be deleted.
.ie n .IP """active""" 4
.el .IP "\f(CWactive\fR" 4
.IX Item "active"
The bitmap is actively monitoring for new writes, and can be cleared,
deleted, or used for backup operations.
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBBlockDirtyInfo\fR (Object)
.PP
Block dirty bitmap information.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string"" (optional)" 4
.el .IP "\f(CWname: string\fR (optional)" 4
.IX Item "name: string (optional)"
the name of the dirty bitmap (Since 2.4)
.ie n .IP """count: int""" 4
.el .IP "\f(CWcount: int\fR" 4
.IX Item "count: int"
number of dirty bytes according to the dirty bitmap
.ie n .IP """granularity: int""" 4
.el .IP "\f(CWgranularity: int\fR" 4
.IX Item "granularity: int"
granularity of the dirty bitmap in bytes (since 1.4)
.ie n .IP """status: DirtyBitmapStatus""" 4
.el .IP "\f(CWstatus: DirtyBitmapStatus\fR" 4
.IX Item "status: DirtyBitmapStatus"
current status of the dirty bitmap (since 2.4)
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBBlockInfo\fR (Object)
.PP
Block device information.  This structure describes a virtual device and
the backing device associated with it.
.PP
\&\fBMembers:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The device name associated with the virtual device.
.ie n .IP """qdev: string"" (optional)" 4
.el .IP "\f(CWqdev: string\fR (optional)" 4
.IX Item "qdev: string (optional)"
The qdev \s-1ID,\s0 or if no \s-1ID\s0 is assigned, the \s-1QOM\s0 path of the block
device. (since 2.10)
.ie n .IP """type: string""" 4
.el .IP "\f(CWtype: string\fR" 4
.IX Item "type: string"
This field is returned only for compatibility reasons, it should
not be used (always returns 'unknown')
.ie n .IP """removable: boolean""" 4
.el .IP "\f(CWremovable: boolean\fR" 4
.IX Item "removable: boolean"
True if the device supports removable media.
.ie n .IP """locked: boolean""" 4
.el .IP "\f(CWlocked: boolean\fR" 4
.IX Item "locked: boolean"
True if the guest has locked this device from having its media
removed
.ie n .IP """tray_open: boolean"" (optional)" 4
.el .IP "\f(CWtray_open: boolean\fR (optional)" 4
.IX Item "tray_open: boolean (optional)"
True if the device's tray is open
(only present if it has a tray)
.ie n .IP """dirty\-bitmaps: array of BlockDirtyInfo"" (optional)" 4
.el .IP "\f(CWdirty\-bitmaps: array of BlockDirtyInfo\fR (optional)" 4
.IX Item "dirty-bitmaps: array of BlockDirtyInfo (optional)"
dirty bitmaps information (only present if the
driver has one or more dirty bitmaps) (Since 2.0)
.ie n .IP """io\-status: BlockDeviceIoStatus"" (optional)" 4
.el .IP "\f(CWio\-status: BlockDeviceIoStatus\fR (optional)" 4
.IX Item "io-status: BlockDeviceIoStatus (optional)"
\&\f(CW\*(C`BlockDeviceIoStatus\*(C'\fR. Only present if the device
supports it and the \s-1VM\s0 is configured to stop on errors
(supported device models: virtio-blk, \s-1IDE, SCSI\s0 except
scsi-generic)
.ie n .IP """inserted: BlockDeviceInfo"" (optional)" 4
.el .IP "\f(CWinserted: BlockDeviceInfo\fR (optional)" 4
.IX Item "inserted: BlockDeviceInfo (optional)"
\&\f(CW\*(C`BlockDeviceInfo\*(C'\fR describing the device if media is
present
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBBlockMeasureInfo\fR (Object)
.PP
Image file size calculation information.  This structure describes the size
requirements for creating a new image file.
.PP
The size requirements depend on the new image file format.  File size always
equals virtual disk size for the 'raw' format, even for sparse \s-1POSIX\s0 files.
Compact formats such as 'qcow2' represent unallocated and zero regions
efficiently so file size may be smaller than virtual disk size.
.PP
The values are upper bounds that are guaranteed to fit the new image file.
Subsequent modification, such as internal snapshot or bitmap creation, may
require additional space and is not covered here.
.PP
\&\fBMembers:\fR
.ie n .IP """required: int""" 4
.el .IP "\f(CWrequired: int\fR" 4
.IX Item "required: int"
Size required for a new image file, in bytes.
.ie n .IP """fully\-allocated: int""" 4
.el .IP "\f(CWfully\-allocated: int\fR" 4
.IX Item "fully-allocated: int"
Image file size, in bytes, once data has been written
to all sectors.
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBquery-block\fR  (Command)
Get a list of BlockInfo for all virtual block devices.
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`BlockInfo\*(C'\fR describing each virtual block device. Filter
nodes that were created implicitly are skipped over.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-block" }
\&        <\- {
\&              "return":[
\&                 {
\&                    "io\-status": "ok",
\&                    "device":"ide0\-hd0",
\&                    "locked":false,
\&                    "removable":false,
\&                    "inserted":{
\&                       "ro":false,
\&                       "drv":"qcow2",
\&                       "encrypted":false,
\&                       "file":"disks/test.qcow2",
\&                       "backing_file_depth":1,
\&                       "bps":1000000,
\&                       "bps_rd":0,
\&                       "bps_wr":0,
\&                       "iops":1000000,
\&                       "iops_rd":0,
\&                       "iops_wr":0,
\&                       "bps_max": 8000000,
\&                       "bps_rd_max": 0,
\&                       "bps_wr_max": 0,
\&                       "iops_max": 0,
\&                       "iops_rd_max": 0,
\&                       "iops_wr_max": 0,
\&                       "iops_size": 0,
\&                       "detect_zeroes": "on",
\&                       "write_threshold": 0,
\&                       "image":{
\&                          "filename":"disks/test.qcow2",
\&                          "format":"qcow2",
\&                          "virtual\-size":2048000,
\&                          "backing_file":"base.qcow2",
\&                          "full\-backing\-filename":"disks/base.qcow2",
\&                          "backing\-filename\-format":"qcow2",
\&                          "snapshots":[
\&                             {
\&                                "id": "1",
\&                                "name": "snapshot1",
\&                                "vm\-state\-size": 0,
\&                                "date\-sec": 10000200,
\&                                "date\-nsec": 12,
\&                                "vm\-clock\-sec": 206,
\&                                "vm\-clock\-nsec": 30
\&                             }
\&                          ],
\&                          "backing\-image":{
\&                              "filename":"disks/base.qcow2",
\&                              "format":"qcow2",
\&                              "virtual\-size":2048000
\&                          }
\&                       }
\&                    },
\&                    "qdev": "ide_disk",
\&                    "type":"unknown"
\&                 },
\&                 {
\&                    "io\-status": "ok",
\&                    "device":"ide1\-cd0",
\&                    "locked":false,
\&                    "removable":true,
\&                    "qdev": "/machine/unattached/device[23]",
\&                    "tray_open": false,
\&                    "type":"unknown"
\&                 },
\&                 {
\&                    "device":"floppy0",
\&                    "locked":false,
\&                    "removable":true,
\&                    "qdev": "/machine/unattached/device[20]",
\&                    "type":"unknown"
\&                 },
\&                 {
\&                    "device":"sd0",
\&                    "locked":false,
\&                    "removable":true,
\&                    "type":"unknown"
\&                 }
\&              ]
\&           }
.Ve
.PP
\&\fBBlockDeviceTimedStats\fR (Object)
.PP
Statistics of a block device during a given interval of time.
.PP
\&\fBMembers:\fR
.ie n .IP """interval_length: int""" 4
.el .IP "\f(CWinterval_length: int\fR" 4
.IX Item "interval_length: int"
Interval used for calculating the statistics,
in seconds.
.ie n .IP """min_rd_latency_ns: int""" 4
.el .IP "\f(CWmin_rd_latency_ns: int\fR" 4
.IX Item "min_rd_latency_ns: int"
Minimum latency of read operations in the
defined interval, in nanoseconds.
.ie n .IP """min_wr_latency_ns: int""" 4
.el .IP "\f(CWmin_wr_latency_ns: int\fR" 4
.IX Item "min_wr_latency_ns: int"
Minimum latency of write operations in the
defined interval, in nanoseconds.
.ie n .IP """min_flush_latency_ns: int""" 4
.el .IP "\f(CWmin_flush_latency_ns: int\fR" 4
.IX Item "min_flush_latency_ns: int"
Minimum latency of flush operations in the
defined interval, in nanoseconds.
.ie n .IP """max_rd_latency_ns: int""" 4
.el .IP "\f(CWmax_rd_latency_ns: int\fR" 4
.IX Item "max_rd_latency_ns: int"
Maximum latency of read operations in the
defined interval, in nanoseconds.
.ie n .IP """max_wr_latency_ns: int""" 4
.el .IP "\f(CWmax_wr_latency_ns: int\fR" 4
.IX Item "max_wr_latency_ns: int"
Maximum latency of write operations in the
defined interval, in nanoseconds.
.ie n .IP """max_flush_latency_ns: int""" 4
.el .IP "\f(CWmax_flush_latency_ns: int\fR" 4
.IX Item "max_flush_latency_ns: int"
Maximum latency of flush operations in the
defined interval, in nanoseconds.
.ie n .IP """avg_rd_latency_ns: int""" 4
.el .IP "\f(CWavg_rd_latency_ns: int\fR" 4
.IX Item "avg_rd_latency_ns: int"
Average latency of read operations in the
defined interval, in nanoseconds.
.ie n .IP """avg_wr_latency_ns: int""" 4
.el .IP "\f(CWavg_wr_latency_ns: int\fR" 4
.IX Item "avg_wr_latency_ns: int"
Average latency of write operations in the
defined interval, in nanoseconds.
.ie n .IP """avg_flush_latency_ns: int""" 4
.el .IP "\f(CWavg_flush_latency_ns: int\fR" 4
.IX Item "avg_flush_latency_ns: int"
Average latency of flush operations in the
defined interval, in nanoseconds.
.ie n .IP """avg_rd_queue_depth: number""" 4
.el .IP "\f(CWavg_rd_queue_depth: number\fR" 4
.IX Item "avg_rd_queue_depth: number"
Average number of pending read operations
in the defined interval.
.ie n .IP """avg_wr_queue_depth: number""" 4
.el .IP "\f(CWavg_wr_queue_depth: number\fR" 4
.IX Item "avg_wr_queue_depth: number"
Average number of pending write operations
in the defined interval.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBBlockDeviceStats\fR (Object)
.PP
Statistics of a virtual block device or a block backing device.
.PP
\&\fBMembers:\fR
.ie n .IP """rd_bytes: int""" 4
.el .IP "\f(CWrd_bytes: int\fR" 4
.IX Item "rd_bytes: int"
The number of bytes read by the device.
.ie n .IP """wr_bytes: int""" 4
.el .IP "\f(CWwr_bytes: int\fR" 4
.IX Item "wr_bytes: int"
The number of bytes written by the device.
.ie n .IP """rd_operations: int""" 4
.el .IP "\f(CWrd_operations: int\fR" 4
.IX Item "rd_operations: int"
The number of read operations performed by the device.
.ie n .IP """wr_operations: int""" 4
.el .IP "\f(CWwr_operations: int\fR" 4
.IX Item "wr_operations: int"
The number of write operations performed by the device.
.ie n .IP """flush_operations: int""" 4
.el .IP "\f(CWflush_operations: int\fR" 4
.IX Item "flush_operations: int"
The number of cache flush operations performed by the
device (since 0.15.0)
.ie n .IP """flush_total_time_ns: int""" 4
.el .IP "\f(CWflush_total_time_ns: int\fR" 4
.IX Item "flush_total_time_ns: int"
Total time spend on cache flushes in nano-seconds
(since 0.15.0).
.ie n .IP """wr_total_time_ns: int""" 4
.el .IP "\f(CWwr_total_time_ns: int\fR" 4
.IX Item "wr_total_time_ns: int"
Total time spend on writes in nano-seconds (since 0.15.0).
.ie n .IP """rd_total_time_ns: int""" 4
.el .IP "\f(CWrd_total_time_ns: int\fR" 4
.IX Item "rd_total_time_ns: int"
Total_time_spend on reads in nano-seconds (since 0.15.0).
.ie n .IP """wr_highest_offset: int""" 4
.el .IP "\f(CWwr_highest_offset: int\fR" 4
.IX Item "wr_highest_offset: int"
The offset after the greatest byte written to the
device.  The intended use of this information is for
growable sparse files (like qcow2) that are used on top
of a physical device.
.ie n .IP """rd_merged: int""" 4
.el .IP "\f(CWrd_merged: int\fR" 4
.IX Item "rd_merged: int"
Number of read requests that have been merged into another
request (Since 2.3).
.ie n .IP """wr_merged: int""" 4
.el .IP "\f(CWwr_merged: int\fR" 4
.IX Item "wr_merged: int"
Number of write requests that have been merged into another
request (Since 2.3).
.ie n .IP """idle_time_ns: int"" (optional)" 4
.el .IP "\f(CWidle_time_ns: int\fR (optional)" 4
.IX Item "idle_time_ns: int (optional)"
Time since the last I/O operation, in
nanoseconds. If the field is absent it means that
there haven't been any operations yet (Since 2.5).
.ie n .IP """failed_rd_operations: int""" 4
.el .IP "\f(CWfailed_rd_operations: int\fR" 4
.IX Item "failed_rd_operations: int"
The number of failed read operations
performed by the device (Since 2.5)
.ie n .IP """failed_wr_operations: int""" 4
.el .IP "\f(CWfailed_wr_operations: int\fR" 4
.IX Item "failed_wr_operations: int"
The number of failed write operations
performed by the device (Since 2.5)
.ie n .IP """failed_flush_operations: int""" 4
.el .IP "\f(CWfailed_flush_operations: int\fR" 4
.IX Item "failed_flush_operations: int"
The number of failed flush operations
performed by the device (Since 2.5)
.ie n .IP """invalid_rd_operations: int""" 4
.el .IP "\f(CWinvalid_rd_operations: int\fR" 4
.IX Item "invalid_rd_operations: int"
The number of invalid read operations
performed by the device (Since 2.5)
.ie n .IP """invalid_wr_operations: int""" 4
.el .IP "\f(CWinvalid_wr_operations: int\fR" 4
.IX Item "invalid_wr_operations: int"
The number of invalid write operations
performed by the device (Since 2.5)
.ie n .IP """invalid_flush_operations: int""" 4
.el .IP "\f(CWinvalid_flush_operations: int\fR" 4
.IX Item "invalid_flush_operations: int"
The number of invalid flush operations
performed by the device (Since 2.5)
.ie n .IP """account_invalid: boolean""" 4
.el .IP "\f(CWaccount_invalid: boolean\fR" 4
.IX Item "account_invalid: boolean"
Whether invalid operations are included in the
last access statistics (Since 2.5)
.ie n .IP """account_failed: boolean""" 4
.el .IP "\f(CWaccount_failed: boolean\fR" 4
.IX Item "account_failed: boolean"
Whether failed operations are included in the
latency and last access statistics (Since 2.5)
.ie n .IP """timed_stats: array of BlockDeviceTimedStats""" 4
.el .IP "\f(CWtimed_stats: array of BlockDeviceTimedStats\fR" 4
.IX Item "timed_stats: array of BlockDeviceTimedStats"
Statistics specific to the set of previously defined
intervals of time (Since 2.5)
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBBlockStats\fR (Object)
.PP
Statistics of a virtual block device or a block backing device.
.PP
\&\fBMembers:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
If the stats are for a virtual block device, the name
corresponding to the virtual block device.
.ie n .IP """node\-name: string"" (optional)" 4
.el .IP "\f(CWnode\-name: string\fR (optional)" 4
.IX Item "node-name: string (optional)"
The node name of the device. (Since 2.3)
.ie n .IP """stats: BlockDeviceStats""" 4
.el .IP "\f(CWstats: BlockDeviceStats\fR" 4
.IX Item "stats: BlockDeviceStats"
A \f(CW\*(C`BlockDeviceStats\*(C'\fR for the device.
.ie n .IP """parent: BlockStats"" (optional)" 4
.el .IP "\f(CWparent: BlockStats\fR (optional)" 4
.IX Item "parent: BlockStats (optional)"
This describes the file block device if it has one.
Contains recursively the statistics of the underlying
protocol (e.g. the host file for a qcow2 image). If there is
no underlying protocol, this field is omitted
.ie n .IP """backing: BlockStats"" (optional)" 4
.el .IP "\f(CWbacking: BlockStats\fR (optional)" 4
.IX Item "backing: BlockStats (optional)"
This describes the backing block device if it has one.
(Since 2.0)
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBquery-blockstats\fR  (Command)
Query the \f(CW\*(C`BlockStats\*(C'\fR for all virtual block devices.
.PP
\&\fBArguments:\fR
.ie n .IP """query\-nodes: boolean"" (optional)" 4
.el .IP "\f(CWquery\-nodes: boolean\fR (optional)" 4
.IX Item "query-nodes: boolean (optional)"
If true, the command will query all the block nodes
that have a node name, in a list which will include \*(L"parent\*(R"
information, but not \*(L"backing\*(R".
If false or omitted, the behavior is as before \- query all the
device backends, recursively including their \*(L"parent\*(R" and
\&\*(L"backing\*(R". Filter nodes that were created implicitly are
skipped over in this mode. (Since 2.3)
.PP
\&\fBReturns:\fR
A list of \f(CW\*(C`BlockStats\*(C'\fR for each virtual block devices.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-blockstats" }
\&        <\- {
\&              "return":[
\&                 {
\&                    "device":"ide0\-hd0",
\&                    "parent":{
\&                       "stats":{
\&                          "wr_highest_offset":3686448128,
\&                          "wr_bytes":9786368,
\&                          "wr_operations":751,
\&                          "rd_bytes":122567168,
\&                          "rd_operations":36772
\&                          "wr_total_times_ns":313253456
\&                          "rd_total_times_ns":3465673657
\&                          "flush_total_times_ns":49653
\&                          "flush_operations":61,
\&                          "rd_merged":0,
\&                          "wr_merged":0,
\&                          "idle_time_ns":2953431879,
\&                          "account_invalid":true,
\&                          "account_failed":false
\&                       }
\&                    },
\&                    "stats":{
\&                       "wr_highest_offset":2821110784,
\&                       "wr_bytes":9786368,
\&                       "wr_operations":692,
\&                       "rd_bytes":122739200,
\&                       "rd_operations":36604
\&                       "flush_operations":51,
\&                       "wr_total_times_ns":313253456
\&                       "rd_total_times_ns":3465673657
\&                       "flush_total_times_ns":49653,
\&                       "rd_merged":0,
\&                       "wr_merged":0,
\&                       "idle_time_ns":2953431879,
\&                       "account_invalid":true,
\&                       "account_failed":false
\&                    }
\&                 },
\&                 {
\&                    "device":"ide1\-cd0",
\&                    "stats":{
\&                       "wr_highest_offset":0,
\&                       "wr_bytes":0,
\&                       "wr_operations":0,
\&                       "rd_bytes":0,
\&                       "rd_operations":0
\&                       "flush_operations":0,
\&                       "wr_total_times_ns":0
\&                       "rd_total_times_ns":0
\&                       "flush_total_times_ns":0,
\&                       "rd_merged":0,
\&                       "wr_merged":0,
\&                       "account_invalid":false,
\&                       "account_failed":false
\&                    }
\&                 },
\&                 {
\&                    "device":"floppy0",
\&                    "stats":{
\&                       "wr_highest_offset":0,
\&                       "wr_bytes":0,
\&                       "wr_operations":0,
\&                       "rd_bytes":0,
\&                       "rd_operations":0
\&                       "flush_operations":0,
\&                       "wr_total_times_ns":0
\&                       "rd_total_times_ns":0
\&                       "flush_total_times_ns":0,
\&                       "rd_merged":0,
\&                       "wr_merged":0,
\&                       "account_invalid":false,
\&                       "account_failed":false
\&                    }
\&                 },
\&                 {
\&                    "device":"sd0",
\&                    "stats":{
\&                       "wr_highest_offset":0,
\&                       "wr_bytes":0,
\&                       "wr_operations":0,
\&                       "rd_bytes":0,
\&                       "rd_operations":0
\&                       "flush_operations":0,
\&                       "wr_total_times_ns":0
\&                       "rd_total_times_ns":0
\&                       "flush_total_times_ns":0,
\&                       "rd_merged":0,
\&                       "wr_merged":0,
\&                       "account_invalid":false,
\&                       "account_failed":false
\&                    }
\&                 }
\&              ]
\&           }
.Ve
.PP
\&\fBBlockdevOnError\fR (Enum)
.PP
An enumeration of possible behaviors for errors on I/O operations.
The exact meaning depends on whether the I/O was initiated by a guest
or by a block job
.PP
\&\fBValues:\fR
.ie n .IP """report""" 4
.el .IP "\f(CWreport\fR" 4
.IX Item "report"
for guest operations, report the error to the guest;
for jobs, cancel the job
.ie n .IP """ignore""" 4
.el .IP "\f(CWignore\fR" 4
.IX Item "ignore"
ignore the error, only report a \s-1QMP\s0 event (\s-1BLOCK_IO_ERROR\s0
or \s-1BLOCK_JOB_ERROR\s0)
.ie n .IP """enospc""" 4
.el .IP "\f(CWenospc\fR" 4
.IX Item "enospc"
same as \f(CW\*(C`stop\*(C'\fR on \s-1ENOSPC,\s0 same as \f(CW\*(C`report\*(C'\fR otherwise.
.ie n .IP """stop""" 4
.el .IP "\f(CWstop\fR" 4
.IX Item "stop"
for guest operations, stop the virtual machine;
for jobs, pause the job
.ie n .IP """auto""" 4
.el .IP "\f(CWauto\fR" 4
.IX Item "auto"
inherit the error handling policy of the backend (since: 2.7)
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBMirrorSyncMode\fR (Enum)
.PP
An enumeration of possible behaviors for the initial synchronization
phase of storage mirroring.
.PP
\&\fBValues:\fR
.ie n .IP """top""" 4
.el .IP "\f(CWtop\fR" 4
.IX Item "top"
copies data in the topmost image to the destination
.ie n .IP """full""" 4
.el .IP "\f(CWfull\fR" 4
.IX Item "full"
copies data from all images to the destination
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
only copy data written from now on
.ie n .IP """incremental""" 4
.el .IP "\f(CWincremental\fR" 4
.IX Item "incremental"
only copy data described by the dirty bitmap. Since: 2.4
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBBlockJobType\fR (Enum)
.PP
Type of a block job.
.PP
\&\fBValues:\fR
.ie n .IP """commit""" 4
.el .IP "\f(CWcommit\fR" 4
.IX Item "commit"
block commit job type, see \*(L"block-commit\*(R"
.ie n .IP """stream""" 4
.el .IP "\f(CWstream\fR" 4
.IX Item "stream"
block stream job type, see \*(L"block-stream\*(R"
.ie n .IP """mirror""" 4
.el .IP "\f(CWmirror\fR" 4
.IX Item "mirror"
drive mirror job type, see \*(L"drive-mirror\*(R"
.ie n .IP """backup""" 4
.el .IP "\f(CWbackup\fR" 4
.IX Item "backup"
drive backup job type, see \*(L"drive-backup\*(R"
.PP
\&\fBSince:\fR
1.7
.PP
\&\fBBlockJobInfo\fR (Object)
.PP
Information about a long-running block device operation.
.PP
\&\fBMembers:\fR
.ie n .IP """type: string""" 4
.el .IP "\f(CWtype: string\fR" 4
.IX Item "type: string"
the job type ('stream' for image streaming)
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The job identifier. Originally the device name but other
values are allowed since \s-1QEMU 2.7\s0
.ie n .IP """len: int""" 4
.el .IP "\f(CWlen: int\fR" 4
.IX Item "len: int"
the maximum progress value
.ie n .IP """busy: boolean""" 4
.el .IP "\f(CWbusy: boolean\fR" 4
.IX Item "busy: boolean"
false if the job is known to be in a quiescent state, with
no pending I/O.  Since 1.3.
.ie n .IP """paused: boolean""" 4
.el .IP "\f(CWpaused: boolean\fR" 4
.IX Item "paused: boolean"
whether the job is paused or, if \f(CW\*(C`busy\*(C'\fR is true, will
pause itself as soon as possible.  Since 1.3.
.ie n .IP """offset: int""" 4
.el .IP "\f(CWoffset: int\fR" 4
.IX Item "offset: int"
the current progress value
.ie n .IP """speed: int""" 4
.el .IP "\f(CWspeed: int\fR" 4
.IX Item "speed: int"
the rate limit, bytes per second
.ie n .IP """io\-status: BlockDeviceIoStatus""" 4
.el .IP "\f(CWio\-status: BlockDeviceIoStatus\fR" 4
.IX Item "io-status: BlockDeviceIoStatus"
the status of the job (since 1.3)
.ie n .IP """ready: boolean""" 4
.el .IP "\f(CWready: boolean\fR" 4
.IX Item "ready: boolean"
true if the job may be completed (since 2.2)
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBquery-block-jobs\fR  (Command)
Return information about long-running block device operations.
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`BlockJobInfo\*(C'\fR for each active block job
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBblock_passwd\fR  (Command)
This command sets the password of a block device that has not been open
with a password and requires one.
.PP
This command is now obsolete and will always return an error since 2.10
.PP
\&\fBArguments:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
Not documented
.ie n .IP """node\-name: string"" (optional)" 4
.el .IP "\f(CWnode\-name: string\fR (optional)" 4
.IX Item "node-name: string (optional)"
Not documented
.ie n .IP """password: string""" 4
.el .IP "\f(CWpassword: string\fR" 4
.IX Item "password: string"
Not documented
.PP
\&\fBblock_resize\fR  (Command)
Resize a block image while a guest is running.
.PP
Either \f(CW\*(C`device\*(C'\fR or \f(CW\*(C`node\-name\*(C'\fR must be set but not both.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
the name of the device to get the image resized
.ie n .IP """node\-name: string"" (optional)" 4
.el .IP "\f(CWnode\-name: string\fR (optional)" 4
.IX Item "node-name: string (optional)"
graph node name to get the image resized (Since 2.0)
.ie n .IP """size: int""" 4
.el .IP "\f(CWsize: int\fR" 4
.IX Item "size: int"
new image size in bytes
.PP
\&\fBReturns:\fR
nothing on success
If \f(CW\*(C`device\*(C'\fR is not a valid block device, DeviceNotFound
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "block_resize",
\&             "arguments": { "device": "scratch", "size": 1073741824 } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBNewImageMode\fR (Enum)
.PP
An enumeration that tells \s-1QEMU\s0 how to set the backing file path in
a new image file.
.PP
\&\fBValues:\fR
.ie n .IP """existing""" 4
.el .IP "\f(CWexisting\fR" 4
.IX Item "existing"
\&\s-1QEMU\s0 should look for an existing image file.
.ie n .IP """absolute\-paths""" 4
.el .IP "\f(CWabsolute\-paths\fR" 4
.IX Item "absolute-paths"
\&\s-1QEMU\s0 should create a new image with absolute paths
for the backing file. If there is no backing file available, the new
image will not be backed either.
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBBlockdevSnapshotSync\fR (Object)
.PP
Either \f(CW\*(C`device\*(C'\fR or \f(CW\*(C`node\-name\*(C'\fR must be set but not both.
.PP
\&\fBMembers:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
the name of the device to generate the snapshot from.
.ie n .IP """node\-name: string"" (optional)" 4
.el .IP "\f(CWnode\-name: string\fR (optional)" 4
.IX Item "node-name: string (optional)"
graph node name to generate the snapshot from (Since 2.0)
.ie n .IP """snapshot\-file: string""" 4
.el .IP "\f(CWsnapshot\-file: string\fR" 4
.IX Item "snapshot-file: string"
the target of the new image. If the file exists, or
if it is a device, the snapshot will be created in the existing
file/device. Otherwise, a new file will be created.
.ie n .IP """snapshot\-node\-name: string"" (optional)" 4
.el .IP "\f(CWsnapshot\-node\-name: string\fR (optional)" 4
.IX Item "snapshot-node-name: string (optional)"
the graph node name of the new image (Since 2.0)
.ie n .IP """format: string"" (optional)" 4
.el .IP "\f(CWformat: string\fR (optional)" 4
.IX Item "format: string (optional)"
the format of the snapshot image, default is 'qcow2'.
.ie n .IP """mode: NewImageMode"" (optional)" 4
.el .IP "\f(CWmode: NewImageMode\fR (optional)" 4
.IX Item "mode: NewImageMode (optional)"
whether and how \s-1QEMU\s0 should create a new image, default is
\&'absolute\-paths'.
.PP
\&\fBBlockdevSnapshot\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """node: string""" 4
.el .IP "\f(CWnode: string\fR" 4
.IX Item "node: string"
device or node name that will have a snapshot created.
.ie n .IP """overlay: string""" 4
.el .IP "\f(CWoverlay: string\fR" 4
.IX Item "overlay: string"
reference to the existing block device that will become
the overlay of \f(CW\*(C`node\*(C'\fR, as part of creating the snapshot.
It must not have a current backing file (this can be
achieved by passing \*(L"backing\*(R": "" to blockdev-add).
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBDriveBackup\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """job\-id: string"" (optional)" 4
.el .IP "\f(CWjob\-id: string\fR (optional)" 4
.IX Item "job-id: string (optional)"
identifier for the newly-created block job. If
omitted, the device name will be used. (Since 2.7)
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
the device name or node-name of a root node which should be copied.
.ie n .IP """target: string""" 4
.el .IP "\f(CWtarget: string\fR" 4
.IX Item "target: string"
the target of the new image. If the file exists, or if it
is a device, the existing file/device will be used as the new
destination.  If it does not exist, a new file will be created.
.ie n .IP """format: string"" (optional)" 4
.el .IP "\f(CWformat: string\fR (optional)" 4
.IX Item "format: string (optional)"
the format of the new destination, default is to
probe if \f(CW\*(C`mode\*(C'\fR is 'existing', else the format of the source
.ie n .IP """sync: MirrorSyncMode""" 4
.el .IP "\f(CWsync: MirrorSyncMode\fR" 4
.IX Item "sync: MirrorSyncMode"
what parts of the disk image should be copied to the destination
(all the disk, only the sectors allocated in the topmost image, from a
dirty bitmap, or only new I/O).
.ie n .IP """mode: NewImageMode"" (optional)" 4
.el .IP "\f(CWmode: NewImageMode\fR (optional)" 4
.IX Item "mode: NewImageMode (optional)"
whether and how \s-1QEMU\s0 should create a new image, default is
\&'absolute\-paths'.
.ie n .IP """speed: int"" (optional)" 4
.el .IP "\f(CWspeed: int\fR (optional)" 4
.IX Item "speed: int (optional)"
the maximum speed, in bytes per second
.ie n .IP """bitmap: string"" (optional)" 4
.el .IP "\f(CWbitmap: string\fR (optional)" 4
.IX Item "bitmap: string (optional)"
the name of dirty bitmap if sync is \*(L"incremental\*(R".
Must be present if sync is \*(L"incremental\*(R", must \s-1NOT\s0 be present
otherwise. (Since 2.4)
.ie n .IP """compress: boolean"" (optional)" 4
.el .IP "\f(CWcompress: boolean\fR (optional)" 4
.IX Item "compress: boolean (optional)"
true to compress data, if the target format supports it.
(default: false) (since 2.8)
.ie n .IP """on\-source\-error: BlockdevOnError"" (optional)" 4
.el .IP "\f(CWon\-source\-error: BlockdevOnError\fR (optional)" 4
.IX Item "on-source-error: BlockdevOnError (optional)"
the action to take on an error on the source,
default 'report'.  'stop' and 'enospc' can only be used
if the block device supports io-status (see BlockInfo).
.ie n .IP """on\-target\-error: BlockdevOnError"" (optional)" 4
.el .IP "\f(CWon\-target\-error: BlockdevOnError\fR (optional)" 4
.IX Item "on-target-error: BlockdevOnError (optional)"
the action to take on an error on the target,
default 'report' (no limitations, since this applies to
a different block device than \f(CW\*(C`device\*(C'\fR).
.PP
\&\fBNote:\fR
\&\f(CW\*(C`on\-source\-error\*(C'\fR and \f(CW\*(C`on\-target\-error\*(C'\fR only affect background
I/O.  If an error occurs during a guest write request, the device's
rerror/werror actions will be used.
.PP
\&\fBSince:\fR
1.6
.PP
\&\fBBlockdevBackup\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """job\-id: string"" (optional)" 4
.el .IP "\f(CWjob\-id: string\fR (optional)" 4
.IX Item "job-id: string (optional)"
identifier for the newly-created block job. If
omitted, the device name will be used. (Since 2.7)
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
the device name or node-name of a root node which should be copied.
.ie n .IP """target: string""" 4
.el .IP "\f(CWtarget: string\fR" 4
.IX Item "target: string"
the device name or node-name of the backup target node.
.ie n .IP """sync: MirrorSyncMode""" 4
.el .IP "\f(CWsync: MirrorSyncMode\fR" 4
.IX Item "sync: MirrorSyncMode"
what parts of the disk image should be copied to the destination
(all the disk, only the sectors allocated in the topmost image, or
only new I/O).
.ie n .IP """speed: int"" (optional)" 4
.el .IP "\f(CWspeed: int\fR (optional)" 4
.IX Item "speed: int (optional)"
the maximum speed, in bytes per second. The default is 0,
for unlimited.
.ie n .IP """compress: boolean"" (optional)" 4
.el .IP "\f(CWcompress: boolean\fR (optional)" 4
.IX Item "compress: boolean (optional)"
true to compress data, if the target format supports it.
(default: false) (since 2.8)
.ie n .IP """on\-source\-error: BlockdevOnError"" (optional)" 4
.el .IP "\f(CWon\-source\-error: BlockdevOnError\fR (optional)" 4
.IX Item "on-source-error: BlockdevOnError (optional)"
the action to take on an error on the source,
default 'report'.  'stop' and 'enospc' can only be used
if the block device supports io-status (see BlockInfo).
.ie n .IP """on\-target\-error: BlockdevOnError"" (optional)" 4
.el .IP "\f(CWon\-target\-error: BlockdevOnError\fR (optional)" 4
.IX Item "on-target-error: BlockdevOnError (optional)"
the action to take on an error on the target,
default 'report' (no limitations, since this applies to
a different block device than \f(CW\*(C`device\*(C'\fR).
.PP
\&\fBNote:\fR
\&\f(CW\*(C`on\-source\-error\*(C'\fR and \f(CW\*(C`on\-target\-error\*(C'\fR only affect background
I/O.  If an error occurs during a guest write request, the device's
rerror/werror actions will be used.
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBblockdev-snapshot-sync\fR  (Command)
Generates a synchronous snapshot of a block device.
.PP
For the arguments, see the documentation of BlockdevSnapshotSync.
.PP
\&\fBReturns:\fR
nothing on success
If \f(CW\*(C`device\*(C'\fR is not a valid block device, DeviceNotFound
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&        \-> { "execute": "blockdev\-snapshot\-sync",
\&             "arguments": { "device": "ide\-hd0",
\&                            "snapshot\-file":
\&                            "/some/place/my\-image",
\&                            "format": "qcow2" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBblockdev-snapshot\fR  (Command)
Generates a snapshot of a block device.
.PP
Create a snapshot, by installing 'node' as the backing image of
\&'overlay'. Additionally, if 'node' is associated with a block
device, the block device changes to using 'overlay' as its new active
image.
.PP
For the arguments, see the documentation of BlockdevSnapshot.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&        \-> { "execute": "blockdev\-add",
\&             "arguments": { "driver": "qcow2",
\&                            "node\-name": "node1534",
\&                            "file": { "driver": "file",
\&                                      "filename": "hd1.qcow2" },
\&                            "backing": "" } }
\&        
\&        <\- { "return": {} }
\&        
\&        \-> { "execute": "blockdev\-snapshot",
\&             "arguments": { "node": "ide\-hd0",
\&                            "overlay": "node1534" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBchange-backing-file\fR  (Command)
Change the backing file in the image file metadata.  This does not
cause \s-1QEMU\s0 to reopen the image file to reparse the backing filename
(it may, however, perform a reopen to change permissions from
r/o \-> r/w \-> r/o, if needed). The new backing file string is written
into the image file metadata, and the \s-1QEMU\s0 internal strings are
updated.
.PP
\&\fBArguments:\fR
.ie n .IP """image\-node\-name: string""" 4
.el .IP "\f(CWimage\-node\-name: string\fR" 4
.IX Item "image-node-name: string"
The name of the block driver state node of the
image to modify. The \*(L"device\*(R" argument is used
to verify \*(L"image-node-name\*(R" is in the chain
described by \*(L"device\*(R".
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The device name or node-name of the root node that owns
image-node-name.
.ie n .IP """backing\-file: string""" 4
.el .IP "\f(CWbacking\-file: string\fR" 4
.IX Item "backing-file: string"
The string to write as the backing file.  This
string is not validated, so care should be taken
when specifying the string or the image chain may
not be able to be reopened again.
.PP
\&\fBReturns:\fR
Nothing on success
.PP
If \*(L"device\*(R" does not exist or cannot be determined, DeviceNotFound
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBblock-commit\fR  (Command)
Live commit of data from overlay image nodes into backing nodes \- i.e.,
writes data between 'top' and 'base' into 'base'.
.PP
\&\fBArguments:\fR
.ie n .IP """job\-id: string"" (optional)" 4
.el .IP "\f(CWjob\-id: string\fR (optional)" 4
.IX Item "job-id: string (optional)"
identifier for the newly-created block job. If
omitted, the device name will be used. (Since 2.7)
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
the device name or node-name of a root node
.ie n .IP """base: string"" (optional)" 4
.el .IP "\f(CWbase: string\fR (optional)" 4
.IX Item "base: string (optional)"
The file name of the backing image to write data into.
If not specified, this is the deepest backing image.
.ie n .IP """top: string"" (optional)" 4
.el .IP "\f(CWtop: string\fR (optional)" 4
.IX Item "top: string (optional)"
The file name of the backing image within the image chain,
which contains the topmost data to be committed down. If
not specified, this is the active layer.
.ie n .IP """backing\-file: string"" (optional)" 4
.el .IP "\f(CWbacking\-file: string\fR (optional)" 4
.IX Item "backing-file: string (optional)"
The backing file string to write into the overlay
image of 'top'.  If 'top' is the active layer,
specifying a backing file string is an error. This
filename is not validated.
.Sp
If a pathname string is such that it cannot be
resolved by \s-1QEMU,\s0 that means that subsequent \s-1QMP\s0 or
\&\s-1HMP\s0 commands must use node-names for the image in
question, as filename lookup methods will fail.
.Sp
If not specified, \s-1QEMU\s0 will automatically determine
the backing file string to use, or error out if
there is no obvious choice. Care should be taken
when specifying the string, to specify a valid
filename or protocol.
(Since 2.1)
.Sp
If top == base, that is an error.
If top == active, the job will not be completed by itself,
user needs to complete the job with the block-job-complete
command after getting the ready event. (Since 2.0)
.Sp
If the base image is smaller than top, then the base image
will be resized to be the same size as top.  If top is
smaller than the base image, the base will not be
truncated.  If you want the base image size to match the
size of the smaller top, you can safely truncate it
yourself once the commit operation successfully completes.
.ie n .IP """speed: int"" (optional)" 4
.el .IP "\f(CWspeed: int\fR (optional)" 4
.IX Item "speed: int (optional)"
the maximum speed, in bytes per second
.ie n .IP """filter\-node\-name: string"" (optional)" 4
.el .IP "\f(CWfilter\-node\-name: string\fR (optional)" 4
.IX Item "filter-node-name: string (optional)"
the node name that should be assigned to the
filter driver that the commit job inserts into the graph
above \f(CW\*(C`top\*(C'\fR. If this option is not given, a node name is
autogenerated. (Since: 2.9)
.PP
\&\fBReturns:\fR
Nothing on success
If commit or stream is already active on this device, DeviceInUse
If \f(CW\*(C`device\*(C'\fR does not exist, DeviceNotFound
If image commit is not supported by this device, NotSupported
If \f(CW\*(C`base\*(C'\fR or \f(CW\*(C`top\*(C'\fR is invalid, a generic error is returned
If \f(CW\*(C`speed\*(C'\fR is invalid, InvalidParameter
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&        \-> { "execute": "block\-commit",
\&             "arguments": { "device": "virtio0",
\&                            "top": "/tmp/snap1.qcow2" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBdrive-backup\fR  (Command)
Start a point-in-time copy of a block device to a new destination.  The
status of ongoing drive-backup operations can be checked with
query-block-jobs where the BlockJobInfo.type field has the value 'backup'.
The operation can be stopped before it has completed using the
block-job-cancel command.
.PP
\&\fBArguments:\fR the members of \f(CW\*(C`DriveBackup\*(C'\fR
.PP
\&\fBReturns:\fR
nothing on success
If \f(CW\*(C`device\*(C'\fR is not a valid block device, GenericError
.PP
\&\fBSince:\fR
1.6
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "drive\-backup",
\&             "arguments": { "device": "drive0",
\&                            "sync": "full",
\&                            "target": "backup.img" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBblockdev-backup\fR  (Command)
Start a point-in-time copy of a block device to a new destination.  The
status of ongoing blockdev-backup operations can be checked with
query-block-jobs where the BlockJobInfo.type field has the value 'backup'.
The operation can be stopped before it has completed using the
block-job-cancel command.
.PP
\&\fBArguments:\fR the members of \f(CW\*(C`BlockdevBackup\*(C'\fR
.PP
\&\fBReturns:\fR
nothing on success
If \f(CW\*(C`device\*(C'\fR is not a valid block device, DeviceNotFound
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "blockdev\-backup",
\&             "arguments": { "device": "src\-id",
\&                            "sync": "full",
\&                            "target": "tgt\-id" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBquery-named-block-nodes\fR  (Command)
Get the named block driver list
.PP
\&\fBReturns:\fR
the list of BlockDeviceInfo
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-named\-block\-nodes" }
\&        <\- { "return": [ { "ro":false,
\&                           "drv":"qcow2",
\&                           "encrypted":false,
\&                           "file":"disks/test.qcow2",
\&                           "node\-name": "my\-node",
\&                           "backing_file_depth":1,
\&                           "bps":1000000,
\&                           "bps_rd":0,
\&                           "bps_wr":0,
\&                           "iops":1000000,
\&                           "iops_rd":0,
\&                           "iops_wr":0,
\&                           "bps_max": 8000000,
\&                           "bps_rd_max": 0,
\&                           "bps_wr_max": 0,
\&                           "iops_max": 0,
\&                           "iops_rd_max": 0,
\&                           "iops_wr_max": 0,
\&                           "iops_size": 0,
\&                           "write_threshold": 0,
\&                           "image":{
\&                              "filename":"disks/test.qcow2",
\&                              "format":"qcow2",
\&                              "virtual\-size":2048000,
\&                              "backing_file":"base.qcow2",
\&                              "full\-backing\-filename":"disks/base.qcow2",
\&                              "backing\-filename\-format":"qcow2",
\&                              "snapshots":[
\&                                 {
\&                                    "id": "1",
\&                                    "name": "snapshot1",
\&                                    "vm\-state\-size": 0,
\&                                    "date\-sec": 10000200,
\&                                    "date\-nsec": 12,
\&                                    "vm\-clock\-sec": 206,
\&                                    "vm\-clock\-nsec": 30
\&                                 }
\&                              ],
\&                              "backing\-image":{
\&                                  "filename":"disks/base.qcow2",
\&                                  "format":"qcow2",
\&                                  "virtual\-size":2048000
\&                              }
\&                           } } ] }
.Ve
.PP
\&\fBdrive-mirror\fR  (Command)
Start mirroring a block device's writes to a new destination. target
specifies the target of the new image. If the file exists, or if it
is a device, it will be used as the new destination for writes. If
it does not exist, a new file will be created. format specifies the
format of the mirror image, default is to probe if mode='existing',
else the format of the source.
.PP
\&\fBArguments:\fR the members of \f(CW\*(C`DriveMirror\*(C'\fR
.PP
\&\fBReturns:\fR
nothing on success
If \f(CW\*(C`device\*(C'\fR is not a valid block device, GenericError
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&        \-> { "execute": "drive\-mirror",
\&             "arguments": { "device": "ide\-hd0",
\&                            "target": "/some/place/my\-image",
\&                            "sync": "full",
\&                            "format": "qcow2" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBDriveMirror\fR (Object)
.PP
A set of parameters describing drive mirror setup.
.PP
\&\fBMembers:\fR
.ie n .IP """job\-id: string"" (optional)" 4
.el .IP "\f(CWjob\-id: string\fR (optional)" 4
.IX Item "job-id: string (optional)"
identifier for the newly-created block job. If
omitted, the device name will be used. (Since 2.7)
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
the device name or node-name of a root node whose writes should be
mirrored.
.ie n .IP """target: string""" 4
.el .IP "\f(CWtarget: string\fR" 4
.IX Item "target: string"
the target of the new image. If the file exists, or if it
is a device, the existing file/device will be used as the new
destination.  If it does not exist, a new file will be created.
.ie n .IP """format: string"" (optional)" 4
.el .IP "\f(CWformat: string\fR (optional)" 4
.IX Item "format: string (optional)"
the format of the new destination, default is to
probe if \f(CW\*(C`mode\*(C'\fR is 'existing', else the format of the source
.ie n .IP """node\-name: string"" (optional)" 4
.el .IP "\f(CWnode\-name: string\fR (optional)" 4
.IX Item "node-name: string (optional)"
the new block driver state node name in the graph
(Since 2.1)
.ie n .IP """replaces: string"" (optional)" 4
.el .IP "\f(CWreplaces: string\fR (optional)" 4
.IX Item "replaces: string (optional)"
with sync=full graph node name to be replaced by the new
image when a whole image copy is done. This can be used to repair
broken Quorum files. (Since 2.1)
.ie n .IP """mode: NewImageMode"" (optional)" 4
.el .IP "\f(CWmode: NewImageMode\fR (optional)" 4
.IX Item "mode: NewImageMode (optional)"
whether and how \s-1QEMU\s0 should create a new image, default is
\&'absolute\-paths'.
.ie n .IP """speed: int"" (optional)" 4
.el .IP "\f(CWspeed: int\fR (optional)" 4
.IX Item "speed: int (optional)"
the maximum speed, in bytes per second
.ie n .IP """sync: MirrorSyncMode""" 4
.el .IP "\f(CWsync: MirrorSyncMode\fR" 4
.IX Item "sync: MirrorSyncMode"
what parts of the disk image should be copied to the destination
(all the disk, only the sectors allocated in the topmost image, or
only new I/O).
.ie n .IP """granularity: int"" (optional)" 4
.el .IP "\f(CWgranularity: int\fR (optional)" 4
.IX Item "granularity: int (optional)"
granularity of the dirty bitmap, default is 64K
if the image format doesn't have clusters, 4K if the clusters
are smaller than that, else the cluster size.  Must be a
power of 2 between 512 and 64M (since 1.4).
.ie n .IP """buf\-size: int"" (optional)" 4
.el .IP "\f(CWbuf\-size: int\fR (optional)" 4
.IX Item "buf-size: int (optional)"
maximum amount of data in flight from source to
target (since 1.4).
.ie n .IP """on\-source\-error: BlockdevOnError"" (optional)" 4
.el .IP "\f(CWon\-source\-error: BlockdevOnError\fR (optional)" 4
.IX Item "on-source-error: BlockdevOnError (optional)"
the action to take on an error on the source,
default 'report'.  'stop' and 'enospc' can only be used
if the block device supports io-status (see BlockInfo).
.ie n .IP """on\-target\-error: BlockdevOnError"" (optional)" 4
.el .IP "\f(CWon\-target\-error: BlockdevOnError\fR (optional)" 4
.IX Item "on-target-error: BlockdevOnError (optional)"
the action to take on an error on the target,
default 'report' (no limitations, since this applies to
a different block device than \f(CW\*(C`device\*(C'\fR).
.ie n .IP """unmap: boolean"" (optional)" 4
.el .IP "\f(CWunmap: boolean\fR (optional)" 4
.IX Item "unmap: boolean (optional)"
Whether to try to unmap target sectors where source has
only zero. If true, and target unallocated sectors will read as zero,
target image sectors will be unmapped; otherwise, zeroes will be
written. Both will result in identical contents.
Default is true. (Since 2.4)
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBBlockDirtyBitmap\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """node: string""" 4
.el .IP "\f(CWnode: string\fR" 4
.IX Item "node: string"
name of device/node which the bitmap is tracking
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
name of the dirty bitmap
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBBlockDirtyBitmapAdd\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """node: string""" 4
.el .IP "\f(CWnode: string\fR" 4
.IX Item "node: string"
name of device/node which the bitmap is tracking
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
name of the dirty bitmap
.ie n .IP """granularity: int"" (optional)" 4
.el .IP "\f(CWgranularity: int\fR (optional)" 4
.IX Item "granularity: int (optional)"
the bitmap granularity, default is 64k for
block-dirty-bitmap-add
.ie n .IP """persistent: boolean"" (optional)" 4
.el .IP "\f(CWpersistent: boolean\fR (optional)" 4
.IX Item "persistent: boolean (optional)"
the bitmap is persistent, i.e. it will be saved to the
corresponding block device image file on its close. For now only
Qcow2 disks support persistent bitmaps. Default is false for
block-dirty-bitmap-add. (Since: 2.10)
.ie n .IP """autoload: boolean"" (optional)" 4
.el .IP "\f(CWautoload: boolean\fR (optional)" 4
.IX Item "autoload: boolean (optional)"
the bitmap will be automatically loaded when the image it is stored
in is opened. This flag may only be specified for persistent
bitmaps. Default is false for block-dirty-bitmap-add. (Since: 2.10)
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBblock-dirty-bitmap-add\fR  (Command)
Create a dirty bitmap with a name on the node, and start tracking the writes.
.PP
\&\fBReturns:\fR
nothing on success
If \f(CW\*(C`node\*(C'\fR is not a valid block device or node, DeviceNotFound
If \f(CW\*(C`name\*(C'\fR is already taken, GenericError with an explanation
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "block\-dirty\-bitmap\-add",
\&             "arguments": { "node": "drive0", "name": "bitmap0" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBblock-dirty-bitmap-remove\fR  (Command)
Stop write tracking and remove the dirty bitmap that was created
with block-dirty-bitmap-add. If the bitmap is persistent, remove it from its
storage too.
.PP
\&\fBReturns:\fR
nothing on success
If \f(CW\*(C`node\*(C'\fR is not a valid block device or node, DeviceNotFound
If \f(CW\*(C`name\*(C'\fR is not found, GenericError with an explanation
if \f(CW\*(C`name\*(C'\fR is frozen by an operation, GenericError
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "block\-dirty\-bitmap\-remove",
\&             "arguments": { "node": "drive0", "name": "bitmap0" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBblock-dirty-bitmap-clear\fR  (Command)
Clear (reset) a dirty bitmap on the device, so that an incremental
backup from this point in time forward will only backup clusters
modified after this clear operation.
.PP
\&\fBReturns:\fR
nothing on success
If \f(CW\*(C`node\*(C'\fR is not a valid block device, DeviceNotFound
If \f(CW\*(C`name\*(C'\fR is not found, GenericError with an explanation
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "block\-dirty\-bitmap\-clear",
\&             "arguments": { "node": "drive0", "name": "bitmap0" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBBlockDirtyBitmapSha256\fR (Object)
.PP
\&\s-1SHA256\s0 hash of dirty bitmap data
.PP
\&\fBMembers:\fR
.ie n .IP """sha256: string""" 4
.el .IP "\f(CWsha256: string\fR" 4
.IX Item "sha256: string"
\&\s-1ASCII\s0 representation of \s-1SHA256\s0 bitmap hash
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBx\-debug\-block\-dirty\-bitmap\-sha256\fR  (Command)
Get bitmap \s-1SHA256\s0
.PP
\&\fBReturns:\fR
BlockDirtyBitmapSha256 on success
If \f(CW\*(C`node\*(C'\fR is not a valid block device, DeviceNotFound
If \f(CW\*(C`name\*(C'\fR is not found or if hashing has failed, GenericError with an
explanation
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBblockdev-mirror\fR  (Command)
Start mirroring a block device's writes to a new destination.
.PP
\&\fBArguments:\fR
.ie n .IP """job\-id: string"" (optional)" 4
.el .IP "\f(CWjob\-id: string\fR (optional)" 4
.IX Item "job-id: string (optional)"
identifier for the newly-created block job. If
omitted, the device name will be used. (Since 2.7)
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The device name or node-name of a root node whose writes should be
mirrored.
.ie n .IP """target: string""" 4
.el .IP "\f(CWtarget: string\fR" 4
.IX Item "target: string"
the id or node-name of the block device to mirror to. This mustn't be
attached to guest.
.ie n .IP """replaces: string"" (optional)" 4
.el .IP "\f(CWreplaces: string\fR (optional)" 4
.IX Item "replaces: string (optional)"
with sync=full graph node name to be replaced by the new
image when a whole image copy is done. This can be used to repair
broken Quorum files.
.ie n .IP """speed: int"" (optional)" 4
.el .IP "\f(CWspeed: int\fR (optional)" 4
.IX Item "speed: int (optional)"
the maximum speed, in bytes per second
.ie n .IP """sync: MirrorSyncMode""" 4
.el .IP "\f(CWsync: MirrorSyncMode\fR" 4
.IX Item "sync: MirrorSyncMode"
what parts of the disk image should be copied to the destination
(all the disk, only the sectors allocated in the topmost image, or
only new I/O).
.ie n .IP """granularity: int"" (optional)" 4
.el .IP "\f(CWgranularity: int\fR (optional)" 4
.IX Item "granularity: int (optional)"
granularity of the dirty bitmap, default is 64K
if the image format doesn't have clusters, 4K if the clusters
are smaller than that, else the cluster size.  Must be a
power of 2 between 512 and 64M
.ie n .IP """buf\-size: int"" (optional)" 4
.el .IP "\f(CWbuf\-size: int\fR (optional)" 4
.IX Item "buf-size: int (optional)"
maximum amount of data in flight from source to
target
.ie n .IP """on\-source\-error: BlockdevOnError"" (optional)" 4
.el .IP "\f(CWon\-source\-error: BlockdevOnError\fR (optional)" 4
.IX Item "on-source-error: BlockdevOnError (optional)"
the action to take on an error on the source,
default 'report'.  'stop' and 'enospc' can only be used
if the block device supports io-status (see BlockInfo).
.ie n .IP """on\-target\-error: BlockdevOnError"" (optional)" 4
.el .IP "\f(CWon\-target\-error: BlockdevOnError\fR (optional)" 4
.IX Item "on-target-error: BlockdevOnError (optional)"
the action to take on an error on the target,
default 'report' (no limitations, since this applies to
a different block device than \f(CW\*(C`device\*(C'\fR).
.ie n .IP """filter\-node\-name: string"" (optional)" 4
.el .IP "\f(CWfilter\-node\-name: string\fR (optional)" 4
.IX Item "filter-node-name: string (optional)"
the node name that should be assigned to the
filter driver that the mirror job inserts into the graph
above \f(CW\*(C`device\*(C'\fR. If this option is not given, a node name is
autogenerated. (Since: 2.9)
.PP
\&\fBReturns:\fR
nothing on success.
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "blockdev\-mirror",
\&             "arguments": { "device": "ide\-hd0",
\&                            "target": "target0",
\&                            "sync": "full" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBblock_set_io_throttle\fR  (Command)
Change I/O throttle limits for a block drive.
.PP
Since \s-1QEMU 2.4,\s0 each device with I/O limits is member of a throttle
group.
.PP
If two or more devices are members of the same group, the limits
will apply to the combined I/O of the whole group in a round-robin
fashion. Therefore, setting new I/O limits to a device will affect
the whole group.
.PP
The name of the group can be specified using the 'group' parameter.
If the parameter is unset, it is assumed to be the current group of
that device. If it's not in any group yet, the name of the device
will be used as the name for its group.
.PP
The 'group' parameter can also be used to move a device to a
different group. In this case the limits specified in the parameters
will be applied to the new group only.
.PP
I/O limits can be disabled by setting all of them to 0. In this case
the device will be removed from its group and the rest of its
members will not be affected. The 'group' parameter is ignored.
.PP
\&\fBArguments:\fR the members of \f(CW\*(C`BlockIOThrottle\*(C'\fR
.PP
\&\fBReturns:\fR
Nothing on success
If \f(CW\*(C`device\*(C'\fR is not a valid block device, DeviceNotFound
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "block_set_io_throttle",
\&             "arguments": { "id": "ide0\-1\-0",
\&                            "bps": 1000000,
\&                            "bps_rd": 0,
\&                            "bps_wr": 0,
\&                            "iops": 0,
\&                            "iops_rd": 0,
\&                            "iops_wr": 0,
\&                            "bps_max": 8000000,
\&                            "bps_rd_max": 0,
\&                            "bps_wr_max": 0,
\&                            "iops_max": 0,
\&                            "iops_rd_max": 0,
\&                            "iops_wr_max": 0,
\&                            "bps_max_length": 60,
\&                            "iops_size": 0 } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBBlockIOThrottle\fR (Object)
.PP
A set of parameters describing block throttling.
.PP
\&\fBMembers:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
Block device name (deprecated, use \f(CW\*(C`id\*(C'\fR instead)
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
The name or \s-1QOM\s0 path of the guest device (since: 2.8)
.ie n .IP """bps: int""" 4
.el .IP "\f(CWbps: int\fR" 4
.IX Item "bps: int"
total throughput limit in bytes per second
.ie n .IP """bps_rd: int""" 4
.el .IP "\f(CWbps_rd: int\fR" 4
.IX Item "bps_rd: int"
read throughput limit in bytes per second
.ie n .IP """bps_wr: int""" 4
.el .IP "\f(CWbps_wr: int\fR" 4
.IX Item "bps_wr: int"
write throughput limit in bytes per second
.ie n .IP """iops: int""" 4
.el .IP "\f(CWiops: int\fR" 4
.IX Item "iops: int"
total I/O operations per second
.ie n .IP """iops_rd: int""" 4
.el .IP "\f(CWiops_rd: int\fR" 4
.IX Item "iops_rd: int"
read I/O operations per second
.ie n .IP """iops_wr: int""" 4
.el .IP "\f(CWiops_wr: int\fR" 4
.IX Item "iops_wr: int"
write I/O operations per second
.ie n .IP """bps_max: int"" (optional)" 4
.el .IP "\f(CWbps_max: int\fR (optional)" 4
.IX Item "bps_max: int (optional)"
total throughput limit during bursts,
in bytes (Since 1.7)
.ie n .IP """bps_rd_max: int"" (optional)" 4
.el .IP "\f(CWbps_rd_max: int\fR (optional)" 4
.IX Item "bps_rd_max: int (optional)"
read throughput limit during bursts,
in bytes (Since 1.7)
.ie n .IP """bps_wr_max: int"" (optional)" 4
.el .IP "\f(CWbps_wr_max: int\fR (optional)" 4
.IX Item "bps_wr_max: int (optional)"
write throughput limit during bursts,
in bytes (Since 1.7)
.ie n .IP """iops_max: int"" (optional)" 4
.el .IP "\f(CWiops_max: int\fR (optional)" 4
.IX Item "iops_max: int (optional)"
total I/O operations per second during bursts,
in bytes (Since 1.7)
.ie n .IP """iops_rd_max: int"" (optional)" 4
.el .IP "\f(CWiops_rd_max: int\fR (optional)" 4
.IX Item "iops_rd_max: int (optional)"
read I/O operations per second during bursts,
in bytes (Since 1.7)
.ie n .IP """iops_wr_max: int"" (optional)" 4
.el .IP "\f(CWiops_wr_max: int\fR (optional)" 4
.IX Item "iops_wr_max: int (optional)"
write I/O operations per second during bursts,
in bytes (Since 1.7)
.ie n .IP """bps_max_length: int"" (optional)" 4
.el .IP "\f(CWbps_max_length: int\fR (optional)" 4
.IX Item "bps_max_length: int (optional)"
maximum length of the \f(CW\*(C`bps_max\*(C'\fR burst
period, in seconds. It must only
be set if \f(CW\*(C`bps_max\*(C'\fR is set as well.
Defaults to 1. (Since 2.6)
.ie n .IP """bps_rd_max_length: int"" (optional)" 4
.el .IP "\f(CWbps_rd_max_length: int\fR (optional)" 4
.IX Item "bps_rd_max_length: int (optional)"
maximum length of the \f(CW\*(C`bps_rd_max\*(C'\fR
burst period, in seconds. It must only
be set if \f(CW\*(C`bps_rd_max\*(C'\fR is set as well.
Defaults to 1. (Since 2.6)
.ie n .IP """bps_wr_max_length: int"" (optional)" 4
.el .IP "\f(CWbps_wr_max_length: int\fR (optional)" 4
.IX Item "bps_wr_max_length: int (optional)"
maximum length of the \f(CW\*(C`bps_wr_max\*(C'\fR
burst period, in seconds. It must only
be set if \f(CW\*(C`bps_wr_max\*(C'\fR is set as well.
Defaults to 1. (Since 2.6)
.ie n .IP """iops_max_length: int"" (optional)" 4
.el .IP "\f(CWiops_max_length: int\fR (optional)" 4
.IX Item "iops_max_length: int (optional)"
maximum length of the \f(CW\*(C`iops\*(C'\fR burst
period, in seconds. It must only
be set if \f(CW\*(C`iops_max\*(C'\fR is set as well.
Defaults to 1. (Since 2.6)
.ie n .IP """iops_rd_max_length: int"" (optional)" 4
.el .IP "\f(CWiops_rd_max_length: int\fR (optional)" 4
.IX Item "iops_rd_max_length: int (optional)"
maximum length of the \f(CW\*(C`iops_rd_max\*(C'\fR
burst period, in seconds. It must only
be set if \f(CW\*(C`iops_rd_max\*(C'\fR is set as well.
Defaults to 1. (Since 2.6)
.ie n .IP """iops_wr_max_length: int"" (optional)" 4
.el .IP "\f(CWiops_wr_max_length: int\fR (optional)" 4
.IX Item "iops_wr_max_length: int (optional)"
maximum length of the \f(CW\*(C`iops_wr_max\*(C'\fR
burst period, in seconds. It must only
be set if \f(CW\*(C`iops_wr_max\*(C'\fR is set as well.
Defaults to 1. (Since 2.6)
.ie n .IP """iops_size: int"" (optional)" 4
.el .IP "\f(CWiops_size: int\fR (optional)" 4
.IX Item "iops_size: int (optional)"
an I/O size in bytes (Since 1.7)
.ie n .IP """group: string"" (optional)" 4
.el .IP "\f(CWgroup: string\fR (optional)" 4
.IX Item "group: string (optional)"
throttle group name (Since 2.4)
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBblock-stream\fR  (Command)
Copy data from a backing file into a block device.
.PP
The block streaming operation is performed in the background until the entire
backing file has been copied.  This command returns immediately once streaming
has started.  The status of ongoing block streaming operations can be checked
with query-block-jobs.  The operation can be stopped before it has completed
using the block-job-cancel command.
.PP
The node that receives the data is called the top image, can be located in
any part of the chain (but always above the base image; see below) and can be
specified using its device or node name. Earlier qemu versions only allowed
\&'device' to name the top level node; presence of the 'base\-node' parameter
during introspection can be used as a witness of the enhanced semantics
of 'device'.
.PP
If a base file is specified then sectors are not copied from that base file and
its backing chain.  When streaming completes the image file will have the base
file as its backing file.  This can be used to stream a subset of the backing
file chain instead of flattening the entire image.
.PP
On successful completion the image file is updated to drop the backing file
and the \s-1BLOCK_JOB_COMPLETED\s0 event is emitted.
.PP
\&\fBArguments:\fR
.ie n .IP """job\-id: string"" (optional)" 4
.el .IP "\f(CWjob\-id: string\fR (optional)" 4
.IX Item "job-id: string (optional)"
identifier for the newly-created block job. If
omitted, the device name will be used. (Since 2.7)
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
the device or node name of the top image
.ie n .IP """base: string"" (optional)" 4
.el .IP "\f(CWbase: string\fR (optional)" 4
.IX Item "base: string (optional)"
the common backing file name.
It cannot be set if \f(CW\*(C`base\-node\*(C'\fR is also set.
.ie n .IP """base\-node: string"" (optional)" 4
.el .IP "\f(CWbase\-node: string\fR (optional)" 4
.IX Item "base-node: string (optional)"
the node name of the backing file.
It cannot be set if \f(CW\*(C`base\*(C'\fR is also set. (Since 2.8)
.ie n .IP """backing\-file: string"" (optional)" 4
.el .IP "\f(CWbacking\-file: string\fR (optional)" 4
.IX Item "backing-file: string (optional)"
The backing file string to write into the top
image. This filename is not validated.
.Sp
If a pathname string is such that it cannot be
resolved by \s-1QEMU,\s0 that means that subsequent \s-1QMP\s0 or
\&\s-1HMP\s0 commands must use node-names for the image in
question, as filename lookup methods will fail.
.Sp
If not specified, \s-1QEMU\s0 will automatically determine
the backing file string to use, or error out if there
is no obvious choice.  Care should be taken when
specifying the string, to specify a valid filename or
protocol.
(Since 2.1)
.ie n .IP """speed: int"" (optional)" 4
.el .IP "\f(CWspeed: int\fR (optional)" 4
.IX Item "speed: int (optional)"
the maximum speed, in bytes per second
.ie n .IP """on\-error: BlockdevOnError"" (optional)" 4
.el .IP "\f(CWon\-error: BlockdevOnError\fR (optional)" 4
.IX Item "on-error: BlockdevOnError (optional)"
the action to take on an error (default report).
\&'stop' and 'enospc' can only be used if the block device
supports io-status (see BlockInfo).  Since 1.3.
.PP
\&\fBReturns:\fR
Nothing on success. If \f(CW\*(C`device\*(C'\fR does not exist, DeviceNotFound.
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&        \-> { "execute": "block\-stream",
\&             "arguments": { "device": "virtio0",
\&                            "base": "/tmp/master.qcow2" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBblock-job-set-speed\fR  (Command)
Set maximum speed for a background block operation.
.PP
This command can only be issued when there is an active block job.
.PP
Throttling can be disabled by setting the speed to 0.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The job identifier. This used to be a device name (hence
the name of the parameter), but since \s-1QEMU 2.7\s0 it can have
other values.
.ie n .IP """speed: int""" 4
.el .IP "\f(CWspeed: int\fR" 4
.IX Item "speed: int"
the maximum speed, in bytes per second, or 0 for unlimited.
Defaults to 0.
.PP
\&\fBReturns:\fR
Nothing on success
If no background operation is active on this device, DeviceNotActive
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBblock-job-cancel\fR  (Command)
Stop an active background block operation.
.PP
This command returns immediately after marking the active background block
operation for cancellation.  It is an error to call this command if no
operation is in progress.
.PP
The operation will cancel as soon as possible and then emit the
\&\s-1BLOCK_JOB_CANCELLED\s0 event.  Before that happens the job is still visible when
enumerated using query-block-jobs.
.PP
For streaming, the image file retains its backing file unless the streaming
operation happens to complete just as it is being cancelled.  A new streaming
operation can be started at a later time to finish copying all data from the
backing file.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The job identifier. This used to be a device name (hence
the name of the parameter), but since \s-1QEMU 2.7\s0 it can have
other values.
.ie n .IP """force: boolean"" (optional)" 4
.el .IP "\f(CWforce: boolean\fR (optional)" 4
.IX Item "force: boolean (optional)"
whether to allow cancellation of a paused job (default
false).  Since 1.3.
.PP
\&\fBReturns:\fR
Nothing on success
If no background operation is active on this device, DeviceNotActive
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBblock-job-pause\fR  (Command)
Pause an active background block operation.
.PP
This command returns immediately after marking the active background block
operation for pausing.  It is an error to call this command if no
operation is in progress.  Pausing an already paused job has no cumulative
effect; a single block-job-resume command will resume the job.
.PP
The operation will pause as soon as possible.  No event is emitted when
the operation is actually paused.  Cancelling a paused job automatically
resumes it.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The job identifier. This used to be a device name (hence
the name of the parameter), but since \s-1QEMU 2.7\s0 it can have
other values.
.PP
\&\fBReturns:\fR
Nothing on success
If no background operation is active on this device, DeviceNotActive
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBblock-job-resume\fR  (Command)
Resume an active background block operation.
.PP
This command returns immediately after resuming a paused background block
operation.  It is an error to call this command if no operation is in
progress.  Resuming an already running job is not an error.
.PP
This command also clears the error status of the job.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The job identifier. This used to be a device name (hence
the name of the parameter), but since \s-1QEMU 2.7\s0 it can have
other values.
.PP
\&\fBReturns:\fR
Nothing on success
If no background operation is active on this device, DeviceNotActive
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBblock-job-complete\fR  (Command)
Manually trigger completion of an active background block operation.  This
is supported for drive mirroring, where it also switches the device to
write to the target path only.  The ability to complete is signaled with
a \s-1BLOCK_JOB_READY\s0 event.
.PP
This command completes an active background block operation synchronously.
The ordering of this command's return with the \s-1BLOCK_JOB_COMPLETED\s0 event
is not defined.  Note that if an I/O error occurs during the processing of
this command: 1) the command itself will fail; 2) the error will be processed
according to the rerror/werror arguments that were specified when starting
the operation.
.PP
A cancelled or paused job cannot be completed.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The job identifier. This used to be a device name (hence
the name of the parameter), but since \s-1QEMU 2.7\s0 it can have
other values.
.PP
\&\fBReturns:\fR
Nothing on success
If no background operation is active on this device, DeviceNotActive
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBBlockdevDiscardOptions\fR (Enum)
.PP
Determines how to handle discard requests.
.PP
\&\fBValues:\fR
.ie n .IP """ignore""" 4
.el .IP "\f(CWignore\fR" 4
.IX Item "ignore"
Ignore the request
.ie n .IP """unmap""" 4
.el .IP "\f(CWunmap\fR" 4
.IX Item "unmap"
Forward as an unmap request
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevDetectZeroesOptions\fR (Enum)
.PP
Describes the operation mode for the automatic conversion of plain
zero writes by the \s-1OS\s0 to driver specific optimized zero write commands.
.PP
\&\fBValues:\fR
.ie n .IP """off""" 4
.el .IP "\f(CWoff\fR" 4
.IX Item "off"
Disabled (default)
.ie n .IP """on""" 4
.el .IP "\f(CWon\fR" 4
.IX Item "on"
Enabled
.ie n .IP """unmap""" 4
.el .IP "\f(CWunmap\fR" 4
.IX Item "unmap"
Enabled and even try to unmap blocks if possible. This requires
also that \f(CW\*(C`BlockdevDiscardOptions\*(C'\fR is set to unmap for this device.
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBBlockdevAioOptions\fR (Enum)
.PP
Selects the \s-1AIO\s0 backend to handle I/O requests
.PP
\&\fBValues:\fR
.ie n .IP """threads""" 4
.el .IP "\f(CWthreads\fR" 4
.IX Item "threads"
Use qemu's thread pool
.ie n .IP """native""" 4
.el .IP "\f(CWnative\fR" 4
.IX Item "native"
Use native \s-1AIO\s0 backend (only Linux and Windows)
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevCacheOptions\fR (Object)
.PP
Includes cache-related options for block devices
.PP
\&\fBMembers:\fR
.ie n .IP """direct: boolean"" (optional)" 4
.el .IP "\f(CWdirect: boolean\fR (optional)" 4
.IX Item "direct: boolean (optional)"
enables use of O_DIRECT (bypass the host page cache;
default: false)
.ie n .IP """no\-flush: boolean"" (optional)" 4
.el .IP "\f(CWno\-flush: boolean\fR (optional)" 4
.IX Item "no-flush: boolean (optional)"
ignore any flush requests for the device (default:
false)
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevDriver\fR (Enum)
.PP
Drivers that are supported in block device operations.
.PP
\&\fBValues:\fR
.ie n .IP """vxhs""" 4
.el .IP "\f(CWvxhs\fR" 4
.IX Item "vxhs"
Since 2.10
.ie n .IP """blkdebug""" 4
.el .IP "\f(CWblkdebug\fR" 4
.IX Item "blkdebug"
Not documented
.ie n .IP """blkverify""" 4
.el .IP "\f(CWblkverify\fR" 4
.IX Item "blkverify"
Not documented
.ie n .IP """bochs""" 4
.el .IP "\f(CWbochs\fR" 4
.IX Item "bochs"
Not documented
.ie n .IP """cloop""" 4
.el .IP "\f(CWcloop\fR" 4
.IX Item "cloop"
Not documented
.ie n .IP """dmg""" 4
.el .IP "\f(CWdmg\fR" 4
.IX Item "dmg"
Not documented
.ie n .IP """file""" 4
.el .IP "\f(CWfile\fR" 4
.IX Item "file"
Not documented
.ie n .IP """ftp""" 4
.el .IP "\f(CWftp\fR" 4
.IX Item "ftp"
Not documented
.ie n .IP """ftps""" 4
.el .IP "\f(CWftps\fR" 4
.IX Item "ftps"
Not documented
.ie n .IP """gluster""" 4
.el .IP "\f(CWgluster\fR" 4
.IX Item "gluster"
Not documented
.ie n .IP """host_cdrom""" 4
.el .IP "\f(CWhost_cdrom\fR" 4
.IX Item "host_cdrom"
Not documented
.ie n .IP """host_device""" 4
.el .IP "\f(CWhost_device\fR" 4
.IX Item "host_device"
Not documented
.ie n .IP """http""" 4
.el .IP "\f(CWhttp\fR" 4
.IX Item "http"
Not documented
.ie n .IP """https""" 4
.el .IP "\f(CWhttps\fR" 4
.IX Item "https"
Not documented
.ie n .IP """iscsi""" 4
.el .IP "\f(CWiscsi\fR" 4
.IX Item "iscsi"
Not documented
.ie n .IP """luks""" 4
.el .IP "\f(CWluks\fR" 4
.IX Item "luks"
Not documented
.ie n .IP """nbd""" 4
.el .IP "\f(CWnbd\fR" 4
.IX Item "nbd"
Not documented
.ie n .IP """nfs""" 4
.el .IP "\f(CWnfs\fR" 4
.IX Item "nfs"
Not documented
.ie n .IP """null\-aio""" 4
.el .IP "\f(CWnull\-aio\fR" 4
.IX Item "null-aio"
Not documented
.ie n .IP """null\-co""" 4
.el .IP "\f(CWnull\-co\fR" 4
.IX Item "null-co"
Not documented
.ie n .IP """parallels""" 4
.el .IP "\f(CWparallels\fR" 4
.IX Item "parallels"
Not documented
.ie n .IP """qcow""" 4
.el .IP "\f(CWqcow\fR" 4
.IX Item "qcow"
Not documented
.ie n .IP """qcow2""" 4
.el .IP "\f(CWqcow2\fR" 4
.IX Item "qcow2"
Not documented
.ie n .IP """qed""" 4
.el .IP "\f(CWqed\fR" 4
.IX Item "qed"
Not documented
.ie n .IP """quorum""" 4
.el .IP "\f(CWquorum\fR" 4
.IX Item "quorum"
Not documented
.ie n .IP """raw""" 4
.el .IP "\f(CWraw\fR" 4
.IX Item "raw"
Not documented
.ie n .IP """rbd""" 4
.el .IP "\f(CWrbd\fR" 4
.IX Item "rbd"
Not documented
.ie n .IP """replication""" 4
.el .IP "\f(CWreplication\fR" 4
.IX Item "replication"
Not documented
.ie n .IP """sheepdog""" 4
.el .IP "\f(CWsheepdog\fR" 4
.IX Item "sheepdog"
Not documented
.ie n .IP """ssh""" 4
.el .IP "\f(CWssh\fR" 4
.IX Item "ssh"
Not documented
.ie n .IP """vdi""" 4
.el .IP "\f(CWvdi\fR" 4
.IX Item "vdi"
Not documented
.ie n .IP """vhdx""" 4
.el .IP "\f(CWvhdx\fR" 4
.IX Item "vhdx"
Not documented
.ie n .IP """vmdk""" 4
.el .IP "\f(CWvmdk\fR" 4
.IX Item "vmdk"
Not documented
.ie n .IP """vpc""" 4
.el .IP "\f(CWvpc\fR" 4
.IX Item "vpc"
Not documented
.ie n .IP """vvfat""" 4
.el .IP "\f(CWvvfat\fR" 4
.IX Item "vvfat"
Not documented
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsFile\fR (Object)
.PP
Driver specific block device options for the file backend.
.PP
\&\fBMembers:\fR
.ie n .IP """filename: string""" 4
.el .IP "\f(CWfilename: string\fR" 4
.IX Item "filename: string"
path to the image file
.ie n .IP """aio: BlockdevAioOptions"" (optional)" 4
.el .IP "\f(CWaio: BlockdevAioOptions\fR (optional)" 4
.IX Item "aio: BlockdevAioOptions (optional)"
\&\s-1AIO\s0 backend (default: threads) (since: 2.8)
.ie n .IP """locking: OnOffAuto"" (optional)" 4
.el .IP "\f(CWlocking: OnOffAuto\fR (optional)" 4
.IX Item "locking: OnOffAuto (optional)"
whether to enable file locking. If set to 'auto', only enable
when Open File Descriptor (\s-1OFD\s0) locking \s-1API\s0 is available
(default: auto, since 2.10)
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsNull\fR (Object)
.PP
Driver specific block device options for the null backend.
.PP
\&\fBMembers:\fR
.ie n .IP """size: int"" (optional)" 4
.el .IP "\f(CWsize: int\fR (optional)" 4
.IX Item "size: int (optional)"
size of the device in bytes.
.ie n .IP """latency\-ns: int"" (optional)" 4
.el .IP "\f(CWlatency\-ns: int\fR (optional)" 4
.IX Item "latency-ns: int (optional)"
emulated latency (in nanoseconds) in processing
requests. Default to zero which completes requests immediately.
(Since 2.4)
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsVVFAT\fR (Object)
.PP
Driver specific block device options for the vvfat protocol.
.PP
\&\fBMembers:\fR
.ie n .IP """dir: string""" 4
.el .IP "\f(CWdir: string\fR" 4
.IX Item "dir: string"
directory to be exported as \s-1FAT\s0 image
.ie n .IP """fat\-type: int"" (optional)" 4
.el .IP "\f(CWfat\-type: int\fR (optional)" 4
.IX Item "fat-type: int (optional)"
\&\s-1FAT\s0 type: 12, 16 or 32
.ie n .IP """floppy: boolean"" (optional)" 4
.el .IP "\f(CWfloppy: boolean\fR (optional)" 4
.IX Item "floppy: boolean (optional)"
whether to export a floppy image (true) or
partitioned hard disk (false; default)
.ie n .IP """label: string"" (optional)" 4
.el .IP "\f(CWlabel: string\fR (optional)" 4
.IX Item "label: string (optional)"
set the volume label, limited to 11 bytes. \s-1FAT16\s0 and
\&\s-1FAT32\s0 traditionally have some restrictions on labels, which are
ignored by most operating systems. Defaults to \*(L"\s-1QEMU VVFAT\*(R".
\&\s0(since 2.4)
.ie n .IP """rw: boolean"" (optional)" 4
.el .IP "\f(CWrw: boolean\fR (optional)" 4
.IX Item "rw: boolean (optional)"
whether to allow write operations (default: false)
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsGenericFormat\fR (Object)
.PP
Driver specific block device options for image format that have no option
besides their data source.
.PP
\&\fBMembers:\fR
.ie n .IP """file: BlockdevRef""" 4
.el .IP "\f(CWfile: BlockdevRef\fR" 4
.IX Item "file: BlockdevRef"
reference to or definition of the data source block device
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsLUKS\fR (Object)
.PP
Driver specific block device options for \s-1LUKS.\s0
.PP
\&\fBMembers:\fR
.ie n .IP """key\-secret: string"" (optional)" 4
.el .IP "\f(CWkey\-secret: string\fR (optional)" 4
.IX Item "key-secret: string (optional)"
the \s-1ID\s0 of a QCryptoSecret object providing
the decryption key (since 2.6). Mandatory except when
doing a metadata-only probe of the image.
.ie n .IP "The members of ""BlockdevOptionsGenericFormat""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericFormat\fR" 4
.IX Item "The members of BlockdevOptionsGenericFormat"
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsGenericCOWFormat\fR (Object)
.PP
Driver specific block device options for image format that have no option
besides their data source and an optional backing file.
.PP
\&\fBMembers:\fR
.ie n .IP """backing: BlockdevRefOrNull"" (optional)" 4
.el .IP "\f(CWbacking: BlockdevRefOrNull\fR (optional)" 4
.IX Item "backing: BlockdevRefOrNull (optional)"
reference to or definition of the backing file block
device, null disables the backing file entirely.
Defaults to the backing file stored the image file.
.ie n .IP "The members of ""BlockdevOptionsGenericFormat""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericFormat\fR" 4
.IX Item "The members of BlockdevOptionsGenericFormat"
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBQcow2OverlapCheckMode\fR (Enum)
.PP
General overlap check modes.
.PP
\&\fBValues:\fR
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
Do not perform any checks
.ie n .IP """constant""" 4
.el .IP "\f(CWconstant\fR" 4
.IX Item "constant"
Perform only checks which can be done in constant time and
without reading anything from disk
.ie n .IP """cached""" 4
.el .IP "\f(CWcached\fR" 4
.IX Item "cached"
Perform only checks which can be done without reading anything
from disk
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
Perform all available overlap checks
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBQcow2OverlapCheckFlags\fR (Object)
.PP
Structure of flags for each metadata structure. Setting a field to 'true'
makes qemu guard that structure against unintended overwriting. The default
value is chosen according to the template given.
.PP
\&\fBMembers:\fR
.ie n .IP """template: Qcow2OverlapCheckMode"" (optional)" 4
.el .IP "\f(CWtemplate: Qcow2OverlapCheckMode\fR (optional)" 4
.IX Item "template: Qcow2OverlapCheckMode (optional)"
Specifies a template mode which can be adjusted using the other
flags, defaults to 'cached'
.ie n .IP """main\-header: boolean"" (optional)" 4
.el .IP "\f(CWmain\-header: boolean\fR (optional)" 4
.IX Item "main-header: boolean (optional)"
Not documented
.ie n .IP """active\-l1: boolean"" (optional)" 4
.el .IP "\f(CWactive\-l1: boolean\fR (optional)" 4
.IX Item "active-l1: boolean (optional)"
Not documented
.ie n .IP """active\-l2: boolean"" (optional)" 4
.el .IP "\f(CWactive\-l2: boolean\fR (optional)" 4
.IX Item "active-l2: boolean (optional)"
Not documented
.ie n .IP """refcount\-table: boolean"" (optional)" 4
.el .IP "\f(CWrefcount\-table: boolean\fR (optional)" 4
.IX Item "refcount-table: boolean (optional)"
Not documented
.ie n .IP """refcount\-block: boolean"" (optional)" 4
.el .IP "\f(CWrefcount\-block: boolean\fR (optional)" 4
.IX Item "refcount-block: boolean (optional)"
Not documented
.ie n .IP """snapshot\-table: boolean"" (optional)" 4
.el .IP "\f(CWsnapshot\-table: boolean\fR (optional)" 4
.IX Item "snapshot-table: boolean (optional)"
Not documented
.ie n .IP """inactive\-l1: boolean"" (optional)" 4
.el .IP "\f(CWinactive\-l1: boolean\fR (optional)" 4
.IX Item "inactive-l1: boolean (optional)"
Not documented
.ie n .IP """inactive\-l2: boolean"" (optional)" 4
.el .IP "\f(CWinactive\-l2: boolean\fR (optional)" 4
.IX Item "inactive-l2: boolean (optional)"
Not documented
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBQcow2OverlapChecks\fR (Alternate)
.PP
Specifies which metadata structures should be guarded against unintended
overwriting.
.PP
\&\fBMembers:\fR
.ie n .IP """flags: Qcow2OverlapCheckFlags""" 4
.el .IP "\f(CWflags: Qcow2OverlapCheckFlags\fR" 4
.IX Item "flags: Qcow2OverlapCheckFlags"
set of flags for separate specification of each metadata structure
type
.ie n .IP """mode: Qcow2OverlapCheckMode""" 4
.el .IP "\f(CWmode: Qcow2OverlapCheckMode\fR" 4
.IX Item "mode: Qcow2OverlapCheckMode"
named mode which chooses a specific set of flags
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevQcowEncryptionFormat\fR (Enum)
.PP
\&\fBValues:\fR
.ie n .IP """aes""" 4
.el .IP "\f(CWaes\fR" 4
.IX Item "aes"
AES-CBC with plain64 initialization vectors
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBBlockdevQcowEncryption\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """format: BlockdevQcowEncryptionFormat""" 4
.el .IP "\f(CWformat: BlockdevQcowEncryptionFormat\fR" 4
.IX Item "format: BlockdevQcowEncryptionFormat"
Not documented
.ie n .IP "The members of ""QCryptoBlockOptionsQCow"" when ""format"" is ""aes""" 4
.el .IP "The members of \f(CWQCryptoBlockOptionsQCow\fR when \f(CWformat\fR is ``aes''" 4
.IX Item "The members of QCryptoBlockOptionsQCow when format is aes"
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBBlockdevOptionsQcow\fR (Object)
.PP
Driver specific block device options for qcow.
.PP
\&\fBMembers:\fR
.ie n .IP """encrypt: BlockdevQcowEncryption"" (optional)" 4
.el .IP "\f(CWencrypt: BlockdevQcowEncryption\fR (optional)" 4
.IX Item "encrypt: BlockdevQcowEncryption (optional)"
Image decryption options. Mandatory for
encrypted images, except when doing a metadata-only
probe of the image.
.ie n .IP "The members of ""BlockdevOptionsGenericCOWFormat""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericCOWFormat\fR" 4
.IX Item "The members of BlockdevOptionsGenericCOWFormat"
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBBlockdevQcow2EncryptionFormat\fR (Enum)
.PP
\&\fBValues:\fR
.ie n .IP """aes""" 4
.el .IP "\f(CWaes\fR" 4
.IX Item "aes"
AES-CBC with plain64 initialization venctors
.ie n .IP """luks""" 4
.el .IP "\f(CWluks\fR" 4
.IX Item "luks"
Not documented
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBBlockdevQcow2Encryption\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """format: BlockdevQcow2EncryptionFormat""" 4
.el .IP "\f(CWformat: BlockdevQcow2EncryptionFormat\fR" 4
.IX Item "format: BlockdevQcow2EncryptionFormat"
Not documented
.ie n .IP "The members of ""QCryptoBlockOptionsQCow"" when ""format"" is ""aes""" 4
.el .IP "The members of \f(CWQCryptoBlockOptionsQCow\fR when \f(CWformat\fR is ``aes''" 4
.IX Item "The members of QCryptoBlockOptionsQCow when format is aes"
.PD 0
.ie n .IP "The members of ""QCryptoBlockOptionsLUKS"" when ""format"" is ""luks""" 4
.el .IP "The members of \f(CWQCryptoBlockOptionsLUKS\fR when \f(CWformat\fR is ``luks''" 4
.IX Item "The members of QCryptoBlockOptionsLUKS when format is luks"
.PD
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBBlockdevOptionsQcow2\fR (Object)
.PP
Driver specific block device options for qcow2.
.PP
\&\fBMembers:\fR
.ie n .IP """lazy\-refcounts: boolean"" (optional)" 4
.el .IP "\f(CWlazy\-refcounts: boolean\fR (optional)" 4
.IX Item "lazy-refcounts: boolean (optional)"
whether to enable the lazy refcounts
feature (default is taken from the image file)
.ie n .IP """pass\-discard\-request: boolean"" (optional)" 4
.el .IP "\f(CWpass\-discard\-request: boolean\fR (optional)" 4
.IX Item "pass-discard-request: boolean (optional)"
whether discard requests to the qcow2
device should be forwarded to the data source
.ie n .IP """pass\-discard\-snapshot: boolean"" (optional)" 4
.el .IP "\f(CWpass\-discard\-snapshot: boolean\fR (optional)" 4
.IX Item "pass-discard-snapshot: boolean (optional)"
whether discard requests for the data source
should be issued when a snapshot operation (e.g.
deleting a snapshot) frees clusters in the qcow2 file
.ie n .IP """pass\-discard\-other: boolean"" (optional)" 4
.el .IP "\f(CWpass\-discard\-other: boolean\fR (optional)" 4
.IX Item "pass-discard-other: boolean (optional)"
whether discard requests for the data source
should be issued on other occasions where a cluster
gets freed
.ie n .IP """overlap\-check: Qcow2OverlapChecks"" (optional)" 4
.el .IP "\f(CWoverlap\-check: Qcow2OverlapChecks\fR (optional)" 4
.IX Item "overlap-check: Qcow2OverlapChecks (optional)"
which overlap checks to perform for writes
to the image, defaults to 'cached' (since 2.2)
.ie n .IP """cache\-size: int"" (optional)" 4
.el .IP "\f(CWcache\-size: int\fR (optional)" 4
.IX Item "cache-size: int (optional)"
the maximum total size of the L2 table and
refcount block caches in bytes (since 2.2)
.ie n .IP """l2\-cache\-size: int"" (optional)" 4
.el .IP "\f(CWl2\-cache\-size: int\fR (optional)" 4
.IX Item "l2-cache-size: int (optional)"
the maximum size of the L2 table cache in
bytes (since 2.2)
.ie n .IP """refcount\-cache\-size: int"" (optional)" 4
.el .IP "\f(CWrefcount\-cache\-size: int\fR (optional)" 4
.IX Item "refcount-cache-size: int (optional)"
the maximum size of the refcount block cache
in bytes (since 2.2)
.ie n .IP """cache\-clean\-interval: int"" (optional)" 4
.el .IP "\f(CWcache\-clean\-interval: int\fR (optional)" 4
.IX Item "cache-clean-interval: int (optional)"
clean unused entries in the L2 and refcount
caches. The interval is in seconds. The default value
is 0 and it disables this feature (since 2.5)
.ie n .IP """encrypt: BlockdevQcow2Encryption"" (optional)" 4
.el .IP "\f(CWencrypt: BlockdevQcow2Encryption\fR (optional)" 4
.IX Item "encrypt: BlockdevQcow2Encryption (optional)"
Image decryption options. Mandatory for
encrypted images, except when doing a metadata-only
probe of the image. (since 2.10)
.ie n .IP "The members of ""BlockdevOptionsGenericCOWFormat""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericCOWFormat\fR" 4
.IX Item "The members of BlockdevOptionsGenericCOWFormat"
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsSsh\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """server: InetSocketAddress""" 4
.el .IP "\f(CWserver: InetSocketAddress\fR" 4
.IX Item "server: InetSocketAddress"
host address
.ie n .IP """path: string""" 4
.el .IP "\f(CWpath: string\fR" 4
.IX Item "path: string"
path to the image on the host
.ie n .IP """user: string"" (optional)" 4
.el .IP "\f(CWuser: string\fR (optional)" 4
.IX Item "user: string (optional)"
user as which to connect, defaults to current
local user name
.PP
\&\fB\s-1TODO:\s0\fR
Expose the host_key_check option in \s-1QMP\s0
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlkdebugEvent\fR (Enum)
.PP
Trigger events supported by blkdebug.
.PP
\&\fBValues:\fR
.ie n .IP """l1_update""" 4
.el .IP "\f(CWl1_update\fR" 4
.IX Item "l1_update"
Not documented
.ie n .IP """l1_grow_alloc_table""" 4
.el .IP "\f(CWl1_grow_alloc_table\fR" 4
.IX Item "l1_grow_alloc_table"
Not documented
.ie n .IP """l1_grow_write_table""" 4
.el .IP "\f(CWl1_grow_write_table\fR" 4
.IX Item "l1_grow_write_table"
Not documented
.ie n .IP """l1_grow_activate_table""" 4
.el .IP "\f(CWl1_grow_activate_table\fR" 4
.IX Item "l1_grow_activate_table"
Not documented
.ie n .IP """l2_load""" 4
.el .IP "\f(CWl2_load\fR" 4
.IX Item "l2_load"
Not documented
.ie n .IP """l2_update""" 4
.el .IP "\f(CWl2_update\fR" 4
.IX Item "l2_update"
Not documented
.ie n .IP """l2_update_compressed""" 4
.el .IP "\f(CWl2_update_compressed\fR" 4
.IX Item "l2_update_compressed"
Not documented
.ie n .IP """l2_alloc_cow_read""" 4
.el .IP "\f(CWl2_alloc_cow_read\fR" 4
.IX Item "l2_alloc_cow_read"
Not documented
.ie n .IP """l2_alloc_write""" 4
.el .IP "\f(CWl2_alloc_write\fR" 4
.IX Item "l2_alloc_write"
Not documented
.ie n .IP """read_aio""" 4
.el .IP "\f(CWread_aio\fR" 4
.IX Item "read_aio"
Not documented
.ie n .IP """read_backing_aio""" 4
.el .IP "\f(CWread_backing_aio\fR" 4
.IX Item "read_backing_aio"
Not documented
.ie n .IP """read_compressed""" 4
.el .IP "\f(CWread_compressed\fR" 4
.IX Item "read_compressed"
Not documented
.ie n .IP """write_aio""" 4
.el .IP "\f(CWwrite_aio\fR" 4
.IX Item "write_aio"
Not documented
.ie n .IP """write_compressed""" 4
.el .IP "\f(CWwrite_compressed\fR" 4
.IX Item "write_compressed"
Not documented
.ie n .IP """vmstate_load""" 4
.el .IP "\f(CWvmstate_load\fR" 4
.IX Item "vmstate_load"
Not documented
.ie n .IP """vmstate_save""" 4
.el .IP "\f(CWvmstate_save\fR" 4
.IX Item "vmstate_save"
Not documented
.ie n .IP """cow_read""" 4
.el .IP "\f(CWcow_read\fR" 4
.IX Item "cow_read"
Not documented
.ie n .IP """cow_write""" 4
.el .IP "\f(CWcow_write\fR" 4
.IX Item "cow_write"
Not documented
.ie n .IP """reftable_load""" 4
.el .IP "\f(CWreftable_load\fR" 4
.IX Item "reftable_load"
Not documented
.ie n .IP """reftable_grow""" 4
.el .IP "\f(CWreftable_grow\fR" 4
.IX Item "reftable_grow"
Not documented
.ie n .IP """reftable_update""" 4
.el .IP "\f(CWreftable_update\fR" 4
.IX Item "reftable_update"
Not documented
.ie n .IP """refblock_load""" 4
.el .IP "\f(CWrefblock_load\fR" 4
.IX Item "refblock_load"
Not documented
.ie n .IP """refblock_update""" 4
.el .IP "\f(CWrefblock_update\fR" 4
.IX Item "refblock_update"
Not documented
.ie n .IP """refblock_update_part""" 4
.el .IP "\f(CWrefblock_update_part\fR" 4
.IX Item "refblock_update_part"
Not documented
.ie n .IP """refblock_alloc""" 4
.el .IP "\f(CWrefblock_alloc\fR" 4
.IX Item "refblock_alloc"
Not documented
.ie n .IP """refblock_alloc_hookup""" 4
.el .IP "\f(CWrefblock_alloc_hookup\fR" 4
.IX Item "refblock_alloc_hookup"
Not documented
.ie n .IP """refblock_alloc_write""" 4
.el .IP "\f(CWrefblock_alloc_write\fR" 4
.IX Item "refblock_alloc_write"
Not documented
.ie n .IP """refblock_alloc_write_blocks""" 4
.el .IP "\f(CWrefblock_alloc_write_blocks\fR" 4
.IX Item "refblock_alloc_write_blocks"
Not documented
.ie n .IP """refblock_alloc_write_table""" 4
.el .IP "\f(CWrefblock_alloc_write_table\fR" 4
.IX Item "refblock_alloc_write_table"
Not documented
.ie n .IP """refblock_alloc_switch_table""" 4
.el .IP "\f(CWrefblock_alloc_switch_table\fR" 4
.IX Item "refblock_alloc_switch_table"
Not documented
.ie n .IP """cluster_alloc""" 4
.el .IP "\f(CWcluster_alloc\fR" 4
.IX Item "cluster_alloc"
Not documented
.ie n .IP """cluster_alloc_bytes""" 4
.el .IP "\f(CWcluster_alloc_bytes\fR" 4
.IX Item "cluster_alloc_bytes"
Not documented
.ie n .IP """cluster_free""" 4
.el .IP "\f(CWcluster_free\fR" 4
.IX Item "cluster_free"
Not documented
.ie n .IP """flush_to_os""" 4
.el .IP "\f(CWflush_to_os\fR" 4
.IX Item "flush_to_os"
Not documented
.ie n .IP """flush_to_disk""" 4
.el .IP "\f(CWflush_to_disk\fR" 4
.IX Item "flush_to_disk"
Not documented
.ie n .IP """pwritev_rmw_head""" 4
.el .IP "\f(CWpwritev_rmw_head\fR" 4
.IX Item "pwritev_rmw_head"
Not documented
.ie n .IP """pwritev_rmw_after_head""" 4
.el .IP "\f(CWpwritev_rmw_after_head\fR" 4
.IX Item "pwritev_rmw_after_head"
Not documented
.ie n .IP """pwritev_rmw_tail""" 4
.el .IP "\f(CWpwritev_rmw_tail\fR" 4
.IX Item "pwritev_rmw_tail"
Not documented
.ie n .IP """pwritev_rmw_after_tail""" 4
.el .IP "\f(CWpwritev_rmw_after_tail\fR" 4
.IX Item "pwritev_rmw_after_tail"
Not documented
.ie n .IP """pwritev""" 4
.el .IP "\f(CWpwritev\fR" 4
.IX Item "pwritev"
Not documented
.ie n .IP """pwritev_zero""" 4
.el .IP "\f(CWpwritev_zero\fR" 4
.IX Item "pwritev_zero"
Not documented
.ie n .IP """pwritev_done""" 4
.el .IP "\f(CWpwritev_done\fR" 4
.IX Item "pwritev_done"
Not documented
.ie n .IP """empty_image_prepare""" 4
.el .IP "\f(CWempty_image_prepare\fR" 4
.IX Item "empty_image_prepare"
Not documented
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlkdebugInjectErrorOptions\fR (Object)
.PP
Describes a single error injection for blkdebug.
.PP
\&\fBMembers:\fR
.ie n .IP """event: BlkdebugEvent""" 4
.el .IP "\f(CWevent: BlkdebugEvent\fR" 4
.IX Item "event: BlkdebugEvent"
trigger event
.ie n .IP """state: int"" (optional)" 4
.el .IP "\f(CWstate: int\fR (optional)" 4
.IX Item "state: int (optional)"
the state identifier blkdebug needs to be in to
actually trigger the event; defaults to \*(L"any\*(R"
.ie n .IP """errno: int"" (optional)" 4
.el .IP "\f(CWerrno: int\fR (optional)" 4
.IX Item "errno: int (optional)"
error identifier (errno) to be returned; defaults to
\&\s-1EIO\s0
.ie n .IP """sector: int"" (optional)" 4
.el .IP "\f(CWsector: int\fR (optional)" 4
.IX Item "sector: int (optional)"
specifies the sector index which has to be affected
in order to actually trigger the event; defaults to \*(L"any
sector\*(R"
.ie n .IP """once: boolean"" (optional)" 4
.el .IP "\f(CWonce: boolean\fR (optional)" 4
.IX Item "once: boolean (optional)"
disables further events after this one has been
triggered; defaults to false
.ie n .IP """immediately: boolean"" (optional)" 4
.el .IP "\f(CWimmediately: boolean\fR (optional)" 4
.IX Item "immediately: boolean (optional)"
fail immediately; defaults to false
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlkdebugSetStateOptions\fR (Object)
.PP
Describes a single state-change event for blkdebug.
.PP
\&\fBMembers:\fR
.ie n .IP """event: BlkdebugEvent""" 4
.el .IP "\f(CWevent: BlkdebugEvent\fR" 4
.IX Item "event: BlkdebugEvent"
trigger event
.ie n .IP """state: int"" (optional)" 4
.el .IP "\f(CWstate: int\fR (optional)" 4
.IX Item "state: int (optional)"
the current state identifier blkdebug needs to be in;
defaults to \*(L"any\*(R"
.ie n .IP """new_state: int""" 4
.el .IP "\f(CWnew_state: int\fR" 4
.IX Item "new_state: int"
the state identifier blkdebug is supposed to assume if
this event is triggered
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsBlkdebug\fR (Object)
.PP
Driver specific block device options for blkdebug.
.PP
\&\fBMembers:\fR
.ie n .IP """image: BlockdevRef""" 4
.el .IP "\f(CWimage: BlockdevRef\fR" 4
.IX Item "image: BlockdevRef"
underlying raw block device (or image file)
.ie n .IP """config: string"" (optional)" 4
.el .IP "\f(CWconfig: string\fR (optional)" 4
.IX Item "config: string (optional)"
filename of the configuration file
.ie n .IP """align: int"" (optional)" 4
.el .IP "\f(CWalign: int\fR (optional)" 4
.IX Item "align: int (optional)"
required alignment for requests in bytes, must be
positive power of 2, or 0 for default
.ie n .IP """max\-transfer: int"" (optional)" 4
.el .IP "\f(CWmax\-transfer: int\fR (optional)" 4
.IX Item "max-transfer: int (optional)"
maximum size for I/O transfers in bytes, must be
positive multiple of \f(CW\*(C`align\*(C'\fR and of the underlying
file's request alignment (but need not be a power of
2), or 0 for default (since 2.10)
.ie n .IP """opt\-write\-zero: int"" (optional)" 4
.el .IP "\f(CWopt\-write\-zero: int\fR (optional)" 4
.IX Item "opt-write-zero: int (optional)"
preferred alignment for write zero requests in bytes,
must be positive multiple of \f(CW\*(C`align\*(C'\fR and of the
underlying file's request alignment (but need not be a
power of 2), or 0 for default (since 2.10)
.ie n .IP """max\-write\-zero: int"" (optional)" 4
.el .IP "\f(CWmax\-write\-zero: int\fR (optional)" 4
.IX Item "max-write-zero: int (optional)"
maximum size for write zero requests in bytes, must be
positive multiple of \f(CW\*(C`align\*(C'\fR, of \f(CW\*(C`opt\-write\-zero\*(C'\fR, and of
the underlying file's request alignment (but need not
be a power of 2), or 0 for default (since 2.10)
.ie n .IP """opt\-discard: int"" (optional)" 4
.el .IP "\f(CWopt\-discard: int\fR (optional)" 4
.IX Item "opt-discard: int (optional)"
preferred alignment for discard requests in bytes, must
be positive multiple of \f(CW\*(C`align\*(C'\fR and of the underlying
file's request alignment (but need not be a power of
2), or 0 for default (since 2.10)
.ie n .IP """max\-discard: int"" (optional)" 4
.el .IP "\f(CWmax\-discard: int\fR (optional)" 4
.IX Item "max-discard: int (optional)"
maximum size for discard requests in bytes, must be
positive multiple of \f(CW\*(C`align\*(C'\fR, of \f(CW\*(C`opt\-discard\*(C'\fR, and of
the underlying file's request alignment (but need not
be a power of 2), or 0 for default (since 2.10)
.ie n .IP """inject\-error: array of BlkdebugInjectErrorOptions"" (optional)" 4
.el .IP "\f(CWinject\-error: array of BlkdebugInjectErrorOptions\fR (optional)" 4
.IX Item "inject-error: array of BlkdebugInjectErrorOptions (optional)"
array of error injection descriptions
.ie n .IP """set\-state: array of BlkdebugSetStateOptions"" (optional)" 4
.el .IP "\f(CWset\-state: array of BlkdebugSetStateOptions\fR (optional)" 4
.IX Item "set-state: array of BlkdebugSetStateOptions (optional)"
array of state-change descriptions
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsBlkverify\fR (Object)
.PP
Driver specific block device options for blkverify.
.PP
\&\fBMembers:\fR
.ie n .IP """test: BlockdevRef""" 4
.el .IP "\f(CWtest: BlockdevRef\fR" 4
.IX Item "test: BlockdevRef"
block device to be tested
.ie n .IP """raw: BlockdevRef""" 4
.el .IP "\f(CWraw: BlockdevRef\fR" 4
.IX Item "raw: BlockdevRef"
raw image used for verification
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBQuorumReadPattern\fR (Enum)
.PP
An enumeration of quorum read patterns.
.PP
\&\fBValues:\fR
.ie n .IP """quorum""" 4
.el .IP "\f(CWquorum\fR" 4
.IX Item "quorum"
read all the children and do a quorum vote on reads
.ie n .IP """fifo""" 4
.el .IP "\f(CWfifo\fR" 4
.IX Item "fifo"
read only from the first child that has not failed
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsQuorum\fR (Object)
.PP
Driver specific block device options for Quorum
.PP
\&\fBMembers:\fR
.ie n .IP """blkverify: boolean"" (optional)" 4
.el .IP "\f(CWblkverify: boolean\fR (optional)" 4
.IX Item "blkverify: boolean (optional)"
true if the driver must print content mismatch
set to false by default
.ie n .IP """children: array of BlockdevRef""" 4
.el .IP "\f(CWchildren: array of BlockdevRef\fR" 4
.IX Item "children: array of BlockdevRef"
the children block devices to use
.ie n .IP """vote\-threshold: int""" 4
.el .IP "\f(CWvote\-threshold: int\fR" 4
.IX Item "vote-threshold: int"
the vote limit under which a read will fail
.ie n .IP """rewrite\-corrupted: boolean"" (optional)" 4
.el .IP "\f(CWrewrite\-corrupted: boolean\fR (optional)" 4
.IX Item "rewrite-corrupted: boolean (optional)"
rewrite corrupted data when quorum is reached
(Since 2.1)
.ie n .IP """read\-pattern: QuorumReadPattern"" (optional)" 4
.el .IP "\f(CWread\-pattern: QuorumReadPattern\fR (optional)" 4
.IX Item "read-pattern: QuorumReadPattern (optional)"
choose read pattern and set to quorum by default
(Since 2.2)
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsGluster\fR (Object)
.PP
Driver specific block device options for Gluster
.PP
\&\fBMembers:\fR
.ie n .IP """volume: string""" 4
.el .IP "\f(CWvolume: string\fR" 4
.IX Item "volume: string"
name of gluster volume where \s-1VM\s0 image resides
.ie n .IP """path: string""" 4
.el .IP "\f(CWpath: string\fR" 4
.IX Item "path: string"
absolute path to image file in gluster volume
.ie n .IP """server: array of SocketAddress""" 4
.el .IP "\f(CWserver: array of SocketAddress\fR" 4
.IX Item "server: array of SocketAddress"
gluster servers description
.ie n .IP """debug: int"" (optional)" 4
.el .IP "\f(CWdebug: int\fR (optional)" 4
.IX Item "debug: int (optional)"
libgfapi log level (default '4' which is Error)
(Since 2.8)
.ie n .IP """logfile: string"" (optional)" 4
.el .IP "\f(CWlogfile: string\fR (optional)" 4
.IX Item "logfile: string (optional)"
libgfapi log file (default /dev/stderr) (Since 2.8)
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBIscsiTransport\fR (Enum)
.PP
An enumeration of libiscsi transport types
.PP
\&\fBValues:\fR
.ie n .IP """tcp""" 4
.el .IP "\f(CWtcp\fR" 4
.IX Item "tcp"
Not documented
.ie n .IP """iser""" 4
.el .IP "\f(CWiser\fR" 4
.IX Item "iser"
Not documented
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBIscsiHeaderDigest\fR (Enum)
.PP
An enumeration of header digests supported by libiscsi
.PP
\&\fBValues:\fR
.ie n .IP """crc32c""" 4
.el .IP "\f(CWcrc32c\fR" 4
.IX Item "crc32c"
Not documented
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
Not documented
.ie n .IP """crc32c\-none""" 4
.el .IP "\f(CWcrc32c\-none\fR" 4
.IX Item "crc32c-none"
Not documented
.ie n .IP """none\-crc32c""" 4
.el .IP "\f(CWnone\-crc32c\fR" 4
.IX Item "none-crc32c"
Not documented
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsIscsi\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """transport: IscsiTransport""" 4
.el .IP "\f(CWtransport: IscsiTransport\fR" 4
.IX Item "transport: IscsiTransport"
The iscsi transport type
.ie n .IP """portal: string""" 4
.el .IP "\f(CWportal: string\fR" 4
.IX Item "portal: string"
The address of the iscsi portal
.ie n .IP """target: string""" 4
.el .IP "\f(CWtarget: string\fR" 4
.IX Item "target: string"
The target iqn name
.ie n .IP """lun: int"" (optional)" 4
.el .IP "\f(CWlun: int\fR (optional)" 4
.IX Item "lun: int (optional)"
\&\s-1LUN\s0 to connect to. Defaults to 0.
.ie n .IP """user: string"" (optional)" 4
.el .IP "\f(CWuser: string\fR (optional)" 4
.IX Item "user: string (optional)"
User name to log in with. If omitted, no \s-1CHAP\s0
authentication is performed.
.ie n .IP """password\-secret: string"" (optional)" 4
.el .IP "\f(CWpassword\-secret: string\fR (optional)" 4
.IX Item "password-secret: string (optional)"
The \s-1ID\s0 of a QCryptoSecret object providing
the password for the login. This option is required if
\&\f(CW\*(C`user\*(C'\fR is specified.
.ie n .IP """initiator\-name: string"" (optional)" 4
.el .IP "\f(CWinitiator\-name: string\fR (optional)" 4
.IX Item "initiator-name: string (optional)"
The iqn name we want to identify to the target
as. If this option is not specified, an initiator name is
generated automatically.
.ie n .IP """header\-digest: IscsiHeaderDigest"" (optional)" 4
.el .IP "\f(CWheader\-digest: IscsiHeaderDigest\fR (optional)" 4
.IX Item "header-digest: IscsiHeaderDigest (optional)"
The desired header digest. Defaults to
none\-crc32c.
.ie n .IP """timeout: int"" (optional)" 4
.el .IP "\f(CWtimeout: int\fR (optional)" 4
.IX Item "timeout: int (optional)"
Timeout in seconds after which a request will
timeout. 0 means no timeout and is the default.
.PP
Driver specific block device options for iscsi
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsRbd\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """pool: string""" 4
.el .IP "\f(CWpool: string\fR" 4
.IX Item "pool: string"
Ceph pool name.
.ie n .IP """image: string""" 4
.el .IP "\f(CWimage: string\fR" 4
.IX Item "image: string"
Image name in the Ceph pool.
.ie n .IP """conf: string"" (optional)" 4
.el .IP "\f(CWconf: string\fR (optional)" 4
.IX Item "conf: string (optional)"
path to Ceph configuration file.  Values
in the configuration file will be overridden by
options specified via \s-1QAPI.\s0
.ie n .IP """snapshot: string"" (optional)" 4
.el .IP "\f(CWsnapshot: string\fR (optional)" 4
.IX Item "snapshot: string (optional)"
Ceph snapshot name.
.ie n .IP """user: string"" (optional)" 4
.el .IP "\f(CWuser: string\fR (optional)" 4
.IX Item "user: string (optional)"
Ceph id name.
.ie n .IP """server: array of InetSocketAddressBase"" (optional)" 4
.el .IP "\f(CWserver: array of InetSocketAddressBase\fR (optional)" 4
.IX Item "server: array of InetSocketAddressBase (optional)"
Monitor host address and port.  This maps
to the \*(L"mon_host\*(R" Ceph option.
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsSheepdog\fR (Object)
.PP
Driver specific block device options for sheepdog
.PP
\&\fBMembers:\fR
.ie n .IP """vdi: string""" 4
.el .IP "\f(CWvdi: string\fR" 4
.IX Item "vdi: string"
Virtual disk image name
.ie n .IP """server: SocketAddress""" 4
.el .IP "\f(CWserver: SocketAddress\fR" 4
.IX Item "server: SocketAddress"
The Sheepdog server to connect to
.ie n .IP """snap\-id: int"" (optional)" 4
.el .IP "\f(CWsnap\-id: int\fR (optional)" 4
.IX Item "snap-id: int (optional)"
Snapshot \s-1ID\s0
.ie n .IP """tag: string"" (optional)" 4
.el .IP "\f(CWtag: string\fR (optional)" 4
.IX Item "tag: string (optional)"
Snapshot tag name
.PP
Only one of \f(CW\*(C`snap\-id\*(C'\fR and \f(CW\*(C`tag\*(C'\fR may be present.
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBReplicationMode\fR (Enum)
.PP
An enumeration of replication modes.
.PP
\&\fBValues:\fR
.ie n .IP """primary""" 4
.el .IP "\f(CWprimary\fR" 4
.IX Item "primary"
Primary mode, the vm's state will be sent to secondary \s-1QEMU.\s0
.ie n .IP """secondary""" 4
.el .IP "\f(CWsecondary\fR" 4
.IX Item "secondary"
Secondary mode, receive the vm's state from primary \s-1QEMU.\s0
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsReplication\fR (Object)
.PP
Driver specific block device options for replication
.PP
\&\fBMembers:\fR
.ie n .IP """mode: ReplicationMode""" 4
.el .IP "\f(CWmode: ReplicationMode\fR" 4
.IX Item "mode: ReplicationMode"
the replication mode
.ie n .IP """top\-id: string"" (optional)" 4
.el .IP "\f(CWtop\-id: string\fR (optional)" 4
.IX Item "top-id: string (optional)"
In secondary mode, node name or device \s-1ID\s0 of the root
node who owns the replication node chain. Must not be given in
primary mode.
.ie n .IP "The members of ""BlockdevOptionsGenericFormat""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericFormat\fR" 4
.IX Item "The members of BlockdevOptionsGenericFormat"
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBNFSTransport\fR (Enum)
.PP
An enumeration of \s-1NFS\s0 transport types
.PP
\&\fBValues:\fR
.ie n .IP """inet""" 4
.el .IP "\f(CWinet\fR" 4
.IX Item "inet"
\&\s-1TCP\s0 transport
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBNFSServer\fR (Object)
.PP
Captures the address of the socket
.PP
\&\fBMembers:\fR
.ie n .IP """type: NFSTransport""" 4
.el .IP "\f(CWtype: NFSTransport\fR" 4
.IX Item "type: NFSTransport"
transport type used for \s-1NFS \s0(only \s-1TCP\s0 supported)
.ie n .IP """host: string""" 4
.el .IP "\f(CWhost: string\fR" 4
.IX Item "host: string"
host address for \s-1NFS\s0 server
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsNfs\fR (Object)
.PP
Driver specific block device option for \s-1NFS\s0
.PP
\&\fBMembers:\fR
.ie n .IP """server: NFSServer""" 4
.el .IP "\f(CWserver: NFSServer\fR" 4
.IX Item "server: NFSServer"
host address
.ie n .IP """path: string""" 4
.el .IP "\f(CWpath: string\fR" 4
.IX Item "path: string"
path of the image on the host
.ie n .IP """user: int"" (optional)" 4
.el .IP "\f(CWuser: int\fR (optional)" 4
.IX Item "user: int (optional)"
\&\s-1UID\s0 value to use when talking to the
server (defaults to 65534 on Windows and \fIgetuid()\fR
on unix)
.ie n .IP """group: int"" (optional)" 4
.el .IP "\f(CWgroup: int\fR (optional)" 4
.IX Item "group: int (optional)"
\&\s-1GID\s0 value to use when talking to the
server (defaults to 65534 on Windows and \fIgetgid()\fR
in unix)
.ie n .IP """tcp\-syn\-count: int"" (optional)" 4
.el .IP "\f(CWtcp\-syn\-count: int\fR (optional)" 4
.IX Item "tcp-syn-count: int (optional)"
number of SYNs during the session
establishment (defaults to libnfs default)
.ie n .IP """readahead\-size: int"" (optional)" 4
.el .IP "\f(CWreadahead\-size: int\fR (optional)" 4
.IX Item "readahead-size: int (optional)"
set the readahead size in bytes (defaults
to libnfs default)
.ie n .IP """page\-cache\-size: int"" (optional)" 4
.el .IP "\f(CWpage\-cache\-size: int\fR (optional)" 4
.IX Item "page-cache-size: int (optional)"
set the pagecache size in bytes (defaults
to libnfs default)
.ie n .IP """debug: int"" (optional)" 4
.el .IP "\f(CWdebug: int\fR (optional)" 4
.IX Item "debug: int (optional)"
set the \s-1NFS\s0 debug level (max 2) (defaults
to libnfs default)
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsCurlBase\fR (Object)
.PP
Driver specific block device options shared by all protocols supported by the
curl backend.
.PP
\&\fBMembers:\fR
.ie n .IP """url: string""" 4
.el .IP "\f(CWurl: string\fR" 4
.IX Item "url: string"
\&\s-1URL\s0 of the image file
.ie n .IP """readahead: int"" (optional)" 4
.el .IP "\f(CWreadahead: int\fR (optional)" 4
.IX Item "readahead: int (optional)"
Size of the read-ahead cache; must be a multiple of
512 (defaults to 256 kB)
.ie n .IP """timeout: int"" (optional)" 4
.el .IP "\f(CWtimeout: int\fR (optional)" 4
.IX Item "timeout: int (optional)"
Timeout for connections, in seconds (defaults to 5)
.ie n .IP """username: string"" (optional)" 4
.el .IP "\f(CWusername: string\fR (optional)" 4
.IX Item "username: string (optional)"
Username for authentication (defaults to none)
.ie n .IP """password\-secret: string"" (optional)" 4
.el .IP "\f(CWpassword\-secret: string\fR (optional)" 4
.IX Item "password-secret: string (optional)"
\&\s-1ID\s0 of a QCryptoSecret object providing a password
for authentication (defaults to no password)
.ie n .IP """proxy\-username: string"" (optional)" 4
.el .IP "\f(CWproxy\-username: string\fR (optional)" 4
.IX Item "proxy-username: string (optional)"
Username for proxy authentication (defaults to none)
.ie n .IP """proxy\-password\-secret: string"" (optional)" 4
.el .IP "\f(CWproxy\-password\-secret: string\fR (optional)" 4
.IX Item "proxy-password-secret: string (optional)"
\&\s-1ID\s0 of a QCryptoSecret object providing a password
for proxy authentication (defaults to no password)
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsCurlHttp\fR (Object)
.PP
Driver specific block device options for \s-1HTTP\s0 connections over the curl
backend.  URLs must start with \*(L"http://\*(R".
.PP
\&\fBMembers:\fR
.ie n .IP """cookie: string"" (optional)" 4
.el .IP "\f(CWcookie: string\fR (optional)" 4
.IX Item "cookie: string (optional)"
List of cookies to set; format is
\&\*(L"name1=content1; name2=content2;\*(R" as explained by
\&\s-1\fICURLOPT_COOKIE\s0\fR\|(3). Defaults to no cookies.
.ie n .IP """cookie\-secret: string"" (optional)" 4
.el .IP "\f(CWcookie\-secret: string\fR (optional)" 4
.IX Item "cookie-secret: string (optional)"
\&\s-1ID\s0 of a QCryptoSecret object providing the cookie data in a
secure way. See \f(CW\*(C`cookie\*(C'\fR for the format. (since 2.10)
.ie n .IP "The members of ""BlockdevOptionsCurlBase""" 4
.el .IP "The members of \f(CWBlockdevOptionsCurlBase\fR" 4
.IX Item "The members of BlockdevOptionsCurlBase"
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsCurlHttps\fR (Object)
.PP
Driver specific block device options for \s-1HTTPS\s0 connections over the curl
backend.  URLs must start with \*(L"https://\*(R".
.PP
\&\fBMembers:\fR
.ie n .IP """cookie: string"" (optional)" 4
.el .IP "\f(CWcookie: string\fR (optional)" 4
.IX Item "cookie: string (optional)"
List of cookies to set; format is
\&\*(L"name1=content1; name2=content2;\*(R" as explained by
\&\s-1\fICURLOPT_COOKIE\s0\fR\|(3). Defaults to no cookies.
.ie n .IP """sslverify: boolean"" (optional)" 4
.el .IP "\f(CWsslverify: boolean\fR (optional)" 4
.IX Item "sslverify: boolean (optional)"
Whether to verify the \s-1SSL\s0 certificate's validity (defaults to
true)
.ie n .IP """cookie\-secret: string"" (optional)" 4
.el .IP "\f(CWcookie\-secret: string\fR (optional)" 4
.IX Item "cookie-secret: string (optional)"
\&\s-1ID\s0 of a QCryptoSecret object providing the cookie data in a
secure way. See \f(CW\*(C`cookie\*(C'\fR for the format. (since 2.10)
.ie n .IP "The members of ""BlockdevOptionsCurlBase""" 4
.el .IP "The members of \f(CWBlockdevOptionsCurlBase\fR" 4
.IX Item "The members of BlockdevOptionsCurlBase"
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsCurlFtp\fR (Object)
.PP
Driver specific block device options for \s-1FTP\s0 connections over the curl
backend.  URLs must start with \*(L"ftp://\*(R".
.PP
\&\fBMembers:\fR
.ie n .IP "The members of ""BlockdevOptionsCurlBase""" 4
.el .IP "The members of \f(CWBlockdevOptionsCurlBase\fR" 4
.IX Item "The members of BlockdevOptionsCurlBase"
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsCurlFtps\fR (Object)
.PP
Driver specific block device options for \s-1FTPS\s0 connections over the curl
backend.  URLs must start with \*(L"ftps://\*(R".
.PP
\&\fBMembers:\fR
.ie n .IP """sslverify: boolean"" (optional)" 4
.el .IP "\f(CWsslverify: boolean\fR (optional)" 4
.IX Item "sslverify: boolean (optional)"
Whether to verify the \s-1SSL\s0 certificate's validity (defaults to
true)
.ie n .IP "The members of ""BlockdevOptionsCurlBase""" 4
.el .IP "The members of \f(CWBlockdevOptionsCurlBase\fR" 4
.IX Item "The members of BlockdevOptionsCurlBase"
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsNbd\fR (Object)
.PP
Driver specific block device options for \s-1NBD.\s0
.PP
\&\fBMembers:\fR
.ie n .IP """server: SocketAddress""" 4
.el .IP "\f(CWserver: SocketAddress\fR" 4
.IX Item "server: SocketAddress"
\&\s-1NBD\s0 server address
.ie n .IP """export: string"" (optional)" 4
.el .IP "\f(CWexport: string\fR (optional)" 4
.IX Item "export: string (optional)"
export name
.ie n .IP """tls\-creds: string"" (optional)" 4
.el .IP "\f(CWtls\-creds: string\fR (optional)" 4
.IX Item "tls-creds: string (optional)"
\&\s-1TLS\s0 credentials \s-1ID\s0
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsRaw\fR (Object)
.PP
Driver specific block device options for the raw driver.
.PP
\&\fBMembers:\fR
.ie n .IP """offset: int"" (optional)" 4
.el .IP "\f(CWoffset: int\fR (optional)" 4
.IX Item "offset: int (optional)"
position where the block device starts
.ie n .IP """size: int"" (optional)" 4
.el .IP "\f(CWsize: int\fR (optional)" 4
.IX Item "size: int (optional)"
the assumed size of the device
.ie n .IP "The members of ""BlockdevOptionsGenericFormat""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericFormat\fR" 4
.IX Item "The members of BlockdevOptionsGenericFormat"
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevOptionsVxHS\fR (Object)
.PP
Driver specific block device options for VxHS
.PP
\&\fBMembers:\fR
.ie n .IP """vdisk\-id: string""" 4
.el .IP "\f(CWvdisk\-id: string\fR" 4
.IX Item "vdisk-id: string"
\&\s-1UUID\s0 of VxHS volume
.ie n .IP """server: InetSocketAddressBase""" 4
.el .IP "\f(CWserver: InetSocketAddressBase\fR" 4
.IX Item "server: InetSocketAddressBase"
vxhs server \s-1IP,\s0 port
.ie n .IP """tls\-creds: string"" (optional)" 4
.el .IP "\f(CWtls\-creds: string\fR (optional)" 4
.IX Item "tls-creds: string (optional)"
\&\s-1TLS\s0 credentials \s-1ID\s0
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBBlockdevOptions\fR (Object)
.PP
Options for creating a block device.  Many options are available for all
block devices, independent of the block driver:
.PP
\&\fBMembers:\fR
.ie n .IP """driver: BlockdevDriver""" 4
.el .IP "\f(CWdriver: BlockdevDriver\fR" 4
.IX Item "driver: BlockdevDriver"
block driver name
.ie n .IP """node\-name: string"" (optional)" 4
.el .IP "\f(CWnode\-name: string\fR (optional)" 4
.IX Item "node-name: string (optional)"
the node name of the new node (Since 2.0).
This option is required on the top level of blockdev-add.
.ie n .IP """discard: BlockdevDiscardOptions"" (optional)" 4
.el .IP "\f(CWdiscard: BlockdevDiscardOptions\fR (optional)" 4
.IX Item "discard: BlockdevDiscardOptions (optional)"
discard-related options (default: ignore)
.ie n .IP """cache: BlockdevCacheOptions"" (optional)" 4
.el .IP "\f(CWcache: BlockdevCacheOptions\fR (optional)" 4
.IX Item "cache: BlockdevCacheOptions (optional)"
cache-related options
.ie n .IP """read\-only: boolean"" (optional)" 4
.el .IP "\f(CWread\-only: boolean\fR (optional)" 4
.IX Item "read-only: boolean (optional)"
whether the block device should be read-only
(default: false)
.ie n .IP """detect\-zeroes: BlockdevDetectZeroesOptions"" (optional)" 4
.el .IP "\f(CWdetect\-zeroes: BlockdevDetectZeroesOptions\fR (optional)" 4
.IX Item "detect-zeroes: BlockdevDetectZeroesOptions (optional)"
detect and optimize zero writes (Since 2.1)
(default: off)
.ie n .IP """force\-share: boolean"" (optional)" 4
.el .IP "\f(CWforce\-share: boolean\fR (optional)" 4
.IX Item "force-share: boolean (optional)"
force share all permission on added nodes.
Requires read\-only=true. (Since 2.10)
.ie n .IP "The members of ""BlockdevOptionsBlkdebug"" when ""driver"" is ""blkdebug""" 4
.el .IP "The members of \f(CWBlockdevOptionsBlkdebug\fR when \f(CWdriver\fR is ``blkdebug''" 4
.IX Item "The members of BlockdevOptionsBlkdebug when driver is blkdebug"
.PD 0
.ie n .IP "The members of ""BlockdevOptionsBlkverify"" when ""driver"" is ""blkverify""" 4
.el .IP "The members of \f(CWBlockdevOptionsBlkverify\fR when \f(CWdriver\fR is ``blkverify''" 4
.IX Item "The members of BlockdevOptionsBlkverify when driver is blkverify"
.ie n .IP "The members of ""BlockdevOptionsGenericFormat"" when ""driver"" is ""bochs""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericFormat\fR when \f(CWdriver\fR is ``bochs''" 4
.IX Item "The members of BlockdevOptionsGenericFormat when driver is bochs"
.ie n .IP "The members of ""BlockdevOptionsGenericFormat"" when ""driver"" is ""cloop""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericFormat\fR when \f(CWdriver\fR is ``cloop''" 4
.IX Item "The members of BlockdevOptionsGenericFormat when driver is cloop"
.ie n .IP "The members of ""BlockdevOptionsGenericFormat"" when ""driver"" is ""dmg""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericFormat\fR when \f(CWdriver\fR is ``dmg''" 4
.IX Item "The members of BlockdevOptionsGenericFormat when driver is dmg"
.ie n .IP "The members of ""BlockdevOptionsFile"" when ""driver"" is ""file""" 4
.el .IP "The members of \f(CWBlockdevOptionsFile\fR when \f(CWdriver\fR is ``file''" 4
.IX Item "The members of BlockdevOptionsFile when driver is file"
.ie n .IP "The members of ""BlockdevOptionsCurlFtp"" when ""driver"" is ""ftp""" 4
.el .IP "The members of \f(CWBlockdevOptionsCurlFtp\fR when \f(CWdriver\fR is ``ftp''" 4
.IX Item "The members of BlockdevOptionsCurlFtp when driver is ftp"
.ie n .IP "The members of ""BlockdevOptionsCurlFtps"" when ""driver"" is ""ftps""" 4
.el .IP "The members of \f(CWBlockdevOptionsCurlFtps\fR when \f(CWdriver\fR is ``ftps''" 4
.IX Item "The members of BlockdevOptionsCurlFtps when driver is ftps"
.ie n .IP "The members of ""BlockdevOptionsGluster"" when ""driver"" is ""gluster""" 4
.el .IP "The members of \f(CWBlockdevOptionsGluster\fR when \f(CWdriver\fR is ``gluster''" 4
.IX Item "The members of BlockdevOptionsGluster when driver is gluster"
.ie n .IP "The members of ""BlockdevOptionsFile"" when ""driver"" is ""host_cdrom""" 4
.el .IP "The members of \f(CWBlockdevOptionsFile\fR when \f(CWdriver\fR is ``host_cdrom''" 4
.IX Item "The members of BlockdevOptionsFile when driver is host_cdrom"
.ie n .IP "The members of ""BlockdevOptionsFile"" when ""driver"" is ""host_device""" 4
.el .IP "The members of \f(CWBlockdevOptionsFile\fR when \f(CWdriver\fR is ``host_device''" 4
.IX Item "The members of BlockdevOptionsFile when driver is host_device"
.ie n .IP "The members of ""BlockdevOptionsCurlHttp"" when ""driver"" is ""http""" 4
.el .IP "The members of \f(CWBlockdevOptionsCurlHttp\fR when \f(CWdriver\fR is ``http''" 4
.IX Item "The members of BlockdevOptionsCurlHttp when driver is http"
.ie n .IP "The members of ""BlockdevOptionsCurlHttps"" when ""driver"" is ""https""" 4
.el .IP "The members of \f(CWBlockdevOptionsCurlHttps\fR when \f(CWdriver\fR is ``https''" 4
.IX Item "The members of BlockdevOptionsCurlHttps when driver is https"
.ie n .IP "The members of ""BlockdevOptionsIscsi"" when ""driver"" is ""iscsi""" 4
.el .IP "The members of \f(CWBlockdevOptionsIscsi\fR when \f(CWdriver\fR is ``iscsi''" 4
.IX Item "The members of BlockdevOptionsIscsi when driver is iscsi"
.ie n .IP "The members of ""BlockdevOptionsLUKS"" when ""driver"" is ""luks""" 4
.el .IP "The members of \f(CWBlockdevOptionsLUKS\fR when \f(CWdriver\fR is ``luks''" 4
.IX Item "The members of BlockdevOptionsLUKS when driver is luks"
.ie n .IP "The members of ""BlockdevOptionsNbd"" when ""driver"" is ""nbd""" 4
.el .IP "The members of \f(CWBlockdevOptionsNbd\fR when \f(CWdriver\fR is ``nbd''" 4
.IX Item "The members of BlockdevOptionsNbd when driver is nbd"
.ie n .IP "The members of ""BlockdevOptionsNfs"" when ""driver"" is ""nfs""" 4
.el .IP "The members of \f(CWBlockdevOptionsNfs\fR when \f(CWdriver\fR is ``nfs''" 4
.IX Item "The members of BlockdevOptionsNfs when driver is nfs"
.ie n .IP "The members of ""BlockdevOptionsNull"" when ""driver"" is ""null-aio""" 4
.el .IP "The members of \f(CWBlockdevOptionsNull\fR when \f(CWdriver\fR is ``null-aio''" 4
.IX Item "The members of BlockdevOptionsNull when driver is null-aio"
.ie n .IP "The members of ""BlockdevOptionsNull"" when ""driver"" is ""null-co""" 4
.el .IP "The members of \f(CWBlockdevOptionsNull\fR when \f(CWdriver\fR is ``null-co''" 4
.IX Item "The members of BlockdevOptionsNull when driver is null-co"
.ie n .IP "The members of ""BlockdevOptionsGenericFormat"" when ""driver"" is ""parallels""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericFormat\fR when \f(CWdriver\fR is ``parallels''" 4
.IX Item "The members of BlockdevOptionsGenericFormat when driver is parallels"
.ie n .IP "The members of ""BlockdevOptionsQcow2"" when ""driver"" is ""qcow2""" 4
.el .IP "The members of \f(CWBlockdevOptionsQcow2\fR when \f(CWdriver\fR is ``qcow2''" 4
.IX Item "The members of BlockdevOptionsQcow2 when driver is qcow2"
.ie n .IP "The members of ""BlockdevOptionsQcow"" when ""driver"" is ""qcow""" 4
.el .IP "The members of \f(CWBlockdevOptionsQcow\fR when \f(CWdriver\fR is ``qcow''" 4
.IX Item "The members of BlockdevOptionsQcow when driver is qcow"
.ie n .IP "The members of ""BlockdevOptionsGenericCOWFormat"" when ""driver"" is ""qed""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericCOWFormat\fR when \f(CWdriver\fR is ``qed''" 4
.IX Item "The members of BlockdevOptionsGenericCOWFormat when driver is qed"
.ie n .IP "The members of ""BlockdevOptionsQuorum"" when ""driver"" is ""quorum""" 4
.el .IP "The members of \f(CWBlockdevOptionsQuorum\fR when \f(CWdriver\fR is ``quorum''" 4
.IX Item "The members of BlockdevOptionsQuorum when driver is quorum"
.ie n .IP "The members of ""BlockdevOptionsRaw"" when ""driver"" is ""raw""" 4
.el .IP "The members of \f(CWBlockdevOptionsRaw\fR when \f(CWdriver\fR is ``raw''" 4
.IX Item "The members of BlockdevOptionsRaw when driver is raw"
.ie n .IP "The members of ""BlockdevOptionsRbd"" when ""driver"" is ""rbd""" 4
.el .IP "The members of \f(CWBlockdevOptionsRbd\fR when \f(CWdriver\fR is ``rbd''" 4
.IX Item "The members of BlockdevOptionsRbd when driver is rbd"
.ie n .IP "The members of ""BlockdevOptionsReplication"" when ""driver"" is ""replication""" 4
.el .IP "The members of \f(CWBlockdevOptionsReplication\fR when \f(CWdriver\fR is ``replication''" 4
.IX Item "The members of BlockdevOptionsReplication when driver is replication"
.ie n .IP "The members of ""BlockdevOptionsSheepdog"" when ""driver"" is ""sheepdog""" 4
.el .IP "The members of \f(CWBlockdevOptionsSheepdog\fR when \f(CWdriver\fR is ``sheepdog''" 4
.IX Item "The members of BlockdevOptionsSheepdog when driver is sheepdog"
.ie n .IP "The members of ""BlockdevOptionsSsh"" when ""driver"" is ""ssh""" 4
.el .IP "The members of \f(CWBlockdevOptionsSsh\fR when \f(CWdriver\fR is ``ssh''" 4
.IX Item "The members of BlockdevOptionsSsh when driver is ssh"
.ie n .IP "The members of ""BlockdevOptionsGenericFormat"" when ""driver"" is ""vdi""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericFormat\fR when \f(CWdriver\fR is ``vdi''" 4
.IX Item "The members of BlockdevOptionsGenericFormat when driver is vdi"
.ie n .IP "The members of ""BlockdevOptionsGenericFormat"" when ""driver"" is ""vhdx""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericFormat\fR when \f(CWdriver\fR is ``vhdx''" 4
.IX Item "The members of BlockdevOptionsGenericFormat when driver is vhdx"
.ie n .IP "The members of ""BlockdevOptionsGenericCOWFormat"" when ""driver"" is ""vmdk""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericCOWFormat\fR when \f(CWdriver\fR is ``vmdk''" 4
.IX Item "The members of BlockdevOptionsGenericCOWFormat when driver is vmdk"
.ie n .IP "The members of ""BlockdevOptionsGenericFormat"" when ""driver"" is ""vpc""" 4
.el .IP "The members of \f(CWBlockdevOptionsGenericFormat\fR when \f(CWdriver\fR is ``vpc''" 4
.IX Item "The members of BlockdevOptionsGenericFormat when driver is vpc"
.ie n .IP "The members of ""BlockdevOptionsVVFAT"" when ""driver"" is ""vvfat""" 4
.el .IP "The members of \f(CWBlockdevOptionsVVFAT\fR when \f(CWdriver\fR is ``vvfat''" 4
.IX Item "The members of BlockdevOptionsVVFAT when driver is vvfat"
.ie n .IP "The members of ""BlockdevOptionsVxHS"" when ""driver"" is ""vxhs""" 4
.el .IP "The members of \f(CWBlockdevOptionsVxHS\fR when \f(CWdriver\fR is ``vxhs''" 4
.IX Item "The members of BlockdevOptionsVxHS when driver is vxhs"
.PD
.PP
Remaining options are determined by the block driver.
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevRef\fR (Alternate)
.PP
Reference to a block device.
.PP
\&\fBMembers:\fR
.ie n .IP """definition: BlockdevOptions""" 4
.el .IP "\f(CWdefinition: BlockdevOptions\fR" 4
.IX Item "definition: BlockdevOptions"
defines a new block device inline
.ie n .IP """reference: string""" 4
.el .IP "\f(CWreference: string\fR" 4
.IX Item "reference: string"
references the \s-1ID\s0 of an existing block device
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBBlockdevRefOrNull\fR (Alternate)
.PP
Reference to a block device.
.PP
\&\fBMembers:\fR
.ie n .IP """definition: BlockdevOptions""" 4
.el .IP "\f(CWdefinition: BlockdevOptions\fR" 4
.IX Item "definition: BlockdevOptions"
defines a new block device inline
.ie n .IP """reference: string""" 4
.el .IP "\f(CWreference: string\fR" 4
.IX Item "reference: string"
references the \s-1ID\s0 of an existing block device.
An empty string means that no block device should
be referenced.  Deprecated; use null instead.
.ie n .IP """null: null""" 4
.el .IP "\f(CWnull: null\fR" 4
.IX Item "null: null"
No block device should be referenced (since 2.10)
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBblockdev-add\fR  (Command)
Creates a new block device. If the \f(CW\*(C`id\*(C'\fR option is given at the top level, a
BlockBackend will be created; otherwise, \f(CW\*(C`node\-name\*(C'\fR is mandatory at the top
level and no BlockBackend will be created.
.PP
\&\fBArguments:\fR the members of \f(CW\*(C`BlockdevOptions\*(C'\fR
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBExample:\fR
.PP
.Vb 12
\&        1.
\&        \-> { "execute": "blockdev\-add",
\&             "arguments": {
\&                  "driver": "qcow2",
\&                  "node\-name": "test1",
\&                  "file": {
\&                      "driver": "file",
\&                      "filename": "test.qcow2"
\&                   }
\&              }
\&            }
\&        <\- { "return": {} }
\&        
\&        2.
\&        \-> { "execute": "blockdev\-add",
\&             "arguments": {
\&                  "driver": "qcow2",
\&                  "node\-name": "node0",
\&                  "discard": "unmap",
\&                  "cache": {
\&                     "direct": true
\&                   },
\&                   "file": {
\&                     "driver": "file",
\&                     "filename": "/tmp/test.qcow2"
\&                   },
\&                   "backing": {
\&                      "driver": "raw",
\&                      "file": {
\&                         "driver": "file",
\&                         "filename": "/dev/fdset/4"
\&                       }
\&                   }
\&               }
\&             }
\&        
\&        <\- { "return": {} }
.Ve
.PP
\&\fBblockdev-del\fR  (Command)
Deletes a block device that has been added using blockdev-add.
The command will fail if the node is attached to a device or is
otherwise being used.
.PP
\&\fBArguments:\fR
.ie n .IP """node\-name: string""" 4
.el .IP "\f(CWnode\-name: string\fR" 4
.IX Item "node-name: string"
Name of the graph node to delete.
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBExample:\fR
.PP
.Vb 11
\&        \-> { "execute": "blockdev\-add",
\&             "arguments": {
\&                  "driver": "qcow2",
\&                  "node\-name": "node0",
\&                  "file": {
\&                      "driver": "file",
\&                      "filename": "test.qcow2"
\&                  }
\&             }
\&           }
\&        <\- { "return": {} }
\&        
\&        \-> { "execute": "blockdev\-del",
\&             "arguments": { "node\-name": "node0" }
\&           }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBblockdev-open-tray\fR  (Command)
Opens a block device's tray. If there is a block driver state tree inserted as
a medium, it will become inaccessible to the guest (but it will remain
associated to the block device, so closing the tray will make it accessible
again).
.PP
If the tray was already open before, this will be a no-op.
.PP
Once the tray opens, a \s-1DEVICE_TRAY_MOVED\s0 event is emitted. There are cases in
which no such event will be generated, these include:
.IP "\-" 4
if the guest has locked the tray, \f(CW\*(C`force\*(C'\fR is false and the guest does not
respond to the eject request
.IP "\-" 4
if the BlockBackend denoted by \f(CW\*(C`device\*(C'\fR does not have a guest device attached
to it
.IP "\-" 4
if the guest device does not have an actual tray
.PP
\&\fBArguments:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
Block device name (deprecated, use \f(CW\*(C`id\*(C'\fR instead)
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
The name or \s-1QOM\s0 path of the guest device (since: 2.8)
.ie n .IP """force: boolean"" (optional)" 4
.el .IP "\f(CWforce: boolean\fR (optional)" 4
.IX Item "force: boolean (optional)"
if false (the default), an eject request will be sent to
the guest if it has locked the tray (and the tray will not be opened
immediately); if true, the tray will be opened regardless of whether
it is locked
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "blockdev\-open\-tray",
\&             "arguments": { "id": "ide0\-1\-0" } }
\&        
\&        <\- { "timestamp": { "seconds": 1418751016,
\&                            "microseconds": 716996 },
\&             "event": "DEVICE_TRAY_MOVED",
\&             "data": { "device": "ide1\-cd0",
\&                       "id": "ide0\-1\-0",
\&                       "tray\-open": true } }
\&        
\&        <\- { "return": {} }
.Ve
.PP
\&\fBblockdev-close-tray\fR  (Command)
Closes a block device's tray. If there is a block driver state tree associated
with the block device (which is currently ejected), that tree will be loaded
as the medium.
.PP
If the tray was already closed before, this will be a no-op.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
Block device name (deprecated, use \f(CW\*(C`id\*(C'\fR instead)
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
The name or \s-1QOM\s0 path of the guest device (since: 2.8)
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "blockdev\-close\-tray",
\&             "arguments": { "id": "ide0\-1\-0" } }
\&        
\&        <\- { "timestamp": { "seconds": 1418751345,
\&                            "microseconds": 272147 },
\&             "event": "DEVICE_TRAY_MOVED",
\&             "data": { "device": "ide1\-cd0",
\&                       "id": "ide0\-1\-0",
\&                       "tray\-open": false } }
\&        
\&        <\- { "return": {} }
.Ve
.PP
\&\fBx\-blockdev-remove-medium\fR  (Command)
Removes a medium (a block driver state tree) from a block device. That block
device's tray must currently be open (unless there is no attached guest
device).
.PP
If the tray is open and there is no medium inserted, this will be a no-op.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
Block device name (deprecated, use \f(CW\*(C`id\*(C'\fR instead)
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
The name or \s-1QOM\s0 path of the guest device (since: 2.8)
.PP
\&\fBNote:\fR
This command is still a work in progress and is considered experimental.
Stay away from it unless you want to help with its development.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "x\-blockdev\-remove\-medium",
\&             "arguments": { "id": "ide0\-1\-0" } }
\&        
\&        <\- { "error": { "class": "GenericError",
\&                        "desc": "Tray of device \*(Aqide0\-1\-0\*(Aq is not open" } }
\&        
\&        \-> { "execute": "blockdev\-open\-tray",
\&             "arguments": { "id": "ide0\-1\-0" } }
\&        
\&        <\- { "timestamp": { "seconds": 1418751627,
\&                            "microseconds": 549958 },
\&             "event": "DEVICE_TRAY_MOVED",
\&             "data": { "device": "ide1\-cd0",
\&                       "id": "ide0\-1\-0",
\&                       "tray\-open": true } }
\&        
\&        <\- { "return": {} }
\&        
\&        \-> { "execute": "x\-blockdev\-remove\-medium",
\&             "arguments": { "id": "ide0\-1\-0" } }
\&        
\&        <\- { "return": {} }
.Ve
.PP
\&\fBx\-blockdev-insert-medium\fR  (Command)
Inserts a medium (a block driver state tree) into a block device. That block
device's tray must currently be open (unless there is no attached guest
device) and there must be no medium inserted already.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
Block device name (deprecated, use \f(CW\*(C`id\*(C'\fR instead)
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
The name or \s-1QOM\s0 path of the guest device (since: 2.8)
.ie n .IP """node\-name: string""" 4
.el .IP "\f(CWnode\-name: string\fR" 4
.IX Item "node-name: string"
name of a node in the block driver state graph
.PP
\&\fBNote:\fR
This command is still a work in progress and is considered experimental.
Stay away from it unless you want to help with its development.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&        \-> { "execute": "blockdev\-add",
\&             "arguments": {
\&                 "node\-name": "node0",
\&                 "driver": "raw",
\&                 "file": { "driver": "file",
\&                           "filename": "fedora.iso" } } }
\&        <\- { "return": {} }
\&        
\&        \-> { "execute": "x\-blockdev\-insert\-medium",
\&             "arguments": { "id": "ide0\-1\-0",
\&                            "node\-name": "node0" } }
\&        
\&        <\- { "return": {} }
.Ve
.PP
\&\fBBlockdevChangeReadOnlyMode\fR (Enum)
.PP
Specifies the new read-only mode of a block device subject to the
\&\f(CW\*(C`blockdev\-change\-medium\*(C'\fR command.
.PP
\&\fBValues:\fR
.ie n .IP """retain""" 4
.el .IP "\f(CWretain\fR" 4
.IX Item "retain"
Retains the current read-only mode
.ie n .IP """read\-only""" 4
.el .IP "\f(CWread\-only\fR" 4
.IX Item "read-only"
Makes the device read-only
.ie n .IP """read\-write""" 4
.el .IP "\f(CWread\-write\fR" 4
.IX Item "read-write"
Makes the device writable
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBblockdev-change-medium\fR  (Command)
Changes the medium inserted into a block device by ejecting the current medium
and loading a new image file which is inserted as the new medium (this command
combines blockdev-open-tray, x\-blockdev-remove-medium,
x\-blockdev-insert-medium and blockdev-close-tray).
.PP
\&\fBArguments:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
Block device name (deprecated, use \f(CW\*(C`id\*(C'\fR instead)
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
The name or \s-1QOM\s0 path of the guest device
(since: 2.8)
.ie n .IP """filename: string""" 4
.el .IP "\f(CWfilename: string\fR" 4
.IX Item "filename: string"
filename of the new image to be loaded
.ie n .IP """format: string"" (optional)" 4
.el .IP "\f(CWformat: string\fR (optional)" 4
.IX Item "format: string (optional)"
format to open the new image with (defaults to
the probed format)
.ie n .IP """read\-only\-mode: BlockdevChangeReadOnlyMode"" (optional)" 4
.el .IP "\f(CWread\-only\-mode: BlockdevChangeReadOnlyMode\fR (optional)" 4
.IX Item "read-only-mode: BlockdevChangeReadOnlyMode (optional)"
change the read-only mode of the device; defaults
to 'retain'
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBExamples:\fR
.PP
.Vb 1
\&        1. Change a removable medium
\&        
\&        \-> { "execute": "blockdev\-change\-medium",
\&             "arguments": { "id": "ide0\-1\-0",
\&                            "filename": "/srv/images/Fedora\-12\-x86_64\-DVD.iso",
\&                            "format": "raw" } }
\&        <\- { "return": {} }
\&        
\&        2. Load a read\-only medium into a writable drive
\&        
\&        \-> { "execute": "blockdev\-change\-medium",
\&             "arguments": { "id": "floppyA",
\&                            "filename": "/srv/images/ro.img",
\&                            "format": "raw",
\&                            "read\-only\-mode": "retain" } }
\&        
\&        <\- { "error":
\&             { "class": "GenericError",
\&               "desc": "Could not open \*(Aq/srv/images/ro.img\*(Aq: Permission denied" } }
\&        
\&        \-> { "execute": "blockdev\-change\-medium",
\&             "arguments": { "id": "floppyA",
\&                            "filename": "/srv/images/ro.img",
\&                            "format": "raw",
\&                            "read\-only\-mode": "read\-only" } }
\&        
\&        <\- { "return": {} }
.Ve
.PP
\&\fBBlockErrorAction\fR (Enum)
.PP
An enumeration of action that has been taken when a \s-1DISK I/O\s0 occurs
.PP
\&\fBValues:\fR
.ie n .IP """ignore""" 4
.el .IP "\f(CWignore\fR" 4
.IX Item "ignore"
error has been ignored
.ie n .IP """report""" 4
.el .IP "\f(CWreport\fR" 4
.IX Item "report"
error has been reported to the device
.ie n .IP """stop""" 4
.el .IP "\f(CWstop\fR" 4
.IX Item "stop"
error caused \s-1VM\s0 to be stopped
.PP
\&\fBSince:\fR
2.1
.PP
\&\fB\s-1BLOCK_IMAGE_CORRUPTED\s0\fR  (Event)
Emitted when a disk image is being marked corrupt. The image can be
identified by its device or node name. The 'device' field is always
present for compatibility reasons, but it can be empty ("") if the
image does not have a device name associated.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
device name. This is always present for compatibility
reasons, but it can be empty ("") if the image does not
have a device name associated.
.ie n .IP """node\-name: string"" (optional)" 4
.el .IP "\f(CWnode\-name: string\fR (optional)" 4
.IX Item "node-name: string (optional)"
node name (Since: 2.4)
.ie n .IP """msg: string""" 4
.el .IP "\f(CWmsg: string\fR" 4
.IX Item "msg: string"
informative message for human consumption, such as the kind of
corruption being detected. It should not be parsed by machine as it is
not guaranteed to be stable
.ie n .IP """offset: int"" (optional)" 4
.el .IP "\f(CWoffset: int\fR (optional)" 4
.IX Item "offset: int (optional)"
if the corruption resulted from an image access, this is
the host's access offset into the image
.ie n .IP """size: int"" (optional)" 4
.el .IP "\f(CWsize: int\fR (optional)" 4
.IX Item "size: int (optional)"
if the corruption resulted from an image access, this is
the access size
.ie n .IP """fatal: boolean""" 4
.el .IP "\f(CWfatal: boolean\fR" 4
.IX Item "fatal: boolean"
if set, the image is marked corrupt and therefore unusable after this
event and must be repaired (Since 2.2; before, every
\&\s-1BLOCK_IMAGE_CORRUPTED\s0 event was fatal)
.PP
\&\fBNote:\fR
If action is \*(L"stop\*(R", a \s-1STOP\s0 event will eventually follow the
\&\s-1BLOCK_IO_ERROR\s0 event.
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        <\- { "event": "BLOCK_IMAGE_CORRUPTED",
\&             "data": { "device": "ide0\-hd0", "node\-name": "node0",
\&                       "msg": "Prevented active L1 table overwrite", "offset": 196608,
\&                       "size": 65536 },
\&             "timestamp": { "seconds": 1378126126, "microseconds": 966463 } }
.Ve
.PP
\&\fBSince:\fR
1.7
.PP
\&\fB\s-1BLOCK_IO_ERROR\s0\fR  (Event)
Emitted when a disk I/O error occurs
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
device name. This is always present for compatibility
reasons, but it can be empty ("") if the image does not
have a device name associated.
.ie n .IP """node\-name: string""" 4
.el .IP "\f(CWnode\-name: string\fR" 4
.IX Item "node-name: string"
node name. Note that errors may be reported for the root node
that is directly attached to a guest device rather than for the
node where the error occurred. (Since: 2.8)
.ie n .IP """operation: IoOperationType""" 4
.el .IP "\f(CWoperation: IoOperationType\fR" 4
.IX Item "operation: IoOperationType"
I/O operation
.ie n .IP """action: BlockErrorAction""" 4
.el .IP "\f(CWaction: BlockErrorAction\fR" 4
.IX Item "action: BlockErrorAction"
action that has been taken
.ie n .IP """nospace: boolean"" (optional)" 4
.el .IP "\f(CWnospace: boolean\fR (optional)" 4
.IX Item "nospace: boolean (optional)"
true if I/O error was caused due to a no-space
condition. This key is only present if query-block's
io-status is present, please see query-block documentation
for more information (since: 2.2)
.ie n .IP """reason: string""" 4
.el .IP "\f(CWreason: string\fR" 4
.IX Item "reason: string"
human readable string describing the error cause.
(This field is a debugging aid for humans, it should not
be parsed by applications) (since: 2.2)
.PP
\&\fBNote:\fR
If action is \*(L"stop\*(R", a \s-1STOP\s0 event will eventually follow the
\&\s-1BLOCK_IO_ERROR\s0 event
.PP
\&\fBSince:\fR
0.13.0
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&        <\- { "event": "BLOCK_IO_ERROR",
\&             "data": { "device": "ide0\-hd1",
\&                       "node\-name": "#block212",
\&                       "operation": "write",
\&                       "action": "stop" },
\&             "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
.Ve
.PP
\&\fB\s-1BLOCK_JOB_COMPLETED\s0\fR  (Event)
Emitted when a block job has completed
.PP
\&\fBArguments:\fR
.ie n .IP """type: BlockJobType""" 4
.el .IP "\f(CWtype: BlockJobType\fR" 4
.IX Item "type: BlockJobType"
job type
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The job identifier. Originally the device name but other
values are allowed since \s-1QEMU 2.7\s0
.ie n .IP """len: int""" 4
.el .IP "\f(CWlen: int\fR" 4
.IX Item "len: int"
maximum progress value
.ie n .IP """offset: int""" 4
.el .IP "\f(CWoffset: int\fR" 4
.IX Item "offset: int"
current progress value. On success this is equal to len.
On failure this is less than len
.ie n .IP """speed: int""" 4
.el .IP "\f(CWspeed: int\fR" 4
.IX Item "speed: int"
rate limit, bytes per second
.ie n .IP """error: string"" (optional)" 4
.el .IP "\f(CWerror: string\fR (optional)" 4
.IX Item "error: string (optional)"
error message. Only present on failure. This field
contains a human-readable error message. There are no semantics
other than that streaming has failed and clients should not try to
interpret the error string
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        <\- { "event": "BLOCK_JOB_COMPLETED",
\&             "data": { "type": "stream", "device": "virtio\-disk0",
\&                       "len": 10737418240, "offset": 10737418240,
\&                       "speed": 0 },
\&             "timestamp": { "seconds": 1267061043, "microseconds": 959568 } }
.Ve
.PP
\&\fB\s-1BLOCK_JOB_CANCELLED\s0\fR  (Event)
Emitted when a block job has been cancelled
.PP
\&\fBArguments:\fR
.ie n .IP """type: BlockJobType""" 4
.el .IP "\f(CWtype: BlockJobType\fR" 4
.IX Item "type: BlockJobType"
job type
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The job identifier. Originally the device name but other
values are allowed since \s-1QEMU 2.7\s0
.ie n .IP """len: int""" 4
.el .IP "\f(CWlen: int\fR" 4
.IX Item "len: int"
maximum progress value
.ie n .IP """offset: int""" 4
.el .IP "\f(CWoffset: int\fR" 4
.IX Item "offset: int"
current progress value. On success this is equal to len.
On failure this is less than len
.ie n .IP """speed: int""" 4
.el .IP "\f(CWspeed: int\fR" 4
.IX Item "speed: int"
rate limit, bytes per second
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        <\- { "event": "BLOCK_JOB_CANCELLED",
\&             "data": { "type": "stream", "device": "virtio\-disk0",
\&                       "len": 10737418240, "offset": 134217728,
\&                       "speed": 0 },
\&             "timestamp": { "seconds": 1267061043, "microseconds": 959568 } }
.Ve
.PP
\&\fB\s-1BLOCK_JOB_ERROR\s0\fR  (Event)
Emitted when a block job encounters an error
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The job identifier. Originally the device name but other
values are allowed since \s-1QEMU 2.7\s0
.ie n .IP """operation: IoOperationType""" 4
.el .IP "\f(CWoperation: IoOperationType\fR" 4
.IX Item "operation: IoOperationType"
I/O operation
.ie n .IP """action: BlockErrorAction""" 4
.el .IP "\f(CWaction: BlockErrorAction\fR" 4
.IX Item "action: BlockErrorAction"
action that has been taken
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        <\- { "event": "BLOCK_JOB_ERROR",
\&             "data": { "device": "ide0\-hd1",
\&                       "operation": "write",
\&                       "action": "stop" },
\&             "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
.Ve
.PP
\&\fB\s-1BLOCK_JOB_READY\s0\fR  (Event)
Emitted when a block job is ready to complete
.PP
\&\fBArguments:\fR
.ie n .IP """type: BlockJobType""" 4
.el .IP "\f(CWtype: BlockJobType\fR" 4
.IX Item "type: BlockJobType"
job type
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The job identifier. Originally the device name but other
values are allowed since \s-1QEMU 2.7\s0
.ie n .IP """len: int""" 4
.el .IP "\f(CWlen: int\fR" 4
.IX Item "len: int"
maximum progress value
.ie n .IP """offset: int""" 4
.el .IP "\f(CWoffset: int\fR" 4
.IX Item "offset: int"
current progress value. On success this is equal to len.
On failure this is less than len
.ie n .IP """speed: int""" 4
.el .IP "\f(CWspeed: int\fR" 4
.IX Item "speed: int"
rate limit, bytes per second
.PP
\&\fBNote:\fR
The \*(L"ready to complete\*(R" status is always reset by a \f(CW\*(C`BLOCK_JOB_ERROR\*(C'\fR
event
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&        <\- { "event": "BLOCK_JOB_READY",
\&             "data": { "device": "drive0", "type": "mirror", "speed": 0,
\&                       "len": 2097152, "offset": 2097152 }
\&             "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
.Ve
.PP
\&\fBPreallocMode\fR (Enum)
.PP
Preallocation mode of \s-1QEMU\s0 image file
.PP
\&\fBValues:\fR
.ie n .IP """off""" 4
.el .IP "\f(CWoff\fR" 4
.IX Item "off"
no preallocation
.ie n .IP """metadata""" 4
.el .IP "\f(CWmetadata\fR" 4
.IX Item "metadata"
preallocate only for metadata
.ie n .IP """falloc""" 4
.el .IP "\f(CWfalloc\fR" 4
.IX Item "falloc"
like \f(CW\*(C`full\*(C'\fR preallocation but allocate disk space by
\&\fIposix_fallocate()\fR rather than writing zeros.
.ie n .IP """full""" 4
.el .IP "\f(CWfull\fR" 4
.IX Item "full"
preallocate all data by writing zeros to device to ensure disk
space is really available. \f(CW\*(C`full\*(C'\fR preallocation also sets up
metadata correctly.
.PP
\&\fBSince:\fR
2.2
.PP
\&\fB\s-1BLOCK_WRITE_THRESHOLD\s0\fR  (Event)
Emitted when writes on block device reaches or exceeds the
configured write threshold. For thin-provisioned devices, this
means the device should be extended to avoid pausing for
disk exhaustion.
The event is one shot. Once triggered, it needs to be
re-registered with another block-set-write-threshold command.
.PP
\&\fBArguments:\fR
.ie n .IP """node\-name: string""" 4
.el .IP "\f(CWnode\-name: string\fR" 4
.IX Item "node-name: string"
graph node name on which the threshold was exceeded.
.ie n .IP """amount\-exceeded: int""" 4
.el .IP "\f(CWamount\-exceeded: int\fR" 4
.IX Item "amount-exceeded: int"
amount of data which exceeded the threshold, in bytes.
.ie n .IP """write\-threshold: int""" 4
.el .IP "\f(CWwrite\-threshold: int\fR" 4
.IX Item "write-threshold: int"
last configured threshold, in bytes.
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBblock-set-write-threshold\fR  (Command)
Change the write threshold for a block drive. An event will be
delivered if a write to this block drive crosses the configured
threshold.  The threshold is an offset, thus must be
non-negative. Default is no write threshold. Setting the threshold
to zero disables it.
.PP
This is useful to transparently resize thin-provisioned drives without
the guest \s-1OS\s0 noticing.
.PP
\&\fBArguments:\fR
.ie n .IP """node\-name: string""" 4
.el .IP "\f(CWnode\-name: string\fR" 4
.IX Item "node-name: string"
graph node name on which the threshold must be set.
.ie n .IP """write\-threshold: int""" 4
.el .IP "\f(CWwrite\-threshold: int\fR" 4
.IX Item "write-threshold: int"
configured threshold for the block device, bytes.
Use 0 to disable the threshold.
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&        \-> { "execute": "block\-set\-write\-threshold",
\&             "arguments": { "node\-name": "mydev",
\&                            "write\-threshold": 17179869184 } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBx\-blockdev-change\fR  (Command)
Dynamically reconfigure the block driver state graph. It can be used
to add, remove, insert or replace a graph node. Currently only the
Quorum driver implements this feature to add or remove its child. This
is useful to fix a broken quorum child.
.PP
If \f(CW\*(C`node\*(C'\fR is specified, it will be inserted under \f(CW\*(C`parent\*(C'\fR. \f(CW\*(C`child\*(C'\fR
may not be specified in this case. If both \f(CW\*(C`parent\*(C'\fR and \f(CW\*(C`child\*(C'\fR are
specified but \f(CW\*(C`node\*(C'\fR is not, \f(CW\*(C`child\*(C'\fR will be detached from \f(CW\*(C`parent\*(C'\fR.
.PP
\&\fBArguments:\fR
.ie n .IP """parent: string""" 4
.el .IP "\f(CWparent: string\fR" 4
.IX Item "parent: string"
the id or name of the parent node.
.ie n .IP """child: string"" (optional)" 4
.el .IP "\f(CWchild: string\fR (optional)" 4
.IX Item "child: string (optional)"
the name of a child under the given parent node.
.ie n .IP """node: string"" (optional)" 4
.el .IP "\f(CWnode: string\fR (optional)" 4
.IX Item "node: string (optional)"
the name of the node that will be added.
.PP
\&\fBNote:\fR
this command is experimental, and its \s-1API\s0 is not stable. It
does not support all kinds of operations, all kinds of children, nor
all block drivers.
.PP
Warning: The data in a new quorum child \s-1MUST\s0 be consistent with that of
the rest of the array.
.PP
\&\fBSince:\fR
2.7
.PP
\&\fBExample:\fR
.PP
.Vb 12
\&        1. Add a new node to a quorum
\&        \-> { "execute": "blockdev\-add",
\&             "arguments": {
\&                 "driver": "raw",
\&                 "node\-name": "new_node",
\&                 "file": { "driver": "file",
\&                           "filename": "test.raw" } } }
\&        <\- { "return": {} }
\&        \-> { "execute": "x\-blockdev\-change",
\&             "arguments": { "parent": "disk1",
\&                            "node": "new_node" } }
\&        <\- { "return": {} }
\&        
\&        2. Delete a quorum\*(Aqs node
\&        \-> { "execute": "x\-blockdev\-change",
\&             "arguments": { "parent": "disk1",
\&                            "child": "children.1" } }
\&        <\- { "return": {} }
.Ve
.PP
\fI\s-1QAPI\s0 block definitions (vm unrelated)\fR
.IX Subsection "QAPI block definitions (vm unrelated)"
.PP
\&\fBBiosAtaTranslation\fR (Enum)
.PP
Policy that \s-1BIOS\s0 should use to interpret cylinder/head/sector
addresses.  Note that Bochs \s-1BIOS\s0 and SeaBIOS will not actually
translate logical \s-1CHS\s0 to physical; instead, they will use logical
block addressing.
.PP
\&\fBValues:\fR
.ie n .IP """auto""" 4
.el .IP "\f(CWauto\fR" 4
.IX Item "auto"
If cylinder/heads/sizes are passed, choose between none and \s-1LBA\s0
depending on the size of the disk.  If they are not passed,
choose none if \s-1QEMU\s0 can guess that the disk had 16 or fewer
heads, large if \s-1QEMU\s0 can guess that the disk had 131072 or
fewer tracks across all heads (i.e. cylinders*heads<131072),
otherwise \s-1LBA.\s0
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
The physical disk geometry is equal to the logical geometry.
.ie n .IP """lba""" 4
.el .IP "\f(CWlba\fR" 4
.IX Item "lba"
Assume 63 sectors per track and one of 16, 32, 64, 128 or 255
heads (if fewer than 255 are enough to cover the whole disk
with 1024 cylinders/head).  The number of cylinders/head is
then computed based on the number of sectors and heads.
.ie n .IP """large""" 4
.el .IP "\f(CWlarge\fR" 4
.IX Item "large"
The number of cylinders per head is scaled down to 1024
by correspondingly scaling up the number of heads.
.ie n .IP """rechs""" 4
.el .IP "\f(CWrechs\fR" 4
.IX Item "rechs"
Same as \f(CW\*(C`large\*(C'\fR, but first convert a 16\-head geometry to
15\-head, by proportionally scaling up the number of
cylinders/head.
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBFloppyDriveType\fR (Enum)
.PP
Type of Floppy drive to be emulated by the Floppy Disk Controller.
.PP
\&\fBValues:\fR
.ie n .IP "144" 4
.el .IP "\f(CW144\fR" 4
.IX Item "144"
1.44MB 3.5" drive
.ie n .IP "288" 4
.el .IP "\f(CW288\fR" 4
.IX Item "288"
2.88MB 3.5" drive
.ie n .IP "120" 4
.el .IP "\f(CW120\fR" 4
.IX Item "120"
1.2MB 5.25" drive
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
No drive connected
.ie n .IP """auto""" 4
.el .IP "\f(CWauto\fR" 4
.IX Item "auto"
Automatically determined by inserted media at boot
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBBlockdevSnapshotInternal\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
the device name or node-name of a root node to generate the snapshot
from
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
the name of the internal snapshot to be created
.PP
\&\fBNotes:\fR
In transaction, if \f(CW\*(C`name\*(C'\fR is empty, or any snapshot matching \f(CW\*(C`name\*(C'\fR
exists, the operation will fail. Only some image formats support it,
for example, qcow2, rbd, and sheepdog.
.PP
\&\fBSince:\fR
1.7
.PP
\&\fBblockdev-snapshot-internal-sync\fR  (Command)
Synchronously take an internal snapshot of a block device, when the
format of the image used supports it. If the name is an empty
string, or a snapshot with name already exists, the operation will
fail.
.PP
For the arguments, see the documentation of BlockdevSnapshotInternal.
.PP
\&\fBReturns:\fR
nothing on success
.PP
If \f(CW\*(C`device\*(C'\fR is not a valid block device, GenericError
.PP
If any snapshot matching \f(CW\*(C`name\*(C'\fR exists, or \f(CW\*(C`name\*(C'\fR is empty,
GenericError
.PP
If the format of the image used does not support it,
BlockFormatFeatureNotSupported
.PP
\&\fBSince:\fR
1.7
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "blockdev\-snapshot\-internal\-sync",
\&             "arguments": { "device": "ide\-hd0",
\&                            "name": "snapshot0" }
\&           }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBblockdev-snapshot-delete-internal-sync\fR  (Command)
Synchronously delete an internal snapshot of a block device, when the format
of the image used support it. The snapshot is identified by name or id or
both. One of the name or id is required. Return SnapshotInfo for the
successfully deleted snapshot.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
the device name or node-name of a root node to delete the snapshot
from
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
optional the snapshot's \s-1ID\s0 to be deleted
.ie n .IP """name: string"" (optional)" 4
.el .IP "\f(CWname: string\fR (optional)" 4
.IX Item "name: string (optional)"
optional the snapshot's name to be deleted
.PP
\&\fBReturns:\fR
SnapshotInfo on success
If \f(CW\*(C`device\*(C'\fR is not a valid block device, GenericError
If snapshot not found, GenericError
If the format of the image used does not support it,
BlockFormatFeatureNotSupported
If \f(CW\*(C`id\*(C'\fR and \f(CW\*(C`name\*(C'\fR are both not specified, GenericError
.PP
\&\fBSince:\fR
1.7
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "blockdev\-snapshot\-delete\-internal\-sync",
\&             "arguments": { "device": "ide\-hd0",
\&                            "name": "snapshot0" }
\&           }
\&        <\- { "return": {
\&                           "id": "1",
\&                           "name": "snapshot0",
\&                           "vm\-state\-size": 0,
\&                           "date\-sec": 1000012,
\&                           "date\-nsec": 10,
\&                           "vm\-clock\-sec": 100,
\&                           "vm\-clock\-nsec": 20
\&             }
\&           }
.Ve
.PP
\&\fBeject\fR  (Command)
Ejects a device from a removable drive.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
Block device name (deprecated, use \f(CW\*(C`id\*(C'\fR instead)
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
The name or \s-1QOM\s0 path of the guest device (since: 2.8)
.ie n .IP """force: boolean"" (optional)" 4
.el .IP "\f(CWforce: boolean\fR (optional)" 4
.IX Item "force: boolean (optional)"
If true, eject regardless of whether the drive is locked.
If not specified, the default value is false.
.PP
\&\fBReturns:\fR
Nothing on success
.PP
If \f(CW\*(C`device\*(C'\fR is not a valid block device, DeviceNotFound
.PP
\&\fBNotes:\fR
Ejecting a device with no media results in success
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "eject", "arguments": { "id": "ide1\-0\-1" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBnbd-server-start\fR  (Command)
Start an \s-1NBD\s0 server listening on the given host and port.  Block
devices can then be exported using \f(CW\*(C`nbd\-server\-add\*(C'\fR.  The \s-1NBD\s0
server will present them as named exports; for example, another
\&\s-1QEMU\s0 instance could refer to them as \*(L"nbd:HOST:PORT:exportname=NAME\*(R".
.PP
\&\fBArguments:\fR
.ie n .IP """addr: SocketAddressLegacy""" 4
.el .IP "\f(CWaddr: SocketAddressLegacy\fR" 4
.IX Item "addr: SocketAddressLegacy"
Address on which to listen.
.ie n .IP """tls\-creds: string"" (optional)" 4
.el .IP "\f(CWtls\-creds: string\fR (optional)" 4
.IX Item "tls-creds: string (optional)"
(optional) \s-1ID\s0 of the \s-1TLS\s0 credentials object. Since 2.6
.PP
\&\fBReturns:\fR
error if the server is already running.
.PP
\&\fBSince:\fR
1.3.0
.PP
\&\fBnbd-server-add\fR  (Command)
Export a block node to \s-1QEMU\s0's embedded \s-1NBD\s0 server.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The device name or node name of the node to be exported
.ie n .IP """writable: boolean"" (optional)" 4
.el .IP "\f(CWwritable: boolean\fR (optional)" 4
.IX Item "writable: boolean (optional)"
Whether clients should be able to write to the device via the
\&\s-1NBD\s0 connection (default false).
.PP
\&\fBReturns:\fR
error if the device is already marked for export.
.PP
\&\fBSince:\fR
1.3.0
.PP
\&\fBnbd-server-stop\fR  (Command)
Stop \s-1QEMU\s0's embedded \s-1NBD\s0 server, and unregister all devices previously
added via \f(CW\*(C`nbd\-server\-add\*(C'\fR.
.PP
\&\fBSince:\fR
1.3.0
.PP
\&\fB\s-1DEVICE_TRAY_MOVED\s0\fR  (Event)
Emitted whenever the tray of a removable device is moved by the guest or by
\&\s-1HMP/QMP\s0 commands
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
Block device name. This is always present for compatibility
reasons, but it can be empty ("") if the image does not
have a device name associated.
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
The name or \s-1QOM\s0 path of the guest device (since 2.8)
.ie n .IP """tray\-open: boolean""" 4
.el .IP "\f(CWtray\-open: boolean\fR" 4
.IX Item "tray-open: boolean"
true if the tray has been opened or false if it has been closed
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&        <\- { "event": "DEVICE_TRAY_MOVED",
\&             "data": { "device": "ide1\-cd0",
\&                       "id": "/machine/unattached/device[22]",
\&                       "tray\-open": true
\&             },
\&             "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
.Ve
.PP
\&\fBQuorumOpType\fR (Enum)
.PP
An enumeration of the quorum operation types
.PP
\&\fBValues:\fR
.ie n .IP """read""" 4
.el .IP "\f(CWread\fR" 4
.IX Item "read"
read operation
.ie n .IP """write""" 4
.el .IP "\f(CWwrite\fR" 4
.IX Item "write"
write operation
.ie n .IP """flush""" 4
.el .IP "\f(CWflush\fR" 4
.IX Item "flush"
flush operation
.PP
\&\fBSince:\fR
2.6
.SS "Other events"
.IX Subsection "Other events"
\&\fB\s-1SHUTDOWN\s0\fR  (Event)
Emitted when the virtual machine has shut down, indicating that qemu is
about to exit.
.PP
\&\fBArguments:\fR
.ie n .IP """guest: boolean""" 4
.el .IP "\f(CWguest: boolean\fR" 4
.IX Item "guest: boolean"
If true, the shutdown was triggered by a guest request (such as
a guest-initiated \s-1ACPI\s0 shutdown request or other hardware-specific action)
rather than a host request (such as sending qemu a \s-1SIGINT\s0). (since 2.10)
.PP
\&\fBNote:\fR
If the command-line option \*(L"\-no\-shutdown\*(R" has been specified, qemu will
not exit, and a \s-1STOP\s0 event will eventually follow the \s-1SHUTDOWN\s0 event
.PP
\&\fBSince:\fR
0.12.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        <\- { "event": "SHUTDOWN", "data": { "guest": true },
\&             "timestamp": { "seconds": 1267040730, "microseconds": 682951 } }
.Ve
.PP
\&\fB\s-1POWERDOWN\s0\fR  (Event)
Emitted when the virtual machine is powered down through the power control
system, such as via \s-1ACPI.\s0
.PP
\&\fBSince:\fR
0.12.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        <\- { "event": "POWERDOWN",
\&             "timestamp": { "seconds": 1267040730, "microseconds": 682951 } }
.Ve
.PP
\&\fB\s-1RESET\s0\fR  (Event)
Emitted when the virtual machine is reset
.PP
\&\fBArguments:\fR
.ie n .IP """guest: boolean""" 4
.el .IP "\f(CWguest: boolean\fR" 4
.IX Item "guest: boolean"
If true, the reset was triggered by a guest request (such as
a guest-initiated \s-1ACPI\s0 reboot request or other hardware-specific action)
rather than a host request (such as the \s-1QMP\s0 command system_reset).
(since 2.10)
.PP
\&\fBSince:\fR
0.12.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        <\- { "event": "RESET", "data": { "guest": false },
\&             "timestamp": { "seconds": 1267041653, "microseconds": 9518 } }
.Ve
.PP
\&\fB\s-1STOP\s0\fR  (Event)
Emitted when the virtual machine is stopped
.PP
\&\fBSince:\fR
0.12.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        <\- { "event": "STOP",
\&             "timestamp": { "seconds": 1267041730, "microseconds": 281295 } }
.Ve
.PP
\&\fB\s-1RESUME\s0\fR  (Event)
Emitted when the virtual machine resumes execution
.PP
\&\fBSince:\fR
0.12.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        <\- { "event": "RESUME",
\&             "timestamp": { "seconds": 1271770767, "microseconds": 582542 } }
.Ve
.PP
\&\fB\s-1SUSPEND\s0\fR  (Event)
Emitted when guest enters a hardware suspension state, for example, S3 state,
which is sometimes called standby state
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        <\- { "event": "SUSPEND",
\&             "timestamp": { "seconds": 1344456160, "microseconds": 309119 } }
.Ve
.PP
\&\fB\s-1SUSPEND_DISK\s0\fR  (Event)
Emitted when guest enters a hardware suspension state with data saved on
disk, for example, S4 state, which is sometimes called hibernate state
.PP
\&\fBNote:\fR
\&\s-1QEMU\s0 shuts down (similar to event \f(CW\*(C`SHUTDOWN\*(C'\fR) when entering this state
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        <\-   { "event": "SUSPEND_DISK",
\&               "timestamp": { "seconds": 1344456160, "microseconds": 309119 } }
.Ve
.PP
\&\fB\s-1WAKEUP\s0\fR  (Event)
Emitted when the guest has woken up from suspend state and is running
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        <\- { "event": "WAKEUP",
\&             "timestamp": { "seconds": 1344522075, "microseconds": 745528 } }
.Ve
.PP
\&\fB\s-1RTC_CHANGE\s0\fR  (Event)
Emitted when the guest changes the \s-1RTC\s0 time.
.PP
\&\fBArguments:\fR
.ie n .IP """offset: int""" 4
.el .IP "\f(CWoffset: int\fR" 4
.IX Item "offset: int"
offset between base \s-1RTC\s0 clock (as specified by \-rtc base), and
new \s-1RTC\s0 clock value
.PP
\&\fBNote:\fR
This event is rate-limited.
.PP
\&\fBSince:\fR
0.13.0
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        <\-   { "event": "RTC_CHANGE",
\&               "data": { "offset": 78 },
\&               "timestamp": { "seconds": 1267020223, "microseconds": 435656 } }
.Ve
.PP
\&\fB\s-1WATCHDOG\s0\fR  (Event)
Emitted when the watchdog device's timer is expired
.PP
\&\fBArguments:\fR
.ie n .IP """action: WatchdogExpirationAction""" 4
.el .IP "\f(CWaction: WatchdogExpirationAction\fR" 4
.IX Item "action: WatchdogExpirationAction"
action that has been taken
.PP
\&\fBNote:\fR
If action is \*(L"reset\*(R", \*(L"shutdown\*(R", or \*(L"pause\*(R" the \s-1WATCHDOG\s0 event is
followed respectively by the \s-1RESET, SHUTDOWN,\s0 or \s-1STOP\s0 events
.PP
\&\fBNote:\fR
This event is rate-limited.
.PP
\&\fBSince:\fR
0.13.0
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        <\- { "event": "WATCHDOG",
\&             "data": { "action": "reset" },
\&             "timestamp": { "seconds": 1267061043, "microseconds": 959568 } }
.Ve
.PP
\&\fB\s-1DEVICE_DELETED\s0\fR  (Event)
Emitted whenever the device removal completion is acknowledged by the guest.
At this point, it's safe to reuse the specified device \s-1ID.\s0 Device removal can
be initiated by the guest or by \s-1HMP/QMP\s0 commands.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
device name
.ie n .IP """path: string""" 4
.el .IP "\f(CWpath: string\fR" 4
.IX Item "path: string"
device path
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&        <\- { "event": "DEVICE_DELETED",
\&             "data": { "device": "virtio\-net\-pci\-0",
\&                       "path": "/machine/peripheral/virtio\-net\-pci\-0" },
\&             "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
.Ve
.PP
\&\fB\s-1NIC_RX_FILTER_CHANGED\s0\fR  (Event)
Emitted once until the 'query\-rx\-filter' command is executed, the first event
will always be emitted
.PP
\&\fBArguments:\fR
.ie n .IP """name: string"" (optional)" 4
.el .IP "\f(CWname: string\fR (optional)" 4
.IX Item "name: string (optional)"
net client name
.ie n .IP """path: string""" 4
.el .IP "\f(CWpath: string\fR" 4
.IX Item "path: string"
device path
.PP
\&\fBSince:\fR
1.6
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        <\- { "event": "NIC_RX_FILTER_CHANGED",
\&             "data": { "name": "vnet0",
\&                       "path": "/machine/peripheral/vnet0/virtio\-backend" },
\&             "timestamp": { "seconds": 1368697518, "microseconds": 326866 } }
\&           }
.Ve
.PP
\&\fB\s-1VNC_CONNECTED\s0\fR  (Event)
Emitted when a \s-1VNC\s0 client establishes a connection
.PP
\&\fBArguments:\fR
.ie n .IP """server: VncServerInfo""" 4
.el .IP "\f(CWserver: VncServerInfo\fR" 4
.IX Item "server: VncServerInfo"
server information
.ie n .IP """client: VncBasicInfo""" 4
.el .IP "\f(CWclient: VncBasicInfo\fR" 4
.IX Item "client: VncBasicInfo"
client information
.PP
\&\fBNote:\fR
This event is emitted before any authentication takes place, thus
the authentication \s-1ID\s0 is not provided
.PP
\&\fBSince:\fR
0.13.0
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&        <\- { "event": "VNC_CONNECTED",
\&             "data": {
\&                   "server": { "auth": "sasl", "family": "ipv4",
\&                               "service": "5901", "host": "0.0.0.0" },
\&                   "client": { "family": "ipv4", "service": "58425",
\&                               "host": "127.0.0.1" } },
\&             "timestamp": { "seconds": 1262976601, "microseconds": 975795 } }
.Ve
.PP
\&\fB\s-1VNC_INITIALIZED\s0\fR  (Event)
Emitted after authentication takes place (if any) and the \s-1VNC\s0 session is
made active
.PP
\&\fBArguments:\fR
.ie n .IP """server: VncServerInfo""" 4
.el .IP "\f(CWserver: VncServerInfo\fR" 4
.IX Item "server: VncServerInfo"
server information
.ie n .IP """client: VncClientInfo""" 4
.el .IP "\f(CWclient: VncClientInfo\fR" 4
.IX Item "client: VncClientInfo"
client information
.PP
\&\fBSince:\fR
0.13.0
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&        <\-  { "event": "VNC_INITIALIZED",
\&              "data": {
\&                   "server": { "auth": "sasl", "family": "ipv4",
\&                               "service": "5901", "host": "0.0.0.0"},
\&                   "client": { "family": "ipv4", "service": "46089",
\&                               "host": "127.0.0.1", "sasl_username": "luiz" } },
\&              "timestamp": { "seconds": 1263475302, "microseconds": 150772 } }
.Ve
.PP
\&\fB\s-1VNC_DISCONNECTED\s0\fR  (Event)
Emitted when the connection is closed
.PP
\&\fBArguments:\fR
.ie n .IP """server: VncServerInfo""" 4
.el .IP "\f(CWserver: VncServerInfo\fR" 4
.IX Item "server: VncServerInfo"
server information
.ie n .IP """client: VncClientInfo""" 4
.el .IP "\f(CWclient: VncClientInfo\fR" 4
.IX Item "client: VncClientInfo"
client information
.PP
\&\fBSince:\fR
0.13.0
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&        <\- { "event": "VNC_DISCONNECTED",
\&             "data": {
\&                   "server": { "auth": "sasl", "family": "ipv4",
\&                               "service": "5901", "host": "0.0.0.0" },
\&                   "client": { "family": "ipv4", "service": "58425",
\&                               "host": "127.0.0.1", "sasl_username": "luiz" } },
\&             "timestamp": { "seconds": 1262976601, "microseconds": 975795 } }
.Ve
.PP
\&\fB\s-1SPICE_CONNECTED\s0\fR  (Event)
Emitted when a \s-1SPICE\s0 client establishes a connection
.PP
\&\fBArguments:\fR
.ie n .IP """server: SpiceBasicInfo""" 4
.el .IP "\f(CWserver: SpiceBasicInfo\fR" 4
.IX Item "server: SpiceBasicInfo"
server information
.ie n .IP """client: SpiceBasicInfo""" 4
.el .IP "\f(CWclient: SpiceBasicInfo\fR" 4
.IX Item "client: SpiceBasicInfo"
client information
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&        <\- { "timestamp": {"seconds": 1290688046, "microseconds": 388707},
\&             "event": "SPICE_CONNECTED",
\&             "data": {
\&               "server": { "port": "5920", "family": "ipv4", "host": "127.0.0.1"},
\&               "client": {"port": "52873", "family": "ipv4", "host": "127.0.0.1"}
\&           }}
.Ve
.PP
\&\fB\s-1SPICE_INITIALIZED\s0\fR  (Event)
Emitted after initial handshake and authentication takes place (if any)
and the \s-1SPICE\s0 channel is up and running
.PP
\&\fBArguments:\fR
.ie n .IP """server: SpiceServerInfo""" 4
.el .IP "\f(CWserver: SpiceServerInfo\fR" 4
.IX Item "server: SpiceServerInfo"
server information
.ie n .IP """client: SpiceChannel""" 4
.el .IP "\f(CWclient: SpiceChannel\fR" 4
.IX Item "client: SpiceChannel"
client information
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 8
\&        <\- { "timestamp": {"seconds": 1290688046, "microseconds": 417172},
\&             "event": "SPICE_INITIALIZED",
\&             "data": {"server": {"auth": "spice", "port": "5921",
\&                                 "family": "ipv4", "host": "127.0.0.1"},
\&                      "client": {"port": "49004", "family": "ipv4", "channel\-type": 3,
\&                                 "connection\-id": 1804289383, "host": "127.0.0.1",
\&                                 "channel\-id": 0, "tls": true}
\&           }}
.Ve
.PP
\&\fB\s-1SPICE_DISCONNECTED\s0\fR  (Event)
Emitted when the \s-1SPICE\s0 connection is closed
.PP
\&\fBArguments:\fR
.ie n .IP """server: SpiceBasicInfo""" 4
.el .IP "\f(CWserver: SpiceBasicInfo\fR" 4
.IX Item "server: SpiceBasicInfo"
server information
.ie n .IP """client: SpiceBasicInfo""" 4
.el .IP "\f(CWclient: SpiceBasicInfo\fR" 4
.IX Item "client: SpiceBasicInfo"
client information
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&        <\- { "timestamp": {"seconds": 1290688046, "microseconds": 388707},
\&             "event": "SPICE_DISCONNECTED",
\&             "data": {
\&               "server": { "port": "5920", "family": "ipv4", "host": "127.0.0.1"},
\&               "client": {"port": "52873", "family": "ipv4", "host": "127.0.0.1"}
\&           }}
.Ve
.PP
\&\fB\s-1SPICE_MIGRATE_COMPLETED\s0\fR  (Event)
Emitted when \s-1SPICE\s0 migration has completed
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        <\- { "timestamp": {"seconds": 1290688046, "microseconds": 417172},
\&             "event": "SPICE_MIGRATE_COMPLETED" }
.Ve
.PP
\&\fB\s-1MIGRATION\s0\fR  (Event)
Emitted when a migration event happens
.PP
\&\fBArguments:\fR
.ie n .IP """status: MigrationStatus""" 4
.el .IP "\f(CWstatus: MigrationStatus\fR" 4
.IX Item "status: MigrationStatus"
\&\f(CW\*(C`MigrationStatus\*(C'\fR describing the current migration status.
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        <\- {"timestamp": {"seconds": 1432121972, "microseconds": 744001},
\&            "event": "MIGRATION",
\&            "data": {"status": "completed"} }
.Ve
.PP
\&\fB\s-1MIGRATION_PASS\s0\fR  (Event)
Emitted from the source side of a migration at the start of each pass
(when it syncs the dirty bitmap)
.PP
\&\fBArguments:\fR
.ie n .IP """pass: int""" 4
.el .IP "\f(CWpass: int\fR" 4
.IX Item "pass: int"
An incrementing count (starting at 1 on the first pass)
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        { "timestamp": {"seconds": 1449669631, "microseconds": 239225},
\&          "event": "MIGRATION_PASS", "data": {"pass": 2} }
.Ve
.PP
\&\fB\s-1ACPI_DEVICE_OST\s0\fR  (Event)
Emitted when guest executes \s-1ACPI _OST\s0 method.
.PP
\&\fBArguments:\fR
.ie n .IP """info: ACPIOSTInfo""" 4
.el .IP "\f(CWinfo: ACPIOSTInfo\fR" 4
.IX Item "info: ACPIOSTInfo"
ACPIOSTInfo type as described in qapi\-schema.json
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        <\- { "event": "ACPI_DEVICE_OST",
\&             "data": { "device": "d1", "slot": "0",
\&                       "slot\-type": "DIMM", "source": 1, "status": 0 } }
.Ve
.PP
\&\fB\s-1BALLOON_CHANGE\s0\fR  (Event)
Emitted when the guest changes the actual \s-1BALLOON\s0 level. This value is
equivalent to the \f(CW\*(C`actual\*(C'\fR field return by the 'query\-balloon' command
.PP
\&\fBArguments:\fR
.ie n .IP """actual: int""" 4
.el .IP "\f(CWactual: int\fR" 4
.IX Item "actual: int"
actual level of the guest memory balloon in bytes
.PP
\&\fBNote:\fR
this event is rate-limited.
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        <\- { "event": "BALLOON_CHANGE",
\&             "data": { "actual": 944766976 },
\&             "timestamp": { "seconds": 1267020223, "microseconds": 435656 } }
.Ve
.PP
\&\fB\s-1GUEST_PANICKED\s0\fR  (Event)
Emitted when guest \s-1OS\s0 panic is detected
.PP
\&\fBArguments:\fR
.ie n .IP """action: GuestPanicAction""" 4
.el .IP "\f(CWaction: GuestPanicAction\fR" 4
.IX Item "action: GuestPanicAction"
action that has been taken, currently always \*(L"pause\*(R"
.ie n .IP """info: GuestPanicInformation"" (optional)" 4
.el .IP "\f(CWinfo: GuestPanicInformation\fR (optional)" 4
.IX Item "info: GuestPanicInformation (optional)"
information about a panic (since 2.9)
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        <\- { "event": "GUEST_PANICKED",
\&             "data": { "action": "pause" } }
.Ve
.PP
\&\fB\s-1QUORUM_FAILURE\s0\fR  (Event)
Emitted by the Quorum block driver if it fails to establish a quorum
.PP
\&\fBArguments:\fR
.ie n .IP """reference: string""" 4
.el .IP "\f(CWreference: string\fR" 4
.IX Item "reference: string"
device name if defined else node name
.ie n .IP """sector\-num: int""" 4
.el .IP "\f(CWsector\-num: int\fR" 4
.IX Item "sector-num: int"
number of the first sector of the failed read operation
.ie n .IP """sectors\-count: int""" 4
.el .IP "\f(CWsectors\-count: int\fR" 4
.IX Item "sectors-count: int"
failed read operation sector count
.PP
\&\fBNote:\fR
This event is rate-limited.
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        <\- { "event": "QUORUM_FAILURE",
\&             "data": { "reference": "usr1", "sector\-num": 345435, "sectors\-count": 5 },
\&             "timestamp": { "seconds": 1344522075, "microseconds": 745528 } }
.Ve
.PP
\&\fB\s-1QUORUM_REPORT_BAD\s0\fR  (Event)
Emitted to report a corruption of a Quorum file
.PP
\&\fBArguments:\fR
.ie n .IP """type: QuorumOpType""" 4
.el .IP "\f(CWtype: QuorumOpType\fR" 4
.IX Item "type: QuorumOpType"
quorum operation type (Since 2.6)
.ie n .IP """error: string"" (optional)" 4
.el .IP "\f(CWerror: string\fR (optional)" 4
.IX Item "error: string (optional)"
error message. Only present on failure. This field
contains a human-readable error message. There are no semantics other
than that the block layer reported an error and clients should not
try to interpret the error string.
.ie n .IP """node\-name: string""" 4
.el .IP "\f(CWnode\-name: string\fR" 4
.IX Item "node-name: string"
the graph node name of the block driver state
.ie n .IP """sector\-num: int""" 4
.el .IP "\f(CWsector\-num: int\fR" 4
.IX Item "sector-num: int"
number of the first sector of the failed read operation
.ie n .IP """sectors\-count: int""" 4
.el .IP "\f(CWsectors\-count: int\fR" 4
.IX Item "sectors-count: int"
failed read operation sector count
.PP
\&\fBNote:\fR
This event is rate-limited.
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&        1. Read operation
\&        
\&        { "event": "QUORUM_REPORT_BAD",
\&             "data": { "node\-name": "node0", "sector\-num": 345435, "sectors\-count": 5,
\&                       "type": "read" },
\&             "timestamp": { "seconds": 1344522075, "microseconds": 745528 } }
\&        
\&        2. Flush operation
\&        
\&        { "event": "QUORUM_REPORT_BAD",
\&             "data": { "node\-name": "node0", "sector\-num": 0, "sectors\-count": 2097120,
\&                       "type": "flush", "error": "Broken pipe" },
\&             "timestamp": { "seconds": 1456406829, "microseconds": 291763 } }
.Ve
.PP
\&\fB\s-1VSERPORT_CHANGE\s0\fR  (Event)
Emitted when the guest opens or closes a virtio-serial port.
.PP
\&\fBArguments:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
device identifier of the virtio-serial port
.ie n .IP """open: boolean""" 4
.el .IP "\f(CWopen: boolean\fR" 4
.IX Item "open: boolean"
true if the guest has opened the virtio-serial port
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        <\- { "event": "VSERPORT_CHANGE",
\&             "data": { "id": "channel0", "open": true },
\&             "timestamp": { "seconds": 1401385907, "microseconds": 422329 } }
.Ve
.PP
\&\fB\s-1MEM_UNPLUG_ERROR\s0\fR  (Event)
Emitted when memory hot unplug error occurs.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
device name
.ie n .IP """msg: string""" 4
.el .IP "\f(CWmsg: string\fR" 4
.IX Item "msg: string"
Informative message
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        <\- { "event": "MEM_UNPLUG_ERROR"
\&             "data": { "device": "dimm1",
\&                       "msg": "acpi: device unplug for unsupported device"
\&             },
\&             "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
.Ve
.PP
\&\fB\s-1DUMP_COMPLETED\s0\fR  (Event)
Emitted when background dump has completed
.PP
\&\fBArguments:\fR
.ie n .IP """result: DumpQueryResult""" 4
.el .IP "\f(CWresult: DumpQueryResult\fR" 4
.IX Item "result: DumpQueryResult"
DumpQueryResult type described in qapi\-schema.json.
.ie n .IP """error: string"" (optional)" 4
.el .IP "\f(CWerror: string\fR (optional)" 4
.IX Item "error: string (optional)"
human-readable error string that provides
hint on why dump failed. Only presents on failure. The
user should not try to interpret the error string.
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        { "event": "DUMP_COMPLETED",
\&          "data": {"result": {"total": 1090650112, "status": "completed",
\&                              "completed": 1090650112} } }
.Ve
.SS "Tracing commands"
.IX Subsection "Tracing commands"
\&\fBTraceEventState\fR (Enum)
.PP
State of a tracing event.
.PP
\&\fBValues:\fR
.ie n .IP """unavailable""" 4
.el .IP "\f(CWunavailable\fR" 4
.IX Item "unavailable"
The event is statically disabled.
.ie n .IP """disabled""" 4
.el .IP "\f(CWdisabled\fR" 4
.IX Item "disabled"
The event is dynamically disabled.
.ie n .IP """enabled""" 4
.el .IP "\f(CWenabled\fR" 4
.IX Item "enabled"
The event is dynamically enabled.
.PP
\&\fBSince:\fR
2.2
.PP
\&\fBTraceEventInfo\fR (Object)
.PP
Information of a tracing event.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
Event name.
.ie n .IP """state: TraceEventState""" 4
.el .IP "\f(CWstate: TraceEventState\fR" 4
.IX Item "state: TraceEventState"
Tracing state.
.ie n .IP """vcpu: boolean""" 4
.el .IP "\f(CWvcpu: boolean\fR" 4
.IX Item "vcpu: boolean"
Whether this is a per-vCPU event (since 2.7).
.PP
An event is per-vCPU if it has the \*(L"vcpu\*(R" property in the \*(L"trace-events\*(R"
files.
.PP
\&\fBSince:\fR
2.2
.PP
\&\fBtrace-event-get-state\fR  (Command)
Query the state of events.
.PP
\&\fBArguments:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
Event name pattern (case-sensitive glob).
.ie n .IP """vcpu: int"" (optional)" 4
.el .IP "\f(CWvcpu: int\fR (optional)" 4
.IX Item "vcpu: int (optional)"
The vCPU to query (any by default; since 2.7).
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`TraceEventInfo\*(C'\fR for the matching events
.PP
An event is returned if:
.IP "\-" 4
its name matches the \f(CW\*(C`name\*(C'\fR pattern, and
.IP "\-" 4
if \f(CW\*(C`vcpu\*(C'\fR is given, the event has the \*(L"vcpu\*(R" property.
.PP
Therefore, if \f(CW\*(C`vcpu\*(C'\fR is given, the operation will only match per-vCPU events,
returning their state on the specified vCPU. Special case: if \f(CW\*(C`name\*(C'\fR is an
exact match, \f(CW\*(C`vcpu\*(C'\fR is given and the event does not have the \*(L"vcpu\*(R" property,
an error is returned.
.PP
\&\fBSince:\fR
2.2
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "trace\-event\-get\-state",
\&             "arguments": { "name": "qemu_memalign" } }
\&        <\- { "return": [ { "name": "qemu_memalign", "state": "disabled" } ] }
.Ve
.PP
\&\fBtrace-event-set-state\fR  (Command)
Set the dynamic tracing state of events.
.PP
\&\fBArguments:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
Event name pattern (case-sensitive glob).
.ie n .IP """enable: boolean""" 4
.el .IP "\f(CWenable: boolean\fR" 4
.IX Item "enable: boolean"
Whether to enable tracing.
.ie n .IP """ignore\-unavailable: boolean"" (optional)" 4
.el .IP "\f(CWignore\-unavailable: boolean\fR (optional)" 4
.IX Item "ignore-unavailable: boolean (optional)"
Do not match unavailable events with \f(CW\*(C`name\*(C'\fR.
.ie n .IP """vcpu: int"" (optional)" 4
.el .IP "\f(CWvcpu: int\fR (optional)" 4
.IX Item "vcpu: int (optional)"
The vCPU to act upon (all by default; since 2.7).
.PP
An event's state is modified if:
.IP "\-" 4
its name matches the \f(CW\*(C`name\*(C'\fR pattern, and
.IP "\-" 4
if \f(CW\*(C`vcpu\*(C'\fR is given, the event has the \*(L"vcpu\*(R" property.
.PP
Therefore, if \f(CW\*(C`vcpu\*(C'\fR is given, the operation will only match per-vCPU events,
setting their state on the specified vCPU. Special case: if \f(CW\*(C`name\*(C'\fR is an exact
match, \f(CW\*(C`vcpu\*(C'\fR is given and the event does not have the \*(L"vcpu\*(R" property, an
error is returned.
.PP
\&\fBSince:\fR
2.2
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "trace\-event\-set\-state",
\&             "arguments": { "name": "qemu_memalign", "enable": "true" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBquery-qmp-schema\fR  (Command)
Command query-qmp-schema exposes the \s-1QMP\s0 wire \s-1ABI\s0 as an array of
SchemaInfo.  This lets \s-1QMP\s0 clients figure out what commands and
events are available in this \s-1QEMU,\s0 and their parameters and results.
.PP
However, the SchemaInfo can't reflect all the rules and restrictions
that apply to \s-1QMP. \s0 It's interface introspection (figuring out
what's there), not interface specification.  The specification is in
the \s-1QAPI\s0 schema.
.PP
Furthermore, while we strive to keep the \s-1QMP\s0 wire format
backwards-compatible across qemu versions, the introspection output
is not guaranteed to have the same stability.  For example, one
version of qemu may list an object member as an optional
non-variant, while another lists the same member only through the
object's variants; or the type of a member may change from a generic
string into a specific enum or from one specific type into an
alternate that includes the original type alongside something else.
.PP
\&\fBReturns:\fR
array of \f(CW\*(C`SchemaInfo\*(C'\fR, where each element describes an
entity in the \s-1ABI:\s0 command, event, type, ...
.PP
The order of the various SchemaInfo is unspecified; however, all
names are guaranteed to be unique (no name will be duplicated with
different meta-types).
.PP
\&\fBNote:\fR
the \s-1QAPI\s0 schema is also used to help define \fBinternal\fR
interfaces, by defining \s-1QAPI\s0 types.  These are not part of the \s-1QMP\s0
wire \s-1ABI,\s0 and therefore not returned by this command.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaMetaType\fR (Enum)
.PP
This is a \f(CW\*(C`SchemaInfo\*(C'\fR's meta type, i.e. the kind of entity it
describes.
.PP
\&\fBValues:\fR
.ie n .IP """builtin""" 4
.el .IP "\f(CWbuiltin\fR" 4
.IX Item "builtin"
a predefined type such as 'int' or 'bool'.
.ie n .IP """enum""" 4
.el .IP "\f(CWenum\fR" 4
.IX Item "enum"
an enumeration type
.ie n .IP """array""" 4
.el .IP "\f(CWarray\fR" 4
.IX Item "array"
an array type
.ie n .IP """object""" 4
.el .IP "\f(CWobject\fR" 4
.IX Item "object"
an object type (struct or union)
.ie n .IP """alternate""" 4
.el .IP "\f(CWalternate\fR" 4
.IX Item "alternate"
an alternate type
.ie n .IP """command""" 4
.el .IP "\f(CWcommand\fR" 4
.IX Item "command"
a \s-1QMP\s0 command
.ie n .IP """event""" 4
.el .IP "\f(CWevent\fR" 4
.IX Item "event"
a \s-1QMP\s0 event
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaInfo\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
the entity's name, inherited from \f(CW\*(C`base\*(C'\fR.
The SchemaInfo is always referenced by this name.
Commands and events have the name defined in the \s-1QAPI\s0 schema.
Unlike command and event names, type names are not part of
the wire \s-1ABI. \s0 Consequently, type names are meaningless
strings here, although they are still guaranteed unique
regardless of \f(CW\*(C`meta\-type\*(C'\fR.
.ie n .IP """meta\-type: SchemaMetaType""" 4
.el .IP "\f(CWmeta\-type: SchemaMetaType\fR" 4
.IX Item "meta-type: SchemaMetaType"
the entity's meta type, inherited from \f(CW\*(C`base\*(C'\fR.
.ie n .IP "The members of ""SchemaInfoBuiltin"" when ""meta\-type"" is ""builtin""" 4
.el .IP "The members of \f(CWSchemaInfoBuiltin\fR when \f(CWmeta\-type\fR is ``builtin''" 4
.IX Item "The members of SchemaInfoBuiltin when meta-type is builtin"
.PD 0
.ie n .IP "The members of ""SchemaInfoEnum"" when ""meta\-type"" is ""enum""" 4
.el .IP "The members of \f(CWSchemaInfoEnum\fR when \f(CWmeta\-type\fR is ``enum''" 4
.IX Item "The members of SchemaInfoEnum when meta-type is enum"
.ie n .IP "The members of ""SchemaInfoArray"" when ""meta\-type"" is ""array""" 4
.el .IP "The members of \f(CWSchemaInfoArray\fR when \f(CWmeta\-type\fR is ``array''" 4
.IX Item "The members of SchemaInfoArray when meta-type is array"
.ie n .IP "The members of ""SchemaInfoObject"" when ""meta\-type"" is ""object""" 4
.el .IP "The members of \f(CWSchemaInfoObject\fR when \f(CWmeta\-type\fR is ``object''" 4
.IX Item "The members of SchemaInfoObject when meta-type is object"
.ie n .IP "The members of ""SchemaInfoAlternate"" when ""meta\-type"" is ""alternate""" 4
.el .IP "The members of \f(CWSchemaInfoAlternate\fR when \f(CWmeta\-type\fR is ``alternate''" 4
.IX Item "The members of SchemaInfoAlternate when meta-type is alternate"
.ie n .IP "The members of ""SchemaInfoCommand"" when ""meta\-type"" is ""command""" 4
.el .IP "The members of \f(CWSchemaInfoCommand\fR when \f(CWmeta\-type\fR is ``command''" 4
.IX Item "The members of SchemaInfoCommand when meta-type is command"
.ie n .IP "The members of ""SchemaInfoEvent"" when ""meta\-type"" is ""event""" 4
.el .IP "The members of \f(CWSchemaInfoEvent\fR when \f(CWmeta\-type\fR is ``event''" 4
.IX Item "The members of SchemaInfoEvent when meta-type is event"
.PD
.PP
Additional members depend on the value of \f(CW\*(C`meta\-type\*(C'\fR.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaInfoBuiltin\fR (Object)
.PP
Additional SchemaInfo members for meta-type 'builtin'.
.PP
\&\fBMembers:\fR
.ie n .IP """json\-type: JSONType""" 4
.el .IP "\f(CWjson\-type: JSONType\fR" 4
.IX Item "json-type: JSONType"
the \s-1JSON\s0 type used for this type on the wire.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBJSONType\fR (Enum)
.PP
The four primitive and two structured types according to \s-1RFC 7159\s0
section 1, plus 'int' (split off 'number'), plus the obvious top
type 'value'.
.PP
\&\fBValues:\fR
.ie n .IP """string""" 4
.el .IP "\f(CWstring\fR" 4
.IX Item "string"
Not documented
.ie n .IP """number""" 4
.el .IP "\f(CWnumber\fR" 4
.IX Item "number"
Not documented
.ie n .IP """int""" 4
.el .IP "\f(CWint\fR" 4
.IX Item "int"
Not documented
.ie n .IP """boolean""" 4
.el .IP "\f(CWboolean\fR" 4
.IX Item "boolean"
Not documented
.ie n .IP """null""" 4
.el .IP "\f(CWnull\fR" 4
.IX Item "null"
Not documented
.ie n .IP """object""" 4
.el .IP "\f(CWobject\fR" 4
.IX Item "object"
Not documented
.ie n .IP """array""" 4
.el .IP "\f(CWarray\fR" 4
.IX Item "array"
Not documented
.ie n .IP """value""" 4
.el .IP "\f(CWvalue\fR" 4
.IX Item "value"
Not documented
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaInfoEnum\fR (Object)
.PP
Additional SchemaInfo members for meta-type 'enum'.
.PP
\&\fBMembers:\fR
.ie n .IP """values: array of string""" 4
.el .IP "\f(CWvalues: array of string\fR" 4
.IX Item "values: array of string"
the enumeration type's values, in no particular order.
.PP
Values of this type are \s-1JSON\s0 string on the wire.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaInfoArray\fR (Object)
.PP
Additional SchemaInfo members for meta-type 'array'.
.PP
\&\fBMembers:\fR
.ie n .IP """element\-type: string""" 4
.el .IP "\f(CWelement\-type: string\fR" 4
.IX Item "element-type: string"
the array type's element type.
.PP
Values of this type are \s-1JSON\s0 array on the wire.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaInfoObject\fR (Object)
.PP
Additional SchemaInfo members for meta-type 'object'.
.PP
\&\fBMembers:\fR
.ie n .IP """members: array of SchemaInfoObjectMember""" 4
.el .IP "\f(CWmembers: array of SchemaInfoObjectMember\fR" 4
.IX Item "members: array of SchemaInfoObjectMember"
the object type's (non-variant) members, in no particular order.
.ie n .IP """tag: string"" (optional)" 4
.el .IP "\f(CWtag: string\fR (optional)" 4
.IX Item "tag: string (optional)"
the name of the member serving as type tag.
An element of \f(CW\*(C`members\*(C'\fR with this name must exist.
.ie n .IP """variants: array of SchemaInfoObjectVariant"" (optional)" 4
.el .IP "\f(CWvariants: array of SchemaInfoObjectVariant\fR (optional)" 4
.IX Item "variants: array of SchemaInfoObjectVariant (optional)"
variant members, i.e. additional members that
depend on the type tag's value.  Present exactly when
\&\f(CW\*(C`tag\*(C'\fR is present.  The variants are in no particular order,
and may even differ from the order of the values of the
enum type of the \f(CW\*(C`tag\*(C'\fR.
.PP
Values of this type are \s-1JSON\s0 object on the wire.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaInfoObjectMember\fR (Object)
.PP
An object member.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
the member's name, as defined in the \s-1QAPI\s0 schema.
.ie n .IP """type: string""" 4
.el .IP "\f(CWtype: string\fR" 4
.IX Item "type: string"
the name of the member's type.
.ie n .IP """default: value"" (optional)" 4
.el .IP "\f(CWdefault: value\fR (optional)" 4
.IX Item "default: value (optional)"
default when used as command parameter.
If absent, the parameter is mandatory.
If present, the value must be null.  The parameter is
optional, and behavior when it's missing is not specified
here.
Future extension: if present and non-null, the parameter
is optional, and defaults to this value.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaInfoObjectVariant\fR (Object)
.PP
The variant members for a value of the type tag.
.PP
\&\fBMembers:\fR
.ie n .IP """case: string""" 4
.el .IP "\f(CWcase: string\fR" 4
.IX Item "case: string"
a value of the type tag.
.ie n .IP """type: string""" 4
.el .IP "\f(CWtype: string\fR" 4
.IX Item "type: string"
the name of the object type that provides the variant members
when the type tag has value \f(CW\*(C`case\*(C'\fR.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaInfoAlternate\fR (Object)
.PP
Additional SchemaInfo members for meta-type 'alternate'.
.PP
\&\fBMembers:\fR
.ie n .IP """members: array of SchemaInfoAlternateMember""" 4
.el .IP "\f(CWmembers: array of SchemaInfoAlternateMember\fR" 4
.IX Item "members: array of SchemaInfoAlternateMember"
the alternate type's members, in no particular order.
The members' wire encoding is distinct, see
docs/devel/qapi\-code\-gen.txt section Alternate types.
.PP
On the wire, this can be any of the members.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaInfoAlternateMember\fR (Object)
.PP
An alternate member.
.PP
\&\fBMembers:\fR
.ie n .IP """type: string""" 4
.el .IP "\f(CWtype: string\fR" 4
.IX Item "type: string"
the name of the member's type.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaInfoCommand\fR (Object)
.PP
Additional SchemaInfo members for meta-type 'command'.
.PP
\&\fBMembers:\fR
.ie n .IP """arg\-type: string""" 4
.el .IP "\f(CWarg\-type: string\fR" 4
.IX Item "arg-type: string"
the name of the object type that provides the command's
parameters.
.ie n .IP """ret\-type: string""" 4
.el .IP "\f(CWret\-type: string\fR" 4
.IX Item "ret-type: string"
the name of the command's result type.
.PP
\&\fB\s-1TODO:\s0\fR
\&\f(CW\*(C`success\-response\*(C'\fR (currently irrelevant, because it's \s-1QGA,\s0 not \s-1QMP\s0)
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBSchemaInfoEvent\fR (Object)
.PP
Additional SchemaInfo members for meta-type 'event'.
.PP
\&\fBMembers:\fR
.ie n .IP """arg\-type: string""" 4
.el .IP "\f(CWarg\-type: string\fR" 4
.IX Item "arg-type: string"
the name of the object type that provides the event's
parameters.
.PP
\&\fBSince:\fR
2.5
.SS "\s-1QMP\s0 commands"
.IX Subsection "QMP commands"
\&\fBqmp_capabilities\fR  (Command)
Enable \s-1QMP\s0 capabilities.
.PP
Arguments: None.
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "qmp_capabilities" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBNotes:\fR
This command is valid exactly when first connecting: it must be
issued before any other command will be accepted, and will fail once the
monitor is accepting other commands. (see qemu docs/interop/qmp\-spec.txt)
.PP
\&\fBSince:\fR
0.13
.PP
\&\fBStrOrNull\fR (Alternate)
.PP
This is a string value or the explicit lack of a string (null
pointer in C).  Intended for cases when 'optional absent' already
has a different meaning.
.PP
\&\fBMembers:\fR
.ie n .IP """s: string""" 4
.el .IP "\f(CWs: string\fR" 4
.IX Item "s: string"
the string value
.ie n .IP """n: null""" 4
.el .IP "\f(CWn: null\fR" 4
.IX Item "n: null"
no string value
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBLostTickPolicy\fR (Enum)
.PP
Policy for handling lost ticks in timer devices.
.PP
\&\fBValues:\fR
.ie n .IP """discard""" 4
.el .IP "\f(CWdiscard\fR" 4
.IX Item "discard"
throw away the missed tick(s) and continue with future injection
normally.  Guest time may be delayed, unless the \s-1OS\s0 has explicit
handling of lost ticks
.ie n .IP """delay""" 4
.el .IP "\f(CWdelay\fR" 4
.IX Item "delay"
continue to deliver ticks at the normal rate.  Guest time will be
delayed due to the late tick
.ie n .IP """merge""" 4
.el .IP "\f(CWmerge\fR" 4
.IX Item "merge"
merge the missed tick(s) into one tick and inject.  Guest time
may be delayed, depending on how the \s-1OS\s0 reacts to the merging
of ticks
.ie n .IP """slew""" 4
.el .IP "\f(CWslew\fR" 4
.IX Item "slew"
deliver ticks at a higher rate to catch up with the missed tick. The
guest time should not be delayed once catchup is complete.
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBadd_client\fR  (Command)
Allow client connections for \s-1VNC,\s0 Spice and socket based
character devices to be passed in to \s-1QEMU\s0 via \s-1SCM_RIGHTS.\s0
.PP
\&\fBArguments:\fR
.ie n .IP """protocol: string""" 4
.el .IP "\f(CWprotocol: string\fR" 4
.IX Item "protocol: string"
protocol name. Valid names are \*(L"vnc\*(R", \*(L"spice\*(R" or the
name of a character device (eg. from \-chardev id=XXXX)
.ie n .IP """fdname: string""" 4
.el .IP "\f(CWfdname: string\fR" 4
.IX Item "fdname: string"
file descriptor name previously passed via 'getfd' command
.ie n .IP """skipauth: boolean"" (optional)" 4
.el .IP "\f(CWskipauth: boolean\fR (optional)" 4
.IX Item "skipauth: boolean (optional)"
whether to skip authentication. Only applies
to \*(L"vnc\*(R" and \*(L"spice\*(R" protocols
.ie n .IP """tls: boolean"" (optional)" 4
.el .IP "\f(CWtls: boolean\fR (optional)" 4
.IX Item "tls: boolean (optional)"
whether to perform \s-1TLS.\s0 Only applies to the \*(L"spice\*(R"
protocol
.PP
\&\fBReturns:\fR
nothing on success.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "add_client", "arguments": { "protocol": "vnc",
\&                                                     "fdname": "myclient" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBNameInfo\fR (Object)
.PP
Guest name information.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string"" (optional)" 4
.el .IP "\f(CWname: string\fR (optional)" 4
.IX Item "name: string (optional)"
The name of the guest
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBquery-name\fR  (Command)
Return the name information of a guest.
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`NameInfo\*(C'\fR of the guest
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "query\-name" }
\&        <\- { "return": { "name": "qemu\-name" } }
.Ve
.PP
\&\fBKvmInfo\fR (Object)
.PP
Information about support for \s-1KVM\s0 acceleration
.PP
\&\fBMembers:\fR
.ie n .IP """enabled: boolean""" 4
.el .IP "\f(CWenabled: boolean\fR" 4
.IX Item "enabled: boolean"
true if \s-1KVM\s0 acceleration is active
.ie n .IP """present: boolean""" 4
.el .IP "\f(CWpresent: boolean\fR" 4
.IX Item "present: boolean"
true if \s-1KVM\s0 acceleration is built into this executable
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBquery-kvm\fR  (Command)
Returns information about \s-1KVM\s0 acceleration
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`KvmInfo\*(C'\fR
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "query\-kvm" }
\&        <\- { "return": { "enabled": true, "present": true } }
.Ve
.PP
\&\fBRunState\fR (Enum)
.PP
An enumeration of \s-1VM\s0 run states.
.PP
\&\fBValues:\fR
.ie n .IP """debug""" 4
.el .IP "\f(CWdebug\fR" 4
.IX Item "debug"
\&\s-1QEMU\s0 is running on a debugger
.ie n .IP """finish\-migrate""" 4
.el .IP "\f(CWfinish\-migrate\fR" 4
.IX Item "finish-migrate"
guest is paused to finish the migration process
.ie n .IP """inmigrate""" 4
.el .IP "\f(CWinmigrate\fR" 4
.IX Item "inmigrate"
guest is paused waiting for an incoming migration.  Note
that this state does not tell whether the machine will start at the
end of the migration.  This depends on the command-line \-S option and
any invocation of 'stop' or 'cont' that has happened since \s-1QEMU\s0 was
started.
.ie n .IP """internal\-error""" 4
.el .IP "\f(CWinternal\-error\fR" 4
.IX Item "internal-error"
An internal error that prevents further guest execution
has occurred
.ie n .IP """io\-error""" 4
.el .IP "\f(CWio\-error\fR" 4
.IX Item "io-error"
the last \s-1IOP\s0 has failed and the device is configured to pause
on I/O errors
.ie n .IP """paused""" 4
.el .IP "\f(CWpaused\fR" 4
.IX Item "paused"
guest has been paused via the 'stop' command
.ie n .IP """postmigrate""" 4
.el .IP "\f(CWpostmigrate\fR" 4
.IX Item "postmigrate"
guest is paused following a successful 'migrate'
.ie n .IP """prelaunch""" 4
.el .IP "\f(CWprelaunch\fR" 4
.IX Item "prelaunch"
\&\s-1QEMU\s0 was started with \-S and guest has not started
.ie n .IP """restore\-vm""" 4
.el .IP "\f(CWrestore\-vm\fR" 4
.IX Item "restore-vm"
guest is paused to restore \s-1VM\s0 state
.ie n .IP """running""" 4
.el .IP "\f(CWrunning\fR" 4
.IX Item "running"
guest is actively running
.ie n .IP """save\-vm""" 4
.el .IP "\f(CWsave\-vm\fR" 4
.IX Item "save-vm"
guest is paused to save the \s-1VM\s0 state
.ie n .IP """shutdown""" 4
.el .IP "\f(CWshutdown\fR" 4
.IX Item "shutdown"
guest is shut down (and \-no\-shutdown is in use)
.ie n .IP """suspended""" 4
.el .IP "\f(CWsuspended\fR" 4
.IX Item "suspended"
guest is suspended (\s-1ACPI S3\s0)
.ie n .IP """watchdog""" 4
.el .IP "\f(CWwatchdog\fR" 4
.IX Item "watchdog"
the watchdog action is configured to pause and has been triggered
.ie n .IP """guest\-panicked""" 4
.el .IP "\f(CWguest\-panicked\fR" 4
.IX Item "guest-panicked"
guest has been panicked as a result of guest \s-1OS\s0 panic
.ie n .IP """colo""" 4
.el .IP "\f(CWcolo\fR" 4
.IX Item "colo"
guest is paused to save/restore \s-1VM\s0 state under colo checkpoint,
\&\s-1VM\s0 can not get into this state unless colo capability is enabled
for migration. (since 2.8)
.PP
\&\fBStatusInfo\fR (Object)
.PP
Information about \s-1VCPU\s0 run state
.PP
\&\fBMembers:\fR
.ie n .IP """running: boolean""" 4
.el .IP "\f(CWrunning: boolean\fR" 4
.IX Item "running: boolean"
true if all VCPUs are runnable, false if not runnable
.ie n .IP """singlestep: boolean""" 4
.el .IP "\f(CWsinglestep: boolean\fR" 4
.IX Item "singlestep: boolean"
true if VCPUs are in single-step mode
.ie n .IP """status: RunState""" 4
.el .IP "\f(CWstatus: RunState\fR" 4
.IX Item "status: RunState"
the virtual machine \f(CW\*(C`RunState\*(C'\fR
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
\&\f(CW\*(C`singlestep\*(C'\fR is enabled through the \s-1GDB\s0 stub
.PP
\&\fBquery-status\fR  (Command)
Query the run status of all VCPUs
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`StatusInfo\*(C'\fR reflecting all VCPUs
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&        \-> { "execute": "query\-status" }
\&        <\- { "return": { "running": true,
\&                         "singlestep": false,
\&                         "status": "running" } }
.Ve
.PP
\&\fBUuidInfo\fR (Object)
.PP
Guest \s-1UUID\s0 information (Universally Unique Identifier).
.PP
\&\fBMembers:\fR
.ie n .IP """UUID: string""" 4
.el .IP "\f(CWUUID: string\fR" 4
.IX Item "UUID: string"
the \s-1UUID\s0 of the guest
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
If no \s-1UUID\s0 was specified for the guest, a null \s-1UUID\s0 is returned.
.PP
\&\fBquery-uuid\fR  (Command)
Query the guest \s-1UUID\s0 information.
.PP
\&\fBReturns:\fR
The \f(CW\*(C`UuidInfo\*(C'\fR for the guest
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "query\-uuid" }
\&        <\- { "return": { "UUID": "550e8400\-e29b\-41d4\-a716\-446655440000" } }
.Ve
.PP
\&\fBChardevInfo\fR (Object)
.PP
Information about a character device.
.PP
\&\fBMembers:\fR
.ie n .IP """label: string""" 4
.el .IP "\f(CWlabel: string\fR" 4
.IX Item "label: string"
the label of the character device
.ie n .IP """filename: string""" 4
.el .IP "\f(CWfilename: string\fR" 4
.IX Item "filename: string"
the filename of the character device
.ie n .IP """frontend\-open: boolean""" 4
.el .IP "\f(CWfrontend\-open: boolean\fR" 4
.IX Item "frontend-open: boolean"
shows whether the frontend device attached to this backend
(eg. with the chardev=... option) is in open or closed state
(since 2.1)
.PP
\&\fBNotes:\fR
\&\f(CW\*(C`filename\*(C'\fR is encoded using the \s-1QEMU\s0 command line character device
encoding.  See the \s-1QEMU\s0 man page for details.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBquery-chardev\fR  (Command)
Returns information about current character devices.
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`ChardevInfo\*(C'\fR
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-chardev" }
\&        <\- {
\&              "return": [
\&                 {
\&                    "label": "charchannel0",
\&                    "filename": "unix:/var/lib/libvirt/qemu/seabios.rhel6.agent,server",
\&                    "frontend\-open": false
\&                 },
\&                 {
\&                    "label": "charmonitor",
\&                    "filename": "unix:/var/lib/libvirt/qemu/seabios.rhel6.monitor,server",
\&                    "frontend\-open": true
\&                 },
\&                 {
\&                    "label": "charserial0",
\&                    "filename": "pty:/dev/pts/2",
\&                    "frontend\-open": true
\&                 }
\&              ]
\&           }
.Ve
.PP
\&\fBChardevBackendInfo\fR (Object)
.PP
Information about a character device backend
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
The backend name
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBquery-chardev-backends\fR  (Command)
Returns information about character device backends.
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`ChardevBackendInfo\*(C'\fR
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-chardev\-backends" }
\&        <\- {
\&              "return":[
\&                 {
\&                    "name":"udp"
\&                 },
\&                 {
\&                    "name":"tcp"
\&                 },
\&                 {
\&                    "name":"unix"
\&                 },
\&                 {
\&                    "name":"spiceport"
\&                 }
\&              ]
\&           }
.Ve
.PP
\&\fBDataFormat\fR (Enum)
.PP
An enumeration of data format.
.PP
\&\fBValues:\fR
.ie n .IP """utf8""" 4
.el .IP "\f(CWutf8\fR" 4
.IX Item "utf8"
Data is a \s-1UTF\-8\s0 string (\s-1RFC 3629\s0)
.ie n .IP """base64""" 4
.el .IP "\f(CWbase64\fR" 4
.IX Item "base64"
Data is Base64 encoded binary (\s-1RFC 3548\s0)
.PP
\&\fBSince:\fR
1.4
.PP
\&\fBringbuf-write\fR  (Command)
Write to a ring buffer character device.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
the ring buffer character device name
.ie n .IP """data: string""" 4
.el .IP "\f(CWdata: string\fR" 4
.IX Item "data: string"
data to write
.ie n .IP """format: DataFormat"" (optional)" 4
.el .IP "\f(CWformat: DataFormat\fR (optional)" 4
.IX Item "format: DataFormat (optional)"
data encoding (default 'utf8').
.RS 4
.IP "\-" 4
base64: data must be base64 encoded text.  Its binary
decoding gets written.
.IP "\-" 4
utf8: data's \s-1UTF\-8\s0 encoding is written
.IP "\-" 4
data itself is always Unicode regardless of format, like
any other string.
.RE
.RS 4
.RE
.PP
\&\fBReturns:\fR
Nothing on success
.PP
\&\fBSince:\fR
1.4
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "ringbuf\-write",
\&             "arguments": { "device": "foo",
\&                            "data": "abcdefgh",
\&                            "format": "utf8" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBringbuf-read\fR  (Command)
Read from a ring buffer character device.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
the ring buffer character device name
.ie n .IP """size: int""" 4
.el .IP "\f(CWsize: int\fR" 4
.IX Item "size: int"
how many bytes to read at most
.ie n .IP """format: DataFormat"" (optional)" 4
.el .IP "\f(CWformat: DataFormat\fR (optional)" 4
.IX Item "format: DataFormat (optional)"
data encoding (default 'utf8').
.RS 4
.IP "\-" 4
base64: the data read is returned in base64 encoding.
.IP "\-" 4
utf8: the data read is interpreted as \s-1UTF\-8.\s0
Bug: can screw up when the buffer contains invalid \s-1UTF\-8\s0
sequences, \s-1NUL\s0 characters, after the ring buffer lost
data, and when reading stops because the size limit is
reached.
.IP "\-" 4
The return value is always Unicode regardless of format,
like any other string.
.RE
.RS 4
.RE
.PP
\&\fBReturns:\fR
data read from the device
.PP
\&\fBSince:\fR
1.4
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "ringbuf\-read",
\&             "arguments": { "device": "foo",
\&                            "size": 1000,
\&                            "format": "utf8" } }
\&        <\- { "return": "abcdefgh" }
.Ve
.PP
\&\fBEventInfo\fR (Object)
.PP
Information about a \s-1QMP\s0 event
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
The event name
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBquery-events\fR  (Command)
Return a list of supported \s-1QMP\s0 events by this server
.PP
\&\fBReturns:\fR
A list of \f(CW\*(C`EventInfo\*(C'\fR for all supported events
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBExample:\fR
.PP
.Vb 11
\&        \-> { "execute": "query\-events" }
\&        <\- {
\&             "return": [
\&                 {
\&                    "name":"SHUTDOWN"
\&                 },
\&                 {
\&                    "name":"RESET"
\&                 }
\&              ]
\&           }
.Ve
.PP
\&\fBNote:\fR
This example has been shortened as the real response is too long.
.PP
\&\fBMigrationStats\fR (Object)
.PP
Detailed migration status.
.PP
\&\fBMembers:\fR
.ie n .IP """transferred: int""" 4
.el .IP "\f(CWtransferred: int\fR" 4
.IX Item "transferred: int"
amount of bytes already transferred to the target \s-1VM\s0
.ie n .IP """remaining: int""" 4
.el .IP "\f(CWremaining: int\fR" 4
.IX Item "remaining: int"
amount of bytes remaining to be transferred to the target \s-1VM\s0
.ie n .IP """total: int""" 4
.el .IP "\f(CWtotal: int\fR" 4
.IX Item "total: int"
total amount of bytes involved in the migration process
.ie n .IP """duplicate: int""" 4
.el .IP "\f(CWduplicate: int\fR" 4
.IX Item "duplicate: int"
number of duplicate (zero) pages (since 1.2)
.ie n .IP """skipped: int""" 4
.el .IP "\f(CWskipped: int\fR" 4
.IX Item "skipped: int"
number of skipped zero pages (since 1.5)
.ie n .IP """normal: int""" 4
.el .IP "\f(CWnormal: int\fR" 4
.IX Item "normal: int"
number of normal pages (since 1.2)
.ie n .IP """normal\-bytes: int""" 4
.el .IP "\f(CWnormal\-bytes: int\fR" 4
.IX Item "normal-bytes: int"
number of normal bytes sent (since 1.2)
.ie n .IP """dirty\-pages\-rate: int""" 4
.el .IP "\f(CWdirty\-pages\-rate: int\fR" 4
.IX Item "dirty-pages-rate: int"
number of pages dirtied by second by the
guest (since 1.3)
.ie n .IP """mbps: number""" 4
.el .IP "\f(CWmbps: number\fR" 4
.IX Item "mbps: number"
throughput in megabits/sec. (since 1.6)
.ie n .IP """dirty\-sync\-count: int""" 4
.el .IP "\f(CWdirty\-sync\-count: int\fR" 4
.IX Item "dirty-sync-count: int"
number of times that dirty ram was synchronized (since 2.1)
.ie n .IP """postcopy\-requests: int""" 4
.el .IP "\f(CWpostcopy\-requests: int\fR" 4
.IX Item "postcopy-requests: int"
The number of page requests received from the destination
(since 2.7)
.ie n .IP """page\-size: int""" 4
.el .IP "\f(CWpage\-size: int\fR" 4
.IX Item "page-size: int"
The number of bytes per page for the various page-based
statistics (since 2.10)
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBXBZRLECacheStats\fR (Object)
.PP
Detailed \s-1XBZRLE\s0 migration cache statistics
.PP
\&\fBMembers:\fR
.ie n .IP """cache\-size: int""" 4
.el .IP "\f(CWcache\-size: int\fR" 4
.IX Item "cache-size: int"
\&\s-1XBZRLE\s0 cache size
.ie n .IP """bytes: int""" 4
.el .IP "\f(CWbytes: int\fR" 4
.IX Item "bytes: int"
amount of bytes already transferred to the target \s-1VM\s0
.ie n .IP """pages: int""" 4
.el .IP "\f(CWpages: int\fR" 4
.IX Item "pages: int"
amount of pages transferred to the target \s-1VM\s0
.ie n .IP """cache\-miss: int""" 4
.el .IP "\f(CWcache\-miss: int\fR" 4
.IX Item "cache-miss: int"
number of cache miss
.ie n .IP """cache\-miss\-rate: number""" 4
.el .IP "\f(CWcache\-miss\-rate: number\fR" 4
.IX Item "cache-miss-rate: number"
rate of cache miss (since 2.1)
.ie n .IP """overflow: int""" 4
.el .IP "\f(CWoverflow: int\fR" 4
.IX Item "overflow: int"
number of overflows
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBMigrationStatus\fR (Enum)
.PP
An enumeration of migration status.
.PP
\&\fBValues:\fR
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
no migration has ever happened.
.ie n .IP """setup""" 4
.el .IP "\f(CWsetup\fR" 4
.IX Item "setup"
migration process has been initiated.
.ie n .IP """cancelling""" 4
.el .IP "\f(CWcancelling\fR" 4
.IX Item "cancelling"
in the process of cancelling migration.
.ie n .IP """cancelled""" 4
.el .IP "\f(CWcancelled\fR" 4
.IX Item "cancelled"
cancelling migration is finished.
.ie n .IP """active""" 4
.el .IP "\f(CWactive\fR" 4
.IX Item "active"
in the process of doing migration.
.ie n .IP """postcopy\-active""" 4
.el .IP "\f(CWpostcopy\-active\fR" 4
.IX Item "postcopy-active"
like active, but now in postcopy mode. (since 2.5)
.ie n .IP """completed""" 4
.el .IP "\f(CWcompleted\fR" 4
.IX Item "completed"
migration is finished.
.ie n .IP """failed""" 4
.el .IP "\f(CWfailed\fR" 4
.IX Item "failed"
some error occurred during migration process.
.ie n .IP """colo""" 4
.el .IP "\f(CWcolo\fR" 4
.IX Item "colo"
\&\s-1VM\s0 is in the process of fault tolerance, \s-1VM\s0 can not get into this
state unless colo capability is enabled for migration. (since 2.8)
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBMigrationInfo\fR (Object)
.PP
Information about current migration process.
.PP
\&\fBMembers:\fR
.ie n .IP """status: MigrationStatus"" (optional)" 4
.el .IP "\f(CWstatus: MigrationStatus\fR (optional)" 4
.IX Item "status: MigrationStatus (optional)"
\&\f(CW\*(C`MigrationStatus\*(C'\fR describing the current migration status.
If this field is not returned, no migration process
has been initiated
.ie n .IP """ram: MigrationStats"" (optional)" 4
.el .IP "\f(CWram: MigrationStats\fR (optional)" 4
.IX Item "ram: MigrationStats (optional)"
\&\f(CW\*(C`MigrationStats\*(C'\fR containing detailed migration
status, only returned if status is 'active' or
\&'completed'(since 1.2)
.ie n .IP """disk: MigrationStats"" (optional)" 4
.el .IP "\f(CWdisk: MigrationStats\fR (optional)" 4
.IX Item "disk: MigrationStats (optional)"
\&\f(CW\*(C`MigrationStats\*(C'\fR containing detailed disk migration
status, only returned if status is 'active' and it is a block
migration
.ie n .IP """xbzrle\-cache: XBZRLECacheStats"" (optional)" 4
.el .IP "\f(CWxbzrle\-cache: XBZRLECacheStats\fR (optional)" 4
.IX Item "xbzrle-cache: XBZRLECacheStats (optional)"
\&\f(CW\*(C`XBZRLECacheStats\*(C'\fR containing detailed \s-1XBZRLE\s0
migration statistics, only returned if \s-1XBZRLE\s0 feature is on and
status is 'active' or 'completed' (since 1.2)
.ie n .IP """total\-time: int"" (optional)" 4
.el .IP "\f(CWtotal\-time: int\fR (optional)" 4
.IX Item "total-time: int (optional)"
total amount of milliseconds since migration started.
If migration has ended, it returns the total migration
time. (since 1.2)
.ie n .IP """downtime: int"" (optional)" 4
.el .IP "\f(CWdowntime: int\fR (optional)" 4
.IX Item "downtime: int (optional)"
only present when migration finishes correctly
total downtime in milliseconds for the guest.
(since 1.3)
.ie n .IP """expected\-downtime: int"" (optional)" 4
.el .IP "\f(CWexpected\-downtime: int\fR (optional)" 4
.IX Item "expected-downtime: int (optional)"
only present while migration is active
expected downtime in milliseconds for the guest in last walk
of the dirty bitmap. (since 1.3)
.ie n .IP """setup\-time: int"" (optional)" 4
.el .IP "\f(CWsetup\-time: int\fR (optional)" 4
.IX Item "setup-time: int (optional)"
amount of setup time in milliseconds \fIbefore\fR the
iterations begin but \fIafter\fR the \s-1QMP\s0 command is issued. This is designed
to provide an accounting of any activities (such as \s-1RDMA\s0 pinning) which
may be expensive, but do not actually occur during the iterative
migration rounds themselves. (since 1.6)
.ie n .IP """cpu\-throttle\-percentage: int"" (optional)" 4
.el .IP "\f(CWcpu\-throttle\-percentage: int\fR (optional)" 4
.IX Item "cpu-throttle-percentage: int (optional)"
percentage of time guest cpus are being
throttled during auto-converge. This is only present when auto-converge
has started throttling guest cpus. (Since 2.7)
.ie n .IP """error\-desc: string"" (optional)" 4
.el .IP "\f(CWerror\-desc: string\fR (optional)" 4
.IX Item "error-desc: string (optional)"
the human readable error description string, when
\&\f(CW\*(C`status\*(C'\fR is 'failed'. Clients should not attempt to parse the
error strings. (Since 2.7)
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBquery-migrate\fR  (Command)
Returns information about current migration process. If migration
is active there will be another json-object with \s-1RAM\s0 migration
status and if block migration is active another one with block
migration status.
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`MigrationInfo\*(C'\fR
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&        1. Before the first migration
\&        
\&        \-> { "execute": "query\-migrate" }
\&        <\- { "return": {} }
\&        
\&        2. Migration is done and has succeeded
\&        
\&        \-> { "execute": "query\-migrate" }
\&        <\- { "return": {
\&                "status": "completed",
\&                "ram":{
\&                  "transferred":123,
\&                  "remaining":123,
\&                  "total":246,
\&                  "total\-time":12345,
\&                  "setup\-time":12345,
\&                  "downtime":12345,
\&                  "duplicate":123,
\&                  "normal":123,
\&                  "normal\-bytes":123456,
\&                  "dirty\-sync\-count":15
\&                }
\&             }
\&           }
\&        
\&        3. Migration is done and has failed
\&        
\&        \-> { "execute": "query\-migrate" }
\&        <\- { "return": { "status": "failed" } }
\&        
\&        4. Migration is being performed and is not a block migration:
\&        
\&        \-> { "execute": "query\-migrate" }
\&        <\- {
\&              "return":{
\&                 "status":"active",
\&                 "ram":{
\&                    "transferred":123,
\&                    "remaining":123,
\&                    "total":246,
\&                    "total\-time":12345,
\&                    "setup\-time":12345,
\&                    "expected\-downtime":12345,
\&                    "duplicate":123,
\&                    "normal":123,
\&                    "normal\-bytes":123456,
\&                    "dirty\-sync\-count":15
\&                 }
\&              }
\&           }
\&        
\&        5. Migration is being performed and is a block migration:
\&        
\&        \-> { "execute": "query\-migrate" }
\&        <\- {
\&              "return":{
\&                 "status":"active",
\&                 "ram":{
\&                    "total":1057024,
\&                    "remaining":1053304,
\&                    "transferred":3720,
\&                    "total\-time":12345,
\&                    "setup\-time":12345,
\&                    "expected\-downtime":12345,
\&                    "duplicate":123,
\&                    "normal":123,
\&                    "normal\-bytes":123456,
\&                    "dirty\-sync\-count":15
\&                 },
\&                 "disk":{
\&                    "total":20971520,
\&                    "remaining":20880384,
\&                    "transferred":91136
\&                 }
\&              }
\&           }
\&        
\&        6. Migration is being performed and XBZRLE is active:
\&        
\&        \-> { "execute": "query\-migrate" }
\&        <\- {
\&              "return":{
\&                 "status":"active",
\&                 "capabilities" : [ { "capability": "xbzrle", "state" : true } ],
\&                 "ram":{
\&                    "total":1057024,
\&                    "remaining":1053304,
\&                    "transferred":3720,
\&                    "total\-time":12345,
\&                    "setup\-time":12345,
\&                    "expected\-downtime":12345,
\&                    "duplicate":10,
\&                    "normal":3333,
\&                    "normal\-bytes":3412992,
\&                    "dirty\-sync\-count":15
\&                 },
\&                 "xbzrle\-cache":{
\&                    "cache\-size":67108864,
\&                    "bytes":20971520,
\&                    "pages":2444343,
\&                    "cache\-miss":2244,
\&                    "cache\-miss\-rate":0.123,
\&                    "overflow":34434
\&                 }
\&              }
\&           }
.Ve
.PP
\&\fBMigrationCapability\fR (Enum)
.PP
Migration capabilities enumeration
.PP
\&\fBValues:\fR
.ie n .IP """xbzrle""" 4
.el .IP "\f(CWxbzrle\fR" 4
.IX Item "xbzrle"
Migration supports xbzrle (Xor Based Zero Run Length Encoding).
This feature allows us to minimize migration traffic for certain work
loads, by sending compressed difference of the pages
.ie n .IP """rdma\-pin\-all""" 4
.el .IP "\f(CWrdma\-pin\-all\fR" 4
.IX Item "rdma-pin-all"
Controls whether or not the entire \s-1VM\s0 memory footprint is
\&\fImlock()\fR'd on demand or all at once. Refer to docs/rdma.txt for usage.
Disabled by default. (since 2.0)
.ie n .IP """zero\-blocks""" 4
.el .IP "\f(CWzero\-blocks\fR" 4
.IX Item "zero-blocks"
During storage migration encode blocks of zeroes efficiently. This
essentially saves 1MB of zeroes per block on the wire. Enabling requires
source and target \s-1VM\s0 to support this feature. To enable it is sufficient
to enable the capability on the source \s-1VM.\s0 The feature is disabled by
default. (since 1.6)
.ie n .IP """compress""" 4
.el .IP "\f(CWcompress\fR" 4
.IX Item "compress"
Use multiple compression threads to accelerate live migration.
This feature can help to reduce the migration traffic, by sending
compressed pages. Please note that if compress and xbzrle are both
on, compress only takes effect in the ram bulk stage, after that,
it will be disabled and only xbzrle takes effect, this can help to
minimize migration traffic. The feature is disabled by default.
(since 2.4 )
.ie n .IP """events""" 4
.el .IP "\f(CWevents\fR" 4
.IX Item "events"
generate events for each migration state change
(since 2.4 )
.ie n .IP """auto\-converge""" 4
.el .IP "\f(CWauto\-converge\fR" 4
.IX Item "auto-converge"
If enabled, \s-1QEMU\s0 will automatically throttle down the guest
to speed up convergence of \s-1RAM\s0 migration. (since 1.6)
.ie n .IP """postcopy\-ram""" 4
.el .IP "\f(CWpostcopy\-ram\fR" 4
.IX Item "postcopy-ram"
Start executing on the migration target before all of \s-1RAM\s0 has
been migrated, pulling the remaining pages along as needed. \s-1NOTE:\s0 If
the migration fails during postcopy the \s-1VM\s0 will fail.  (since 2.6)
.ie n .IP """x\-colo""" 4
.el .IP "\f(CWx\-colo\fR" 4
.IX Item "x-colo"
If enabled, migration will never end, and the state of the \s-1VM\s0 on the
primary side will be migrated continuously to the \s-1VM\s0 on secondary
side, this process is called COarse-Grain LOck Stepping (\s-1COLO\s0) for
Non-stop Service. (since 2.8)
.ie n .IP """release\-ram""" 4
.el .IP "\f(CWrelease\-ram\fR" 4
.IX Item "release-ram"
if enabled, qemu will free the migrated ram pages on the source
during postcopy-ram migration. (since 2.9)
.ie n .IP """block""" 4
.el .IP "\f(CWblock\fR" 4
.IX Item "block"
If enabled, \s-1QEMU\s0 will also migrate the contents of all block
devices.  Default is disabled.  A possible alternative uses
mirror jobs to a builtin \s-1NBD\s0 server on the destination, which
offers more flexibility.
(Since 2.10)
.ie n .IP """return\-path""" 4
.el .IP "\f(CWreturn\-path\fR" 4
.IX Item "return-path"
If enabled, migration will use the return path even
for precopy. (since 2.10)
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBMigrationCapabilityStatus\fR (Object)
.PP
Migration capability information
.PP
\&\fBMembers:\fR
.ie n .IP """capability: MigrationCapability""" 4
.el .IP "\f(CWcapability: MigrationCapability\fR" 4
.IX Item "capability: MigrationCapability"
capability enum
.ie n .IP """state: boolean""" 4
.el .IP "\f(CWstate: boolean\fR" 4
.IX Item "state: boolean"
capability state bool
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBmigrate-set-capabilities\fR  (Command)
Enable/Disable the following migration capabilities (like xbzrle)
.PP
\&\fBArguments:\fR
.ie n .IP """capabilities: array of MigrationCapabilityStatus""" 4
.el .IP "\f(CWcapabilities: array of MigrationCapabilityStatus\fR" 4
.IX Item "capabilities: array of MigrationCapabilityStatus"
json array of capability modifications to make
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "migrate\-set\-capabilities" , "arguments":
\&             { "capabilities": [ { "capability": "xbzrle", "state": true } ] } }
.Ve
.PP
\&\fBquery-migrate-capabilities\fR  (Command)
Returns information about the current migration capabilities status
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`MigrationCapabilitiesStatus\*(C'\fR
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBExample:\fR
.PP
.Vb 11
\&        \-> { "execute": "query\-migrate\-capabilities" }
\&        <\- { "return": [
\&              {"state": false, "capability": "xbzrle"},
\&              {"state": false, "capability": "rdma\-pin\-all"},
\&              {"state": false, "capability": "auto\-converge"},
\&              {"state": false, "capability": "zero\-blocks"},
\&              {"state": false, "capability": "compress"},
\&              {"state": true, "capability": "events"},
\&              {"state": false, "capability": "postcopy\-ram"},
\&              {"state": false, "capability": "x\-colo"}
\&           ]}
.Ve
.PP
\&\fBMigrationParameter\fR (Enum)
.PP
Migration parameters enumeration
.PP
\&\fBValues:\fR
.ie n .IP """compress\-level""" 4
.el .IP "\f(CWcompress\-level\fR" 4
.IX Item "compress-level"
Set the compression level to be used in live migration,
the compression level is an integer between 0 and 9, where 0 means
no compression, 1 means the best compression speed, and 9 means best
compression ratio which will consume more \s-1CPU.\s0
.ie n .IP """compress\-threads""" 4
.el .IP "\f(CWcompress\-threads\fR" 4
.IX Item "compress-threads"
Set compression thread count to be used in live migration,
the compression thread count is an integer between 1 and 255.
.ie n .IP """decompress\-threads""" 4
.el .IP "\f(CWdecompress\-threads\fR" 4
.IX Item "decompress-threads"
Set decompression thread count to be used in live
migration, the decompression thread count is an integer between 1
and 255. Usually, decompression is at least 4 times as fast as
compression, so set the decompress-threads to the number about 1/4
of compress-threads is adequate.
.ie n .IP """cpu\-throttle\-initial""" 4
.el .IP "\f(CWcpu\-throttle\-initial\fR" 4
.IX Item "cpu-throttle-initial"
Initial percentage of time guest cpus are throttled
when migration auto-converge is activated. The
default value is 20. (Since 2.7)
.ie n .IP """cpu\-throttle\-increment""" 4
.el .IP "\f(CWcpu\-throttle\-increment\fR" 4
.IX Item "cpu-throttle-increment"
throttle percentage increase each time
auto-converge detects that migration is not making
progress. The default value is 10. (Since 2.7)
.ie n .IP """tls\-creds""" 4
.el .IP "\f(CWtls\-creds\fR" 4
.IX Item "tls-creds"
\&\s-1ID\s0 of the 'tls\-creds' object that provides credentials for
establishing a \s-1TLS\s0 connection over the migration data channel.
On the outgoing side of the migration, the credentials must
be for a 'client' endpoint, while for the incoming side the
credentials must be for a 'server' endpoint. Setting this
will enable \s-1TLS\s0 for all migrations. The default is unset,
resulting in unsecured migration at the \s-1QEMU\s0 level. (Since 2.7)
.ie n .IP """tls\-hostname""" 4
.el .IP "\f(CWtls\-hostname\fR" 4
.IX Item "tls-hostname"
hostname of the target host for the migration. This is
required when using x509 based \s-1TLS\s0 credentials and the
migration \s-1URI\s0 does not already include a hostname. For
example if using fd: or exec: based migration, the
hostname must be provided so that the server's x509
certificate identity can be validated. (Since 2.7)
.ie n .IP """max\-bandwidth""" 4
.el .IP "\f(CWmax\-bandwidth\fR" 4
.IX Item "max-bandwidth"
to set maximum speed for migration. maximum speed in
bytes per second. (Since 2.8)
.ie n .IP """downtime\-limit""" 4
.el .IP "\f(CWdowntime\-limit\fR" 4
.IX Item "downtime-limit"
set maximum tolerated downtime for migration. maximum
downtime in milliseconds (Since 2.8)
.ie n .IP """x\-checkpoint\-delay""" 4
.el .IP "\f(CWx\-checkpoint\-delay\fR" 4
.IX Item "x-checkpoint-delay"
The delay time (in ms) between two \s-1COLO\s0 checkpoints in
periodic mode. (Since 2.8)
.ie n .IP """block\-incremental""" 4
.el .IP "\f(CWblock\-incremental\fR" 4
.IX Item "block-incremental"
Affects how much storage is migrated when the
block migration capability is enabled.  When false, the entire
storage backing chain is migrated into a flattened image at
the destination; when true, only the active qcow2 layer is
migrated and the destination must already have access to the
same backing chain as was used on the source.  (since 2.10)
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBMigrateSetParameters\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """compress\-level: int"" (optional)" 4
.el .IP "\f(CWcompress\-level: int\fR (optional)" 4
.IX Item "compress-level: int (optional)"
compression level
.ie n .IP """compress\-threads: int"" (optional)" 4
.el .IP "\f(CWcompress\-threads: int\fR (optional)" 4
.IX Item "compress-threads: int (optional)"
compression thread count
.ie n .IP """decompress\-threads: int"" (optional)" 4
.el .IP "\f(CWdecompress\-threads: int\fR (optional)" 4
.IX Item "decompress-threads: int (optional)"
decompression thread count
.ie n .IP """cpu\-throttle\-initial: int"" (optional)" 4
.el .IP "\f(CWcpu\-throttle\-initial: int\fR (optional)" 4
.IX Item "cpu-throttle-initial: int (optional)"
Initial percentage of time guest cpus are
throttled when migration auto-converge is activated.
The default value is 20. (Since 2.7)
.ie n .IP """cpu\-throttle\-increment: int"" (optional)" 4
.el .IP "\f(CWcpu\-throttle\-increment: int\fR (optional)" 4
.IX Item "cpu-throttle-increment: int (optional)"
throttle percentage increase each time
auto-converge detects that migration is not making
progress. The default value is 10. (Since 2.7)
.ie n .IP """tls\-creds: StrOrNull"" (optional)" 4
.el .IP "\f(CWtls\-creds: StrOrNull\fR (optional)" 4
.IX Item "tls-creds: StrOrNull (optional)"
\&\s-1ID\s0 of the 'tls\-creds' object that provides credentials
for establishing a \s-1TLS\s0 connection over the migration data
channel. On the outgoing side of the migration, the credentials
must be for a 'client' endpoint, while for the incoming side the
credentials must be for a 'server' endpoint. Setting this
to a non-empty string enables \s-1TLS\s0 for all migrations.
An empty string means that \s-1QEMU\s0 will use plain text mode for
migration, rather than \s-1TLS \s0(Since 2.9)
Previously (since 2.7), this was reported by omitting
tls-creds instead.
.ie n .IP """tls\-hostname: StrOrNull"" (optional)" 4
.el .IP "\f(CWtls\-hostname: StrOrNull\fR (optional)" 4
.IX Item "tls-hostname: StrOrNull (optional)"
hostname of the target host for the migration. This
is required when using x509 based \s-1TLS\s0 credentials and the
migration \s-1URI\s0 does not already include a hostname. For
example if using fd: or exec: based migration, the
hostname must be provided so that the server's x509
certificate identity can be validated. (Since 2.7)
An empty string means that \s-1QEMU\s0 will use the hostname
associated with the migration \s-1URI,\s0 if any. (Since 2.9)
Previously (since 2.7), this was reported by omitting
tls-hostname instead.
.ie n .IP """max\-bandwidth: int"" (optional)" 4
.el .IP "\f(CWmax\-bandwidth: int\fR (optional)" 4
.IX Item "max-bandwidth: int (optional)"
to set maximum speed for migration. maximum speed in
bytes per second. (Since 2.8)
.ie n .IP """downtime\-limit: int"" (optional)" 4
.el .IP "\f(CWdowntime\-limit: int\fR (optional)" 4
.IX Item "downtime-limit: int (optional)"
set maximum tolerated downtime for migration. maximum
downtime in milliseconds (Since 2.8)
.ie n .IP """x\-checkpoint\-delay: int"" (optional)" 4
.el .IP "\f(CWx\-checkpoint\-delay: int\fR (optional)" 4
.IX Item "x-checkpoint-delay: int (optional)"
the delay time between two \s-1COLO\s0 checkpoints. (Since 2.8)
.ie n .IP """block\-incremental: boolean"" (optional)" 4
.el .IP "\f(CWblock\-incremental: boolean\fR (optional)" 4
.IX Item "block-incremental: boolean (optional)"
Affects how much storage is migrated when the
block migration capability is enabled.  When false, the entire
storage backing chain is migrated into a flattened image at
the destination; when true, only the active qcow2 layer is
migrated and the destination must already have access to the
same backing chain as was used on the source.  (since 2.10)
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBmigrate-set-parameters\fR  (Command)
Set various migration parameters.
.PP
\&\fBArguments:\fR the members of \f(CW\*(C`MigrateSetParameters\*(C'\fR
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "migrate\-set\-parameters" ,
\&             "arguments": { "compress\-level": 1 } }
.Ve
.PP
\&\fBMigrationParameters\fR (Object)
.PP
The optional members aren't actually optional.
.PP
\&\fBMembers:\fR
.ie n .IP """compress\-level: int"" (optional)" 4
.el .IP "\f(CWcompress\-level: int\fR (optional)" 4
.IX Item "compress-level: int (optional)"
compression level
.ie n .IP """compress\-threads: int"" (optional)" 4
.el .IP "\f(CWcompress\-threads: int\fR (optional)" 4
.IX Item "compress-threads: int (optional)"
compression thread count
.ie n .IP """decompress\-threads: int"" (optional)" 4
.el .IP "\f(CWdecompress\-threads: int\fR (optional)" 4
.IX Item "decompress-threads: int (optional)"
decompression thread count
.ie n .IP """cpu\-throttle\-initial: int"" (optional)" 4
.el .IP "\f(CWcpu\-throttle\-initial: int\fR (optional)" 4
.IX Item "cpu-throttle-initial: int (optional)"
Initial percentage of time guest cpus are
throttled when migration auto-converge is activated.
(Since 2.7)
.ie n .IP """cpu\-throttle\-increment: int"" (optional)" 4
.el .IP "\f(CWcpu\-throttle\-increment: int\fR (optional)" 4
.IX Item "cpu-throttle-increment: int (optional)"
throttle percentage increase each time
auto-converge detects that migration is not making
progress. (Since 2.7)
.ie n .IP """tls\-creds: string"" (optional)" 4
.el .IP "\f(CWtls\-creds: string\fR (optional)" 4
.IX Item "tls-creds: string (optional)"
\&\s-1ID\s0 of the 'tls\-creds' object that provides credentials
for establishing a \s-1TLS\s0 connection over the migration data
channel. On the outgoing side of the migration, the credentials
must be for a 'client' endpoint, while for the incoming side the
credentials must be for a 'server' endpoint.
An empty string means that \s-1QEMU\s0 will use plain text mode for
migration, rather than \s-1TLS \s0(Since 2.7)
Note: 2.8 reports this by omitting tls-creds instead.
.ie n .IP """tls\-hostname: string"" (optional)" 4
.el .IP "\f(CWtls\-hostname: string\fR (optional)" 4
.IX Item "tls-hostname: string (optional)"
hostname of the target host for the migration. This
is required when using x509 based \s-1TLS\s0 credentials and the
migration \s-1URI\s0 does not already include a hostname. For
example if using fd: or exec: based migration, the
hostname must be provided so that the server's x509
certificate identity can be validated. (Since 2.7)
An empty string means that \s-1QEMU\s0 will use the hostname
associated with the migration \s-1URI,\s0 if any. (Since 2.9)
Note: 2.8 reports this by omitting tls-hostname instead.
.ie n .IP """max\-bandwidth: int"" (optional)" 4
.el .IP "\f(CWmax\-bandwidth: int\fR (optional)" 4
.IX Item "max-bandwidth: int (optional)"
to set maximum speed for migration. maximum speed in
bytes per second. (Since 2.8)
.ie n .IP """downtime\-limit: int"" (optional)" 4
.el .IP "\f(CWdowntime\-limit: int\fR (optional)" 4
.IX Item "downtime-limit: int (optional)"
set maximum tolerated downtime for migration. maximum
downtime in milliseconds (Since 2.8)
.ie n .IP """x\-checkpoint\-delay: int"" (optional)" 4
.el .IP "\f(CWx\-checkpoint\-delay: int\fR (optional)" 4
.IX Item "x-checkpoint-delay: int (optional)"
the delay time between two \s-1COLO\s0 checkpoints. (Since 2.8)
.ie n .IP """block\-incremental: boolean"" (optional)" 4
.el .IP "\f(CWblock\-incremental: boolean\fR (optional)" 4
.IX Item "block-incremental: boolean (optional)"
Affects how much storage is migrated when the
block migration capability is enabled.  When false, the entire
storage backing chain is migrated into a flattened image at
the destination; when true, only the active qcow2 layer is
migrated and the destination must already have access to the
same backing chain as was used on the source.  (since 2.10)
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBquery-migrate-parameters\fR  (Command)
Returns information about the current migration parameters
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`MigrationParameters\*(C'\fR
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBExample:\fR
.PP
.Vb 11
\&        \-> { "execute": "query\-migrate\-parameters" }
\&        <\- { "return": {
\&                 "decompress\-threads": 2,
\&                 "cpu\-throttle\-increment": 10,
\&                 "compress\-threads": 8,
\&                 "compress\-level": 1,
\&                 "cpu\-throttle\-initial": 20,
\&                 "max\-bandwidth": 33554432,
\&                 "downtime\-limit": 300
\&              }
\&           }
.Ve
.PP
\&\fBclient_migrate_info\fR  (Command)
Set migration information for remote display.  This makes the server
ask the client to automatically reconnect using the new parameters
once migration finished successfully.  Only implemented for \s-1SPICE.\s0
.PP
\&\fBArguments:\fR
.ie n .IP """protocol: string""" 4
.el .IP "\f(CWprotocol: string\fR" 4
.IX Item "protocol: string"
must be \*(L"spice\*(R"
.ie n .IP """hostname: string""" 4
.el .IP "\f(CWhostname: string\fR" 4
.IX Item "hostname: string"
migration target hostname
.ie n .IP """port: int"" (optional)" 4
.el .IP "\f(CWport: int\fR (optional)" 4
.IX Item "port: int (optional)"
spice tcp port for plaintext channels
.ie n .IP """tls\-port: int"" (optional)" 4
.el .IP "\f(CWtls\-port: int\fR (optional)" 4
.IX Item "tls-port: int (optional)"
spice tcp port for tls-secured channels
.ie n .IP """cert\-subject: string"" (optional)" 4
.el .IP "\f(CWcert\-subject: string\fR (optional)" 4
.IX Item "cert-subject: string (optional)"
server certificate subject
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "client_migrate_info",
\&             "arguments": { "protocol": "spice",
\&                            "hostname": "virt42.lab.kraxel.org",
\&                            "port": 1234 } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBmigrate-start-postcopy\fR  (Command)
Followup to a migration command to switch the migration to postcopy mode.
The postcopy-ram capability must be set before the original migration
command.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "migrate\-start\-postcopy" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBCOLOMessage\fR (Enum)
.PP
The message transmission between Primary side and Secondary side.
.PP
\&\fBValues:\fR
.ie n .IP """checkpoint\-ready""" 4
.el .IP "\f(CWcheckpoint\-ready\fR" 4
.IX Item "checkpoint-ready"
Secondary \s-1VM \s0(\s-1SVM\s0) is ready for checkpointing
.ie n .IP """checkpoint\-request""" 4
.el .IP "\f(CWcheckpoint\-request\fR" 4
.IX Item "checkpoint-request"
Primary \s-1VM \s0(\s-1PVM\s0) tells \s-1SVM\s0 to prepare for checkpointing
.ie n .IP """checkpoint\-reply""" 4
.el .IP "\f(CWcheckpoint\-reply\fR" 4
.IX Item "checkpoint-reply"
\&\s-1SVM\s0 gets \s-1PVM\s0's checkpoint request
.ie n .IP """vmstate\-send""" 4
.el .IP "\f(CWvmstate\-send\fR" 4
.IX Item "vmstate-send"
\&\s-1VM\s0's state will be sent by \s-1PVM.\s0
.ie n .IP """vmstate\-size""" 4
.el .IP "\f(CWvmstate\-size\fR" 4
.IX Item "vmstate-size"
The total size of VMstate.
.ie n .IP """vmstate\-received""" 4
.el .IP "\f(CWvmstate\-received\fR" 4
.IX Item "vmstate-received"
\&\s-1VM\s0's state has been received by \s-1SVM.\s0
.ie n .IP """vmstate\-loaded""" 4
.el .IP "\f(CWvmstate\-loaded\fR" 4
.IX Item "vmstate-loaded"
\&\s-1VM\s0's state has been loaded by \s-1SVM.\s0
.PP
\&\fBSince:\fR
2.8
.PP
\&\fBCOLOMode\fR (Enum)
.PP
The colo mode
.PP
\&\fBValues:\fR
.ie n .IP """unknown""" 4
.el .IP "\f(CWunknown\fR" 4
.IX Item "unknown"
unknown mode
.ie n .IP """primary""" 4
.el .IP "\f(CWprimary\fR" 4
.IX Item "primary"
master side
.ie n .IP """secondary""" 4
.el .IP "\f(CWsecondary\fR" 4
.IX Item "secondary"
slave side
.PP
\&\fBSince:\fR
2.8
.PP
\&\fBFailoverStatus\fR (Enum)
.PP
An enumeration of \s-1COLO\s0 failover status
.PP
\&\fBValues:\fR
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
no failover has ever happened
.ie n .IP """require""" 4
.el .IP "\f(CWrequire\fR" 4
.IX Item "require"
got failover requirement but not handled
.ie n .IP """active""" 4
.el .IP "\f(CWactive\fR" 4
.IX Item "active"
in the process of doing failover
.ie n .IP """completed""" 4
.el .IP "\f(CWcompleted\fR" 4
.IX Item "completed"
finish the process of failover
.ie n .IP """relaunch""" 4
.el .IP "\f(CWrelaunch\fR" 4
.IX Item "relaunch"
restart the failover process, from 'none' \-> 'completed' (Since 2.9)
.PP
\&\fBSince:\fR
2.8
.PP
\&\fBx\-colo-lost-heartbeat\fR  (Command)
Tell qemu that heartbeat is lost, request it to do takeover procedures.
If this command is sent to the \s-1PVM,\s0 the Primary side will exit \s-1COLO\s0 mode.
If sent to the Secondary, the Secondary side will run failover work,
then takes over server operation to become the service \s-1VM.\s0
.PP
\&\fBSince:\fR
2.8
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "x\-colo\-lost\-heartbeat" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBMouseInfo\fR (Object)
.PP
Information about a mouse device.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
the name of the mouse device
.ie n .IP """index: int""" 4
.el .IP "\f(CWindex: int\fR" 4
.IX Item "index: int"
the index of the mouse device
.ie n .IP """current: boolean""" 4
.el .IP "\f(CWcurrent: boolean\fR" 4
.IX Item "current: boolean"
true if this device is currently receiving mouse events
.ie n .IP """absolute: boolean""" 4
.el .IP "\f(CWabsolute: boolean\fR" 4
.IX Item "absolute: boolean"
true if this device supports absolute coordinates as input
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBquery-mice\fR  (Command)
Returns information about each active mouse device
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`MouseInfo\*(C'\fR for each device
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-mice" }
\&        <\- { "return": [
\&                 {
\&                    "name":"QEMU Microsoft Mouse",
\&                    "index":0,
\&                    "current":false,
\&                    "absolute":false
\&                 },
\&                 {
\&                    "name":"QEMU PS/2 Mouse",
\&                    "index":1,
\&                    "current":true,
\&                    "absolute":true
\&                 }
\&              ]
\&           }
.Ve
.PP
\&\fBCpuInfoArch\fR (Enum)
.PP
An enumeration of cpu types that enable additional information during
\&\f(CW\*(C`query\-cpus\*(C'\fR.
.PP
\&\fBValues:\fR
.ie n .IP """x86""" 4
.el .IP "\f(CWx86\fR" 4
.IX Item "x86"
Not documented
.ie n .IP """sparc""" 4
.el .IP "\f(CWsparc\fR" 4
.IX Item "sparc"
Not documented
.ie n .IP """ppc""" 4
.el .IP "\f(CWppc\fR" 4
.IX Item "ppc"
Not documented
.ie n .IP """mips""" 4
.el .IP "\f(CWmips\fR" 4
.IX Item "mips"
Not documented
.ie n .IP """tricore""" 4
.el .IP "\f(CWtricore\fR" 4
.IX Item "tricore"
Not documented
.ie n .IP """other""" 4
.el .IP "\f(CWother\fR" 4
.IX Item "other"
Not documented
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBCpuInfo\fR (Object)
.PP
Information about a virtual \s-1CPU\s0
.PP
\&\fBMembers:\fR
.ie n .IP """CPU: int""" 4
.el .IP "\f(CWCPU: int\fR" 4
.IX Item "CPU: int"
the index of the virtual \s-1CPU\s0
.ie n .IP """current: boolean""" 4
.el .IP "\f(CWcurrent: boolean\fR" 4
.IX Item "current: boolean"
this only exists for backwards compatibility and should be ignored
.ie n .IP """halted: boolean""" 4
.el .IP "\f(CWhalted: boolean\fR" 4
.IX Item "halted: boolean"
true if the virtual \s-1CPU\s0 is in the halt state.  Halt usually refers
to a processor specific low power mode.
.ie n .IP """qom_path: string""" 4
.el .IP "\f(CWqom_path: string\fR" 4
.IX Item "qom_path: string"
path to the \s-1CPU\s0 object in the \s-1QOM\s0 tree (since 2.4)
.ie n .IP """thread_id: int""" 4
.el .IP "\f(CWthread_id: int\fR" 4
.IX Item "thread_id: int"
\&\s-1ID\s0 of the underlying host thread
.ie n .IP """props: CpuInstanceProperties"" (optional)" 4
.el .IP "\f(CWprops: CpuInstanceProperties\fR (optional)" 4
.IX Item "props: CpuInstanceProperties (optional)"
properties describing to which node/socket/core/thread
virtual \s-1CPU\s0 belongs to, provided if supported by board (since 2.10)
.ie n .IP """arch: CpuInfoArch""" 4
.el .IP "\f(CWarch: CpuInfoArch\fR" 4
.IX Item "arch: CpuInfoArch"
architecture of the cpu, which determines which additional fields
will be listed (since 2.6)
.ie n .IP "The members of ""CpuInfoX86"" when ""arch"" is ""x86""" 4
.el .IP "The members of \f(CWCpuInfoX86\fR when \f(CWarch\fR is ``x86''" 4
.IX Item "The members of CpuInfoX86 when arch is x86"
.PD 0
.ie n .IP "The members of ""CpuInfoSPARC"" when ""arch"" is ""sparc""" 4
.el .IP "The members of \f(CWCpuInfoSPARC\fR when \f(CWarch\fR is ``sparc''" 4
.IX Item "The members of CpuInfoSPARC when arch is sparc"
.ie n .IP "The members of ""CpuInfoPPC"" when ""arch"" is ""ppc""" 4
.el .IP "The members of \f(CWCpuInfoPPC\fR when \f(CWarch\fR is ``ppc''" 4
.IX Item "The members of CpuInfoPPC when arch is ppc"
.ie n .IP "The members of ""CpuInfoMIPS"" when ""arch"" is ""mips""" 4
.el .IP "The members of \f(CWCpuInfoMIPS\fR when \f(CWarch\fR is ``mips''" 4
.IX Item "The members of CpuInfoMIPS when arch is mips"
.ie n .IP "The members of ""CpuInfoTricore"" when ""arch"" is ""tricore""" 4
.el .IP "The members of \f(CWCpuInfoTricore\fR when \f(CWarch\fR is ``tricore''" 4
.IX Item "The members of CpuInfoTricore when arch is tricore"
.ie n .IP "The members of ""CpuInfoOther"" when ""arch"" is ""other""" 4
.el .IP "The members of \f(CWCpuInfoOther\fR when \f(CWarch\fR is ``other''" 4
.IX Item "The members of CpuInfoOther when arch is other"
.PD
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
\&\f(CW\*(C`halted\*(C'\fR is a transient state that changes frequently.  By the time the
data is sent to the client, the guest may no longer be halted.
.PP
\&\fBCpuInfoX86\fR (Object)
.PP
Additional information about a virtual i386 or x86_64 \s-1CPU\s0
.PP
\&\fBMembers:\fR
.ie n .IP """pc: int""" 4
.el .IP "\f(CWpc: int\fR" 4
.IX Item "pc: int"
the 64\-bit instruction pointer
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBCpuInfoSPARC\fR (Object)
.PP
Additional information about a virtual \s-1SPARC CPU\s0
.PP
\&\fBMembers:\fR
.ie n .IP """pc: int""" 4
.el .IP "\f(CWpc: int\fR" 4
.IX Item "pc: int"
the \s-1PC\s0 component of the instruction pointer
.ie n .IP """npc: int""" 4
.el .IP "\f(CWnpc: int\fR" 4
.IX Item "npc: int"
the \s-1NPC\s0 component of the instruction pointer
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBCpuInfoPPC\fR (Object)
.PP
Additional information about a virtual \s-1PPC CPU\s0
.PP
\&\fBMembers:\fR
.ie n .IP """nip: int""" 4
.el .IP "\f(CWnip: int\fR" 4
.IX Item "nip: int"
the instruction pointer
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBCpuInfoMIPS\fR (Object)
.PP
Additional information about a virtual \s-1MIPS CPU\s0
.PP
\&\fBMembers:\fR
.ie n .IP """PC: int""" 4
.el .IP "\f(CWPC: int\fR" 4
.IX Item "PC: int"
the instruction pointer
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBCpuInfoTricore\fR (Object)
.PP
Additional information about a virtual Tricore \s-1CPU\s0
.PP
\&\fBMembers:\fR
.ie n .IP """PC: int""" 4
.el .IP "\f(CWPC: int\fR" 4
.IX Item "PC: int"
the instruction pointer
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBCpuInfoOther\fR (Object)
.PP
No additional information is available about the virtual \s-1CPU\s0
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBquery-cpus\fR  (Command)
Returns a list of information about each virtual \s-1CPU.\s0
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`CpuInfo\*(C'\fR for each virtual \s-1CPU\s0
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-cpus" }
\&        <\- { "return": [
\&                 {
\&                    "CPU":0,
\&                    "current":true,
\&                    "halted":false,
\&                    "qom_path":"/machine/unattached/device[0]",
\&                    "arch":"x86",
\&                    "pc":3227107138,
\&                    "thread_id":3134
\&                 },
\&                 {
\&                    "CPU":1,
\&                    "current":false,
\&                    "halted":true,
\&                    "qom_path":"/machine/unattached/device[2]",
\&                    "arch":"x86",
\&                    "pc":7108165,
\&                    "thread_id":3135
\&                 }
\&              ]
\&           }
.Ve
.PP
\&\fBIOThreadInfo\fR (Object)
.PP
Information about an iothread
.PP
\&\fBMembers:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
the identifier of the iothread
.ie n .IP """thread\-id: int""" 4
.el .IP "\f(CWthread\-id: int\fR" 4
.IX Item "thread-id: int"
\&\s-1ID\s0 of the underlying host thread
.ie n .IP """poll\-max\-ns: int""" 4
.el .IP "\f(CWpoll\-max\-ns: int\fR" 4
.IX Item "poll-max-ns: int"
maximum polling time in ns, 0 means polling is disabled
(since 2.9)
.ie n .IP """poll\-grow: int""" 4
.el .IP "\f(CWpoll\-grow: int\fR" 4
.IX Item "poll-grow: int"
how many ns will be added to polling time, 0 means that it's not
configured (since 2.9)
.ie n .IP """poll\-shrink: int""" 4
.el .IP "\f(CWpoll\-shrink: int\fR" 4
.IX Item "poll-shrink: int"
how many ns will be removed from polling time, 0 means that
it's not configured (since 2.9)
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBquery-iothreads\fR  (Command)
Returns a list of information about each iothread.
.PP
\&\fBNote:\fR
this list excludes the \s-1QEMU\s0 main loop thread, which is not declared
using the \-object iothread command-line option.  It is always the main thread
of the process.
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`IOThreadInfo\*(C'\fR for each iothread
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBExample:\fR
.PP
.Vb 12
\&        \-> { "execute": "query\-iothreads" }
\&        <\- { "return": [
\&                 {
\&                    "id":"iothread0",
\&                    "thread\-id":3134
\&                 },
\&                 {
\&                    "id":"iothread1",
\&                    "thread\-id":3135
\&                 }
\&              ]
\&           }
.Ve
.PP
\&\fBNetworkAddressFamily\fR (Enum)
.PP
The network address family
.PP
\&\fBValues:\fR
.ie n .IP """ipv4""" 4
.el .IP "\f(CWipv4\fR" 4
.IX Item "ipv4"
\&\s-1IPV4\s0 family
.ie n .IP """ipv6""" 4
.el .IP "\f(CWipv6\fR" 4
.IX Item "ipv6"
\&\s-1IPV6\s0 family
.ie n .IP """unix""" 4
.el .IP "\f(CWunix\fR" 4
.IX Item "unix"
unix socket
.ie n .IP """vsock""" 4
.el .IP "\f(CWvsock\fR" 4
.IX Item "vsock"
vsock family (since 2.8)
.ie n .IP """unknown""" 4
.el .IP "\f(CWunknown\fR" 4
.IX Item "unknown"
otherwise
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBVncBasicInfo\fR (Object)
.PP
The basic information for vnc network connection
.PP
\&\fBMembers:\fR
.ie n .IP """host: string""" 4
.el .IP "\f(CWhost: string\fR" 4
.IX Item "host: string"
\&\s-1IP\s0 address
.ie n .IP """service: string""" 4
.el .IP "\f(CWservice: string\fR" 4
.IX Item "service: string"
The service name of the vnc port. This may depend on the host
system's service database so symbolic names should not be relied
on.
.ie n .IP """family: NetworkAddressFamily""" 4
.el .IP "\f(CWfamily: NetworkAddressFamily\fR" 4
.IX Item "family: NetworkAddressFamily"
address family
.ie n .IP """websocket: boolean""" 4
.el .IP "\f(CWwebsocket: boolean\fR" 4
.IX Item "websocket: boolean"
true in case the socket is a websocket (since 2.3).
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBVncServerInfo\fR (Object)
.PP
The network connection information for server
.PP
\&\fBMembers:\fR
.ie n .IP """auth: string"" (optional)" 4
.el .IP "\f(CWauth: string\fR (optional)" 4
.IX Item "auth: string (optional)"
authentication method used for
the plain (non-websocket) \s-1VNC\s0 server
.ie n .IP "The members of ""VncBasicInfo""" 4
.el .IP "The members of \f(CWVncBasicInfo\fR" 4
.IX Item "The members of VncBasicInfo"
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBVncClientInfo\fR (Object)
.PP
Information about a connected \s-1VNC\s0 client.
.PP
\&\fBMembers:\fR
.ie n .IP """x509_dname: string"" (optional)" 4
.el .IP "\f(CWx509_dname: string\fR (optional)" 4
.IX Item "x509_dname: string (optional)"
If x509 authentication is in use, the Distinguished
Name of the client.
.ie n .IP """sasl_username: string"" (optional)" 4
.el .IP "\f(CWsasl_username: string\fR (optional)" 4
.IX Item "sasl_username: string (optional)"
If \s-1SASL\s0 authentication is in use, the \s-1SASL\s0 username
used for authentication.
.ie n .IP "The members of ""VncBasicInfo""" 4
.el .IP "The members of \f(CWVncBasicInfo\fR" 4
.IX Item "The members of VncBasicInfo"
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBVncInfo\fR (Object)
.PP
Information about the \s-1VNC\s0 session.
.PP
\&\fBMembers:\fR
.ie n .IP """enabled: boolean""" 4
.el .IP "\f(CWenabled: boolean\fR" 4
.IX Item "enabled: boolean"
true if the \s-1VNC\s0 server is enabled, false otherwise
.ie n .IP """host: string"" (optional)" 4
.el .IP "\f(CWhost: string\fR (optional)" 4
.IX Item "host: string (optional)"
The hostname the \s-1VNC\s0 server is bound to.  This depends on
the name resolution on the host and may be an \s-1IP\s0 address.
.ie n .IP """family: NetworkAddressFamily"" (optional)" 4
.el .IP "\f(CWfamily: NetworkAddressFamily\fR (optional)" 4
.IX Item "family: NetworkAddressFamily (optional)"
\&'ipv6' if the host is listening for IPv6 connections
\&'ipv4' if the host is listening for IPv4 connections
\&'unix' if the host is listening on a unix domain socket
\&'unknown' otherwise
.ie n .IP """service: string"" (optional)" 4
.el .IP "\f(CWservice: string\fR (optional)" 4
.IX Item "service: string (optional)"
The service name of the server's port.  This may depends
on the host system's service database so symbolic names should not
be relied on.
.ie n .IP """auth: string"" (optional)" 4
.el .IP "\f(CWauth: string\fR (optional)" 4
.IX Item "auth: string (optional)"
the current authentication type used by the server
\&'none' if no authentication is being used
\&'vnc' if \s-1VNC\s0 authentication is being used
\&'vencrypt+plain' if VEncrypt is used with plain text authentication
\&'vencrypt+tls+none' if VEncrypt is used with \s-1TLS\s0 and no authentication
\&'vencrypt+tls+vnc' if VEncrypt is used with \s-1TLS\s0 and \s-1VNC\s0 authentication
\&'vencrypt+tls+plain' if VEncrypt is used with \s-1TLS\s0 and plain text auth
\&'vencrypt+x509+none' if VEncrypt is used with x509 and no auth
\&'vencrypt+x509+vnc' if VEncrypt is used with x509 and \s-1VNC\s0 auth
\&'vencrypt+x509+plain' if VEncrypt is used with x509 and plain text auth
\&'vencrypt+tls+sasl' if VEncrypt is used with \s-1TLS\s0 and \s-1SASL\s0 auth
\&'vencrypt+x509+sasl' if VEncrypt is used with x509 and \s-1SASL\s0 auth
.ie n .IP """clients: array of VncClientInfo"" (optional)" 4
.el .IP "\f(CWclients: array of VncClientInfo\fR (optional)" 4
.IX Item "clients: array of VncClientInfo (optional)"
a list of \f(CW\*(C`VncClientInfo\*(C'\fR of all currently connected clients
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBVncPrimaryAuth\fR (Enum)
.PP
vnc primary authentication method.
.PP
\&\fBValues:\fR
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
Not documented
.ie n .IP """vnc""" 4
.el .IP "\f(CWvnc\fR" 4
.IX Item "vnc"
Not documented
.ie n .IP """ra2""" 4
.el .IP "\f(CWra2\fR" 4
.IX Item "ra2"
Not documented
.ie n .IP """ra2ne""" 4
.el .IP "\f(CWra2ne\fR" 4
.IX Item "ra2ne"
Not documented
.ie n .IP """tight""" 4
.el .IP "\f(CWtight\fR" 4
.IX Item "tight"
Not documented
.ie n .IP """ultra""" 4
.el .IP "\f(CWultra\fR" 4
.IX Item "ultra"
Not documented
.ie n .IP """tls""" 4
.el .IP "\f(CWtls\fR" 4
.IX Item "tls"
Not documented
.ie n .IP """vencrypt""" 4
.el .IP "\f(CWvencrypt\fR" 4
.IX Item "vencrypt"
Not documented
.ie n .IP """sasl""" 4
.el .IP "\f(CWsasl\fR" 4
.IX Item "sasl"
Not documented
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBVncVencryptSubAuth\fR (Enum)
.PP
vnc sub authentication method with vencrypt.
.PP
\&\fBValues:\fR
.ie n .IP """plain""" 4
.el .IP "\f(CWplain\fR" 4
.IX Item "plain"
Not documented
.ie n .IP """tls\-none""" 4
.el .IP "\f(CWtls\-none\fR" 4
.IX Item "tls-none"
Not documented
.ie n .IP """x509\-none""" 4
.el .IP "\f(CWx509\-none\fR" 4
.IX Item "x509-none"
Not documented
.ie n .IP """tls\-vnc""" 4
.el .IP "\f(CWtls\-vnc\fR" 4
.IX Item "tls-vnc"
Not documented
.ie n .IP """x509\-vnc""" 4
.el .IP "\f(CWx509\-vnc\fR" 4
.IX Item "x509-vnc"
Not documented
.ie n .IP """tls\-plain""" 4
.el .IP "\f(CWtls\-plain\fR" 4
.IX Item "tls-plain"
Not documented
.ie n .IP """x509\-plain""" 4
.el .IP "\f(CWx509\-plain\fR" 4
.IX Item "x509-plain"
Not documented
.ie n .IP """tls\-sasl""" 4
.el .IP "\f(CWtls\-sasl\fR" 4
.IX Item "tls-sasl"
Not documented
.ie n .IP """x509\-sasl""" 4
.el .IP "\f(CWx509\-sasl\fR" 4
.IX Item "x509-sasl"
Not documented
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBVncServerInfo2\fR (Object)
.PP
The network connection information for server
.PP
\&\fBMembers:\fR
.ie n .IP """auth: VncPrimaryAuth""" 4
.el .IP "\f(CWauth: VncPrimaryAuth\fR" 4
.IX Item "auth: VncPrimaryAuth"
The current authentication type used by the servers
.ie n .IP """vencrypt: VncVencryptSubAuth"" (optional)" 4
.el .IP "\f(CWvencrypt: VncVencryptSubAuth\fR (optional)" 4
.IX Item "vencrypt: VncVencryptSubAuth (optional)"
The vencrypt sub authentication type used by the
servers, only specified in case auth == vencrypt.
.ie n .IP "The members of ""VncBasicInfo""" 4
.el .IP "The members of \f(CWVncBasicInfo\fR" 4
.IX Item "The members of VncBasicInfo"
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBVncInfo2\fR (Object)
.PP
Information about a vnc server
.PP
\&\fBMembers:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
vnc server name.
.ie n .IP """server: array of VncServerInfo2""" 4
.el .IP "\f(CWserver: array of VncServerInfo2\fR" 4
.IX Item "server: array of VncServerInfo2"
A list of \f(CW\*(C`VncBasincInfo\*(C'\fR describing all listening sockets.
The list can be empty (in case the vnc server is disabled).
It also may have multiple entries: normal + websocket,
possibly also ipv4 + ipv6 in the future.
.ie n .IP """clients: array of VncClientInfo""" 4
.el .IP "\f(CWclients: array of VncClientInfo\fR" 4
.IX Item "clients: array of VncClientInfo"
A list of \f(CW\*(C`VncClientInfo\*(C'\fR of all currently connected clients.
The list can be empty, for obvious reasons.
.ie n .IP """auth: VncPrimaryAuth""" 4
.el .IP "\f(CWauth: VncPrimaryAuth\fR" 4
.IX Item "auth: VncPrimaryAuth"
The current authentication type used by the non-websockets servers
.ie n .IP """vencrypt: VncVencryptSubAuth"" (optional)" 4
.el .IP "\f(CWvencrypt: VncVencryptSubAuth\fR (optional)" 4
.IX Item "vencrypt: VncVencryptSubAuth (optional)"
The vencrypt authentication type used by the servers,
only specified in case auth == vencrypt.
.ie n .IP """display: string"" (optional)" 4
.el .IP "\f(CWdisplay: string\fR (optional)" 4
.IX Item "display: string (optional)"
The display device the vnc server is linked to.
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBquery-vnc\fR  (Command)
Returns information about the current \s-1VNC\s0 server
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`VncInfo\*(C'\fR
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-vnc" }
\&        <\- { "return": {
\&                 "enabled":true,
\&                 "host":"0.0.0.0",
\&                 "service":"50402",
\&                 "auth":"vnc",
\&                 "family":"ipv4",
\&                 "clients":[
\&                    {
\&                       "host":"127.0.0.1",
\&                       "service":"50401",
\&                       "family":"ipv4"
\&                    }
\&                 ]
\&              }
\&           }
.Ve
.PP
\&\fBquery-vnc-servers\fR  (Command)
Returns a list of vnc servers.  The list can be empty.
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`VncInfo2\*(C'\fR
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBSpiceBasicInfo\fR (Object)
.PP
The basic information for \s-1SPICE\s0 network connection
.PP
\&\fBMembers:\fR
.ie n .IP """host: string""" 4
.el .IP "\f(CWhost: string\fR" 4
.IX Item "host: string"
\&\s-1IP\s0 address
.ie n .IP """port: string""" 4
.el .IP "\f(CWport: string\fR" 4
.IX Item "port: string"
port number
.ie n .IP """family: NetworkAddressFamily""" 4
.el .IP "\f(CWfamily: NetworkAddressFamily\fR" 4
.IX Item "family: NetworkAddressFamily"
address family
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBSpiceServerInfo\fR (Object)
.PP
Information about a \s-1SPICE\s0 server
.PP
\&\fBMembers:\fR
.ie n .IP """auth: string"" (optional)" 4
.el .IP "\f(CWauth: string\fR (optional)" 4
.IX Item "auth: string (optional)"
authentication method
.ie n .IP "The members of ""SpiceBasicInfo""" 4
.el .IP "The members of \f(CWSpiceBasicInfo\fR" 4
.IX Item "The members of SpiceBasicInfo"
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBSpiceChannel\fR (Object)
.PP
Information about a \s-1SPICE\s0 client channel.
.PP
\&\fBMembers:\fR
.ie n .IP """connection\-id: int""" 4
.el .IP "\f(CWconnection\-id: int\fR" 4
.IX Item "connection-id: int"
\&\s-1SPICE\s0 connection id number.  All channels with the same id
belong to the same \s-1SPICE\s0 session.
.ie n .IP """channel\-type: int""" 4
.el .IP "\f(CWchannel\-type: int\fR" 4
.IX Item "channel-type: int"
\&\s-1SPICE\s0 channel type number.  \*(L"1\*(R" is the main control
channel, filter for this one if you want to track spice
sessions only
.ie n .IP """channel\-id: int""" 4
.el .IP "\f(CWchannel\-id: int\fR" 4
.IX Item "channel-id: int"
\&\s-1SPICE\s0 channel \s-1ID\s0 number.  Usually \*(L"0\*(R", might be different when
multiple channels of the same type exist, such as multiple
display channels in a multihead setup
.ie n .IP """tls: boolean""" 4
.el .IP "\f(CWtls: boolean\fR" 4
.IX Item "tls: boolean"
true if the channel is encrypted, false otherwise.
.ie n .IP "The members of ""SpiceBasicInfo""" 4
.el .IP "The members of \f(CWSpiceBasicInfo\fR" 4
.IX Item "The members of SpiceBasicInfo"
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBSpiceQueryMouseMode\fR (Enum)
.PP
An enumeration of Spice mouse states.
.PP
\&\fBValues:\fR
.ie n .IP """client""" 4
.el .IP "\f(CWclient\fR" 4
.IX Item "client"
Mouse cursor position is determined by the client.
.ie n .IP """server""" 4
.el .IP "\f(CWserver\fR" 4
.IX Item "server"
Mouse cursor position is determined by the server.
.ie n .IP """unknown""" 4
.el .IP "\f(CWunknown\fR" 4
.IX Item "unknown"
No information is available about mouse mode used by
the spice server.
.PP
\&\fBNote:\fR
spice/enums.h has a SpiceMouseMode already, hence the name.
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBSpiceInfo\fR (Object)
.PP
Information about the \s-1SPICE\s0 session.
.PP
\&\fBMembers:\fR
.ie n .IP """enabled: boolean""" 4
.el .IP "\f(CWenabled: boolean\fR" 4
.IX Item "enabled: boolean"
true if the \s-1SPICE\s0 server is enabled, false otherwise
.ie n .IP """migrated: boolean""" 4
.el .IP "\f(CWmigrated: boolean\fR" 4
.IX Item "migrated: boolean"
true if the last guest migration completed and spice
migration had completed as well. false otherwise. (since 1.4)
.ie n .IP """host: string"" (optional)" 4
.el .IP "\f(CWhost: string\fR (optional)" 4
.IX Item "host: string (optional)"
The hostname the \s-1SPICE\s0 server is bound to.  This depends on
the name resolution on the host and may be an \s-1IP\s0 address.
.ie n .IP """port: int"" (optional)" 4
.el .IP "\f(CWport: int\fR (optional)" 4
.IX Item "port: int (optional)"
The \s-1SPICE\s0 server's port number.
.ie n .IP """compiled\-version: string"" (optional)" 4
.el .IP "\f(CWcompiled\-version: string\fR (optional)" 4
.IX Item "compiled-version: string (optional)"
\&\s-1SPICE\s0 server version.
.ie n .IP """tls\-port: int"" (optional)" 4
.el .IP "\f(CWtls\-port: int\fR (optional)" 4
.IX Item "tls-port: int (optional)"
The \s-1SPICE\s0 server's \s-1TLS\s0 port number.
.ie n .IP """auth: string"" (optional)" 4
.el .IP "\f(CWauth: string\fR (optional)" 4
.IX Item "auth: string (optional)"
the current authentication type used by the server
\&'none'  if no authentication is being used
\&'spice' uses \s-1SASL\s0 or direct \s-1TLS\s0 authentication, depending on command
line options
.ie n .IP """mouse\-mode: SpiceQueryMouseMode""" 4
.el .IP "\f(CWmouse\-mode: SpiceQueryMouseMode\fR" 4
.IX Item "mouse-mode: SpiceQueryMouseMode"
The mode in which the mouse cursor is displayed currently. Can
be determined by the client or the server, or unknown if spice
server doesn't provide this information. (since: 1.1)
.ie n .IP """channels: array of SpiceChannel"" (optional)" 4
.el .IP "\f(CWchannels: array of SpiceChannel\fR (optional)" 4
.IX Item "channels: array of SpiceChannel (optional)"
a list of \f(CW\*(C`SpiceChannel\*(C'\fR for each active spice channel
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBquery-spice\fR  (Command)
Returns information about the current \s-1SPICE\s0 server
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`SpiceInfo\*(C'\fR
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-spice" }
\&        <\- { "return": {
\&                 "enabled": true,
\&                 "auth": "spice",
\&                 "port": 5920,
\&                 "tls\-port": 5921,
\&                 "host": "0.0.0.0",
\&                 "channels": [
\&                    {
\&                       "port": "54924",
\&                       "family": "ipv4",
\&                       "channel\-type": 1,
\&                       "connection\-id": 1804289383,
\&                       "host": "127.0.0.1",
\&                       "channel\-id": 0,
\&                       "tls": true
\&                    },
\&                    {
\&                       "port": "36710",
\&                       "family": "ipv4",
\&                       "channel\-type": 4,
\&                       "connection\-id": 1804289383,
\&                       "host": "127.0.0.1",
\&                       "channel\-id": 0,
\&                       "tls": false
\&                    },
\&                    [ ... more channels follow ... ]
\&                 ]
\&              }
\&           }
.Ve
.PP
\&\fBBalloonInfo\fR (Object)
.PP
Information about the guest balloon device.
.PP
\&\fBMembers:\fR
.ie n .IP """actual: int""" 4
.el .IP "\f(CWactual: int\fR" 4
.IX Item "actual: int"
the number of bytes the balloon currently contains
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBquery-balloon\fR  (Command)
Return information about the balloon device.
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`BalloonInfo\*(C'\fR on success
.PP
If the balloon driver is enabled but not functional because the \s-1KVM\s0
kernel module cannot support it, KvmMissingCap
.PP
If no balloon device is present, DeviceNotActive
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "query\-balloon" }
\&        <\- { "return": {
\&                 "actual": 1073741824,
\&              }
\&           }
.Ve
.PP
\&\fBPciMemoryRange\fR (Object)
.PP
A \s-1PCI\s0 device memory region
.PP
\&\fBMembers:\fR
.ie n .IP """base: int""" 4
.el .IP "\f(CWbase: int\fR" 4
.IX Item "base: int"
the starting address (guest physical)
.ie n .IP """limit: int""" 4
.el .IP "\f(CWlimit: int\fR" 4
.IX Item "limit: int"
the ending address (guest physical)
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBPciMemoryRegion\fR (Object)
.PP
Information about a \s-1PCI\s0 device I/O region.
.PP
\&\fBMembers:\fR
.ie n .IP """bar: int""" 4
.el .IP "\f(CWbar: int\fR" 4
.IX Item "bar: int"
the index of the Base Address Register for this region
.ie n .IP """type: string""" 4
.el .IP "\f(CWtype: string\fR" 4
.IX Item "type: string"
\&'io' if the region is a \s-1PIO\s0 region
\&'memory' if the region is a \s-1MMIO\s0 region
.ie n .IP """size: int""" 4
.el .IP "\f(CWsize: int\fR" 4
.IX Item "size: int"
memory size
.ie n .IP """prefetch: boolean"" (optional)" 4
.el .IP "\f(CWprefetch: boolean\fR (optional)" 4
.IX Item "prefetch: boolean (optional)"
if \f(CW\*(C`type\*(C'\fR is 'memory', true if the memory is prefetchable
.ie n .IP """mem_type_64: boolean"" (optional)" 4
.el .IP "\f(CWmem_type_64: boolean\fR (optional)" 4
.IX Item "mem_type_64: boolean (optional)"
if \f(CW\*(C`type\*(C'\fR is 'memory', true if the \s-1BAR\s0 is 64\-bit
.ie n .IP """address: int""" 4
.el .IP "\f(CWaddress: int\fR" 4
.IX Item "address: int"
Not documented
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBPciBusInfo\fR (Object)
.PP
Information about a bus of a \s-1PCI\s0 Bridge device
.PP
\&\fBMembers:\fR
.ie n .IP """number: int""" 4
.el .IP "\f(CWnumber: int\fR" 4
.IX Item "number: int"
primary bus interface number.  This should be the number of the
bus the device resides on.
.ie n .IP """secondary: int""" 4
.el .IP "\f(CWsecondary: int\fR" 4
.IX Item "secondary: int"
secondary bus interface number.  This is the number of the
main bus for the bridge
.ie n .IP """subordinate: int""" 4
.el .IP "\f(CWsubordinate: int\fR" 4
.IX Item "subordinate: int"
This is the highest number bus that resides below the
bridge.
.ie n .IP """io_range: PciMemoryRange""" 4
.el .IP "\f(CWio_range: PciMemoryRange\fR" 4
.IX Item "io_range: PciMemoryRange"
The \s-1PIO\s0 range for all devices on this bridge
.ie n .IP """memory_range: PciMemoryRange""" 4
.el .IP "\f(CWmemory_range: PciMemoryRange\fR" 4
.IX Item "memory_range: PciMemoryRange"
The \s-1MMIO\s0 range for all devices on this bridge
.ie n .IP """prefetchable_range: PciMemoryRange""" 4
.el .IP "\f(CWprefetchable_range: PciMemoryRange\fR" 4
.IX Item "prefetchable_range: PciMemoryRange"
The range of prefetchable \s-1MMIO\s0 for all devices on
this bridge
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBPciBridgeInfo\fR (Object)
.PP
Information about a \s-1PCI\s0 Bridge device
.PP
\&\fBMembers:\fR
.ie n .IP """bus: PciBusInfo""" 4
.el .IP "\f(CWbus: PciBusInfo\fR" 4
.IX Item "bus: PciBusInfo"
information about the bus the device resides on
.ie n .IP """devices: array of PciDeviceInfo"" (optional)" 4
.el .IP "\f(CWdevices: array of PciDeviceInfo\fR (optional)" 4
.IX Item "devices: array of PciDeviceInfo (optional)"
a list of \f(CW\*(C`PciDeviceInfo\*(C'\fR for each device on this bridge
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBPciDeviceClass\fR (Object)
.PP
Information about the Class of a \s-1PCI\s0 device
.PP
\&\fBMembers:\fR
.ie n .IP """desc: string"" (optional)" 4
.el .IP "\f(CWdesc: string\fR (optional)" 4
.IX Item "desc: string (optional)"
a string description of the device's class
.ie n .IP """class: int""" 4
.el .IP "\f(CWclass: int\fR" 4
.IX Item "class: int"
the class code of the device
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBPciDeviceId\fR (Object)
.PP
Information about the Id of a \s-1PCI\s0 device
.PP
\&\fBMembers:\fR
.ie n .IP """device: int""" 4
.el .IP "\f(CWdevice: int\fR" 4
.IX Item "device: int"
the \s-1PCI\s0 device id
.ie n .IP """vendor: int""" 4
.el .IP "\f(CWvendor: int\fR" 4
.IX Item "vendor: int"
the \s-1PCI\s0 vendor id
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBPciDeviceInfo\fR (Object)
.PP
Information about a \s-1PCI\s0 device
.PP
\&\fBMembers:\fR
.ie n .IP """bus: int""" 4
.el .IP "\f(CWbus: int\fR" 4
.IX Item "bus: int"
the bus number of the device
.ie n .IP """slot: int""" 4
.el .IP "\f(CWslot: int\fR" 4
.IX Item "slot: int"
the slot the device is located in
.ie n .IP """function: int""" 4
.el .IP "\f(CWfunction: int\fR" 4
.IX Item "function: int"
the function of the slot used by the device
.ie n .IP """class_info: PciDeviceClass""" 4
.el .IP "\f(CWclass_info: PciDeviceClass\fR" 4
.IX Item "class_info: PciDeviceClass"
the class of the device
.ie n .IP """id: PciDeviceId""" 4
.el .IP "\f(CWid: PciDeviceId\fR" 4
.IX Item "id: PciDeviceId"
the \s-1PCI\s0 device id
.ie n .IP """irq: int"" (optional)" 4
.el .IP "\f(CWirq: int\fR (optional)" 4
.IX Item "irq: int (optional)"
if an \s-1IRQ\s0 is assigned to the device, the \s-1IRQ\s0 number
.ie n .IP """qdev_id: string""" 4
.el .IP "\f(CWqdev_id: string\fR" 4
.IX Item "qdev_id: string"
the device name of the \s-1PCI\s0 device
.ie n .IP """pci_bridge: PciBridgeInfo"" (optional)" 4
.el .IP "\f(CWpci_bridge: PciBridgeInfo\fR (optional)" 4
.IX Item "pci_bridge: PciBridgeInfo (optional)"
if the device is a \s-1PCI\s0 bridge, the bridge information
.ie n .IP """regions: array of PciMemoryRegion""" 4
.el .IP "\f(CWregions: array of PciMemoryRegion\fR" 4
.IX Item "regions: array of PciMemoryRegion"
a list of the \s-1PCI I/O\s0 regions associated with the device
.PP
\&\fBNotes:\fR
the contents of \f(CW\*(C`class_info\*(C'\fR.desc are not stable and should only be
treated as informational.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBPciInfo\fR (Object)
.PP
Information about a \s-1PCI\s0 bus
.PP
\&\fBMembers:\fR
.ie n .IP """bus: int""" 4
.el .IP "\f(CWbus: int\fR" 4
.IX Item "bus: int"
the bus index
.ie n .IP """devices: array of PciDeviceInfo""" 4
.el .IP "\f(CWdevices: array of PciDeviceInfo\fR" 4
.IX Item "devices: array of PciDeviceInfo"
a list of devices on this bus
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBquery-pci\fR  (Command)
Return information about the \s-1PCI\s0 bus topology of the guest.
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`PciInfo\*(C'\fR for each \s-1PCI\s0 bus. Each bus is
represented by a json-object, which has a key with a json-array of
all \s-1PCI\s0 devices attached to it. Each device is represented by a
json-object.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-pci" }
\&        <\- { "return": [
\&                 {
\&                    "bus": 0,
\&                    "devices": [
\&                       {
\&                          "bus": 0,
\&                          "qdev_id": "",
\&                          "slot": 0,
\&                          "class_info": {
\&                             "class": 1536,
\&                             "desc": "Host bridge"
\&                          },
\&                          "id": {
\&                             "device": 32902,
\&                             "vendor": 4663
\&                          },
\&                          "function": 0,
\&                          "regions": [
\&                          ]
\&                       },
\&                       {
\&                          "bus": 0,
\&                          "qdev_id": "",
\&                          "slot": 1,
\&                          "class_info": {
\&                             "class": 1537,
\&                             "desc": "ISA bridge"
\&                          },
\&                          "id": {
\&                             "device": 32902,
\&                             "vendor": 28672
\&                          },
\&                          "function": 0,
\&                          "regions": [
\&                          ]
\&                       },
\&                       {
\&                          "bus": 0,
\&                          "qdev_id": "",
\&                          "slot": 1,
\&                          "class_info": {
\&                             "class": 257,
\&                             "desc": "IDE controller"
\&                          },
\&                          "id": {
\&                             "device": 32902,
\&                             "vendor": 28688
\&                          },
\&                          "function": 1,
\&                          "regions": [
\&                             {
\&                                "bar": 4,
\&                                "size": 16,
\&                                "address": 49152,
\&                                "type": "io"
\&                             }
\&                          ]
\&                       },
\&                       {
\&                          "bus": 0,
\&                          "qdev_id": "",
\&                          "slot": 2,
\&                          "class_info": {
\&                             "class": 768,
\&                             "desc": "VGA controller"
\&                          },
\&                          "id": {
\&                             "device": 4115,
\&                             "vendor": 184
\&                          },
\&                          "function": 0,
\&                          "regions": [
\&                             {
\&                                "prefetch": true,
\&                                "mem_type_64": false,
\&                                "bar": 0,
\&                                "size": 33554432,
\&                                "address": 4026531840,
\&                                "type": "memory"
\&                             },
\&                             {
\&                                "prefetch": false,
\&                                "mem_type_64": false,
\&                                "bar": 1,
\&                                "size": 4096,
\&                                "address": 4060086272,
\&                                "type": "memory"
\&                             },
\&                             {
\&                                "prefetch": false,
\&                                "mem_type_64": false,
\&                                "bar": 6,
\&                                "size": 65536,
\&                                "address": \-1,
\&                                "type": "memory"
\&                             }
\&                          ]
\&                       },
\&                       {
\&                          "bus": 0,
\&                          "qdev_id": "",
\&                          "irq": 11,
\&                          "slot": 4,
\&                          "class_info": {
\&                             "class": 1280,
\&                             "desc": "RAM controller"
\&                          },
\&                          "id": {
\&                             "device": 6900,
\&                             "vendor": 4098
\&                          },
\&                          "function": 0,
\&                          "regions": [
\&                             {
\&                                "bar": 0,
\&                                "size": 32,
\&                                "address": 49280,
\&                                "type": "io"
\&                             }
\&                          ]
\&                       }
\&                    ]
\&                 }
\&              ]
\&           }
.Ve
.PP
\&\fBNote:\fR
This example has been shortened as the real response is too long.
.PP
\&\fBquit\fR  (Command)
This command will cause the \s-1QEMU\s0 process to exit gracefully.  While every
attempt is made to send the \s-1QMP\s0 response before terminating, this is not
guaranteed.  When using this interface, a premature \s-1EOF\s0 would not be
unexpected.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "quit" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBstop\fR  (Command)
Stop all guest \s-1VCPU\s0 execution.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
This function will succeed even if the guest is already in the stopped
state.  In \*(L"inmigrate\*(R" state, it will ensure that the guest
remains paused once migration finishes, as if the \-S option was
passed on the command line.
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "stop" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBsystem_reset\fR  (Command)
Performs a hard reset of a guest.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "system_reset" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBsystem_powerdown\fR  (Command)
Requests that a guest perform a powerdown operation.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
A guest may or may not respond to this command.  This command
returning does not indicate that a guest has accepted the request or
that it has shut down.  Many guests will respond to this command by
prompting the user in some way.
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "system_powerdown" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBcpu\fR  (Command)
This command is a nop that is only provided for the purposes of compatibility.
.PP
\&\fBArguments:\fR
.ie n .IP """index: int""" 4
.el .IP "\f(CWindex: int\fR" 4
.IX Item "index: int"
Not documented
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
Do not use this command.
.PP
\&\fBcpu-add\fR  (Command)
Adds \s-1CPU\s0 with specified \s-1ID\s0
.PP
\&\fBArguments:\fR
.ie n .IP """id: int""" 4
.el .IP "\f(CWid: int\fR" 4
.IX Item "id: int"
\&\s-1ID\s0 of \s-1CPU\s0 to be created, valid values [0..max_cpus)
.PP
\&\fBReturns:\fR
Nothing on success
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "cpu\-add", "arguments": { "id": 2 } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBmemsave\fR  (Command)
Save a portion of guest memory to a file.
.PP
\&\fBArguments:\fR
.ie n .IP """val: int""" 4
.el .IP "\f(CWval: int\fR" 4
.IX Item "val: int"
the virtual address of the guest to start from
.ie n .IP """size: int""" 4
.el .IP "\f(CWsize: int\fR" 4
.IX Item "size: int"
the size of memory region to save
.ie n .IP """filename: string""" 4
.el .IP "\f(CWfilename: string\fR" 4
.IX Item "filename: string"
the file to save the memory to as binary data
.ie n .IP """cpu\-index: int"" (optional)" 4
.el .IP "\f(CWcpu\-index: int\fR (optional)" 4
.IX Item "cpu-index: int (optional)"
the index of the virtual \s-1CPU\s0 to use for translating the
virtual address (defaults to \s-1CPU 0\s0)
.PP
\&\fBReturns:\fR
Nothing on success
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
Errors were not reliably returned until 1.1
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "memsave",
\&             "arguments": { "val": 10,
\&                            "size": 100,
\&                            "filename": "/tmp/virtual\-mem\-dump" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBpmemsave\fR  (Command)
Save a portion of guest physical memory to a file.
.PP
\&\fBArguments:\fR
.ie n .IP """val: int""" 4
.el .IP "\f(CWval: int\fR" 4
.IX Item "val: int"
the physical address of the guest to start from
.ie n .IP """size: int""" 4
.el .IP "\f(CWsize: int\fR" 4
.IX Item "size: int"
the size of memory region to save
.ie n .IP """filename: string""" 4
.el .IP "\f(CWfilename: string\fR" 4
.IX Item "filename: string"
the file to save the memory to as binary data
.PP
\&\fBReturns:\fR
Nothing on success
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
Errors were not reliably returned until 1.1
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "pmemsave",
\&             "arguments": { "val": 10,
\&                            "size": 100,
\&                            "filename": "/tmp/physical\-mem\-dump" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBcont\fR  (Command)
Resume guest \s-1VCPU\s0 execution.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBReturns:\fR
If successful, nothing
.PP
\&\fBNotes:\fR
This command will succeed if the guest is currently running.  It
will also succeed if the guest is in the \*(L"inmigrate\*(R" state; in
this case, the effect of the command is to make sure the guest
starts once migration finishes, removing the effect of the \-S
command line option if it was passed.
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "cont" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBsystem_wakeup\fR  (Command)
Wakeup guest from suspend.  Does nothing in case the guest isn't suspended.
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBReturns:\fR
nothing.
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "system_wakeup" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBinject-nmi\fR  (Command)
Injects a Non-Maskable Interrupt into the default \s-1CPU \s0(x86/s390) or all CPUs (ppc64).
The command fails when the guest doesn't support injecting.
.PP
\&\fBReturns:\fR
If successful, nothing
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNote:\fR
prior to 2.1, this command was only supported for x86 and s390 VMs
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "inject\-nmi" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBset_link\fR  (Command)
Sets the link status of a virtual network adapter.
.PP
\&\fBArguments:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
the device name of the virtual network adapter
.ie n .IP """up: boolean""" 4
.el .IP "\f(CWup: boolean\fR" 4
.IX Item "up: boolean"
true to set the link status to be up
.PP
\&\fBReturns:\fR
Nothing on success
If \f(CW\*(C`name\*(C'\fR is not a valid network device, DeviceNotFound
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
Not all network adapters support setting link status.  This command
will succeed even if the network adapter does not support link status
notification.
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "set_link",
\&             "arguments": { "name": "e1000.0", "up": false } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBballoon\fR  (Command)
Request the balloon driver to change its balloon size.
.PP
\&\fBArguments:\fR
.ie n .IP """value: int""" 4
.el .IP "\f(CWvalue: int\fR" 4
.IX Item "value: int"
the target size of the balloon in bytes
.PP
\&\fBReturns:\fR
Nothing on success
If the balloon driver is enabled but not functional because the \s-1KVM\s0
kernel module cannot support it, KvmMissingCap
If no balloon device is present, DeviceNotActive
.PP
\&\fBNotes:\fR
This command just issues a request to the guest.  When it returns,
the balloon size may not have changed.  A guest can change the balloon
size independent of this command.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "balloon", "arguments": { "value": 536870912 } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBAbort\fR (Object)
.PP
This action can be used to test transaction failure.
.PP
\&\fBSince:\fR
1.6
.PP
\&\fBActionCompletionMode\fR (Enum)
.PP
An enumeration of Transactional completion modes.
.PP
\&\fBValues:\fR
.ie n .IP """individual""" 4
.el .IP "\f(CWindividual\fR" 4
.IX Item "individual"
Do not attempt to cancel any other Actions if any Actions fail
after the Transaction request succeeds. All Actions that
can complete successfully will do so without waiting on others.
This is the default.
.ie n .IP """grouped""" 4
.el .IP "\f(CWgrouped\fR" 4
.IX Item "grouped"
If any Action fails after the Transaction succeeds, cancel all
Actions. Actions do not complete until all Actions are ready to
complete. May be rejected by Actions that do not support this
completion mode.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBTransactionAction\fR (Object)
.PP
A discriminated record of operations that can be performed with
\&\f(CW\*(C`transaction\*(C'\fR. Action \f(CW\*(C`type\*(C'\fR can be:
.IP "\-" 4
\&\f(CW\*(C`abort\*(C'\fR: since 1.6
.IP "\-" 4
\&\f(CW\*(C`block\-dirty\-bitmap\-add\*(C'\fR: since 2.5
.IP "\-" 4
\&\f(CW\*(C`block\-dirty\-bitmap\-clear\*(C'\fR: since 2.5
.IP "\-" 4
\&\f(CW\*(C`blockdev\-backup\*(C'\fR: since 2.3
.IP "\-" 4
\&\f(CW\*(C`blockdev\-snapshot\*(C'\fR: since 2.5
.IP "\-" 4
\&\f(CW\*(C`blockdev\-snapshot\-internal\-sync\*(C'\fR: since 1.7
.IP "\-" 4
\&\f(CW\*(C`blockdev\-snapshot\-sync\*(C'\fR: since 1.1
.IP "\-" 4
\&\f(CW\*(C`drive\-backup\*(C'\fR: since 1.6
.PP
\&\fBMembers:\fR
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
One of \*(L"abort\*(R", \*(L"block-dirty-bitmap-add\*(R", \*(L"block-dirty-bitmap-clear\*(R", \*(L"blockdev-backup\*(R", \*(L"blockdev-snapshot\*(R", \*(L"blockdev-snapshot-internal-sync\*(R", \*(L"blockdev-snapshot-sync\*(R", \*(L"drive-backup\*(R"
.ie n .IP """data: Abort"" when ""type"" is ""abort""" 4
.el .IP "\f(CWdata: Abort\fR when \f(CWtype\fR is ``abort''" 4
.IX Item "data: Abort when type is abort"
.PD 0
.ie n .IP """data: BlockDirtyBitmapAdd"" when ""type"" is ""block-dirty-bitmap-add""" 4
.el .IP "\f(CWdata: BlockDirtyBitmapAdd\fR when \f(CWtype\fR is ``block-dirty-bitmap-add''" 4
.IX Item "data: BlockDirtyBitmapAdd when type is block-dirty-bitmap-add"
.ie n .IP """data: BlockDirtyBitmap"" when ""type"" is ""block-dirty-bitmap-clear""" 4
.el .IP "\f(CWdata: BlockDirtyBitmap\fR when \f(CWtype\fR is ``block-dirty-bitmap-clear''" 4
.IX Item "data: BlockDirtyBitmap when type is block-dirty-bitmap-clear"
.ie n .IP """data: BlockdevBackup"" when ""type"" is ""blockdev-backup""" 4
.el .IP "\f(CWdata: BlockdevBackup\fR when \f(CWtype\fR is ``blockdev-backup''" 4
.IX Item "data: BlockdevBackup when type is blockdev-backup"
.ie n .IP """data: BlockdevSnapshot"" when ""type"" is ""blockdev-snapshot""" 4
.el .IP "\f(CWdata: BlockdevSnapshot\fR when \f(CWtype\fR is ``blockdev-snapshot''" 4
.IX Item "data: BlockdevSnapshot when type is blockdev-snapshot"
.ie n .IP """data: BlockdevSnapshotInternal"" when ""type"" is ""blockdev-snapshot-internal-sync""" 4
.el .IP "\f(CWdata: BlockdevSnapshotInternal\fR when \f(CWtype\fR is ``blockdev-snapshot-internal-sync''" 4
.IX Item "data: BlockdevSnapshotInternal when type is blockdev-snapshot-internal-sync"
.ie n .IP """data: BlockdevSnapshotSync"" when ""type"" is ""blockdev-snapshot-sync""" 4
.el .IP "\f(CWdata: BlockdevSnapshotSync\fR when \f(CWtype\fR is ``blockdev-snapshot-sync''" 4
.IX Item "data: BlockdevSnapshotSync when type is blockdev-snapshot-sync"
.ie n .IP """data: DriveBackup"" when ""type"" is ""drive-backup""" 4
.el .IP "\f(CWdata: DriveBackup\fR when \f(CWtype\fR is ``drive-backup''" 4
.IX Item "data: DriveBackup when type is drive-backup"
.PD
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBTransactionProperties\fR (Object)
.PP
Optional arguments to modify the behavior of a Transaction.
.PP
\&\fBMembers:\fR
.ie n .IP """completion\-mode: ActionCompletionMode"" (optional)" 4
.el .IP "\f(CWcompletion\-mode: ActionCompletionMode\fR (optional)" 4
.IX Item "completion-mode: ActionCompletionMode (optional)"
Controls how jobs launched asynchronously by
Actions will complete or fail as a group.
See \f(CW\*(C`ActionCompletionMode\*(C'\fR for details.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBtransaction\fR  (Command)
Executes a number of transactionable \s-1QMP\s0 commands atomically. If any
operation fails, then the entire set of actions will be abandoned and the
appropriate error returned.
.PP
For external snapshots, the dictionary contains the device, the file to use for
the new snapshot, and the format.  The default format, if not specified, is
qcow2.
.PP
Each new snapshot defaults to being created by \s-1QEMU \s0(wiping any
contents if the file already exists), but it is also possible to reuse
an externally-created file.  In the latter case, you should ensure that
the new image file has the same contents as the current one; \s-1QEMU\s0 cannot
perform any meaningful check.  Typically this is achieved by using the
current image file as the backing file for the new image.
.PP
On failure, the original disks pre-snapshot attempt will be used.
.PP
For internal snapshots, the dictionary contains the device and the snapshot's
name.  If an internal snapshot matching name already exists, the request will
be rejected.  Only some image formats support it, for example, qcow2, rbd,
and sheepdog.
.PP
On failure, qemu will try delete the newly created internal snapshot in the
transaction.  When an I/O error occurs during deletion, the user needs to fix
it later with qemu-img or other command.
.PP
\&\fBArguments:\fR
.ie n .IP """actions: array of TransactionAction""" 4
.el .IP "\f(CWactions: array of TransactionAction\fR" 4
.IX Item "actions: array of TransactionAction"
List of \f(CW\*(C`TransactionAction\*(C'\fR;
information needed for the respective operations.
.ie n .IP """properties: TransactionProperties"" (optional)" 4
.el .IP "\f(CWproperties: TransactionProperties\fR (optional)" 4
.IX Item "properties: TransactionProperties (optional)"
structure of additional options to control the
execution of the transaction. See \f(CW\*(C`TransactionProperties\*(C'\fR
for additional detail.
.PP
\&\fBReturns:\fR
nothing on success
.PP
Errors depend on the operations of the transaction
.PP
\&\fBNote:\fR
The transaction aborts on the first failure.  Therefore, there will be
information on only one failed operation returned in an error condition, and
subsequent actions will not have been attempted.
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "transaction",
\&             "arguments": { "actions": [
\&                 { "type": "blockdev\-snapshot\-sync", "data" : { "device": "ide\-hd0",
\&                                             "snapshot\-file": "/some/place/my\-image",
\&                                             "format": "qcow2" } },
\&                 { "type": "blockdev\-snapshot\-sync", "data" : { "node\-name": "myfile",
\&                                             "snapshot\-file": "/some/place/my\-image2",
\&                                             "snapshot\-node\-name": "node3432",
\&                                             "mode": "existing",
\&                                             "format": "qcow2" } },
\&                 { "type": "blockdev\-snapshot\-sync", "data" : { "device": "ide\-hd1",
\&                                             "snapshot\-file": "/some/place/my\-image2",
\&                                             "mode": "existing",
\&                                             "format": "qcow2" } },
\&                 { "type": "blockdev\-snapshot\-internal\-sync", "data" : {
\&                                             "device": "ide\-hd2",
\&                                             "name": "snapshot0" } } ] } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBhuman-monitor-command\fR  (Command)
Execute a command on the human monitor and return the output.
.PP
\&\fBArguments:\fR
.ie n .IP """command\-line: string""" 4
.el .IP "\f(CWcommand\-line: string\fR" 4
.IX Item "command-line: string"
the command to execute in the human monitor
.ie n .IP """cpu\-index: int"" (optional)" 4
.el .IP "\f(CWcpu\-index: int\fR (optional)" 4
.IX Item "cpu-index: int (optional)"
The \s-1CPU\s0 to use for commands that require an implicit \s-1CPU\s0
.PP
\&\fBReturns:\fR
the output of the command as a string
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
This command only exists as a stop-gap.  Its use is highly
discouraged.  The semantics of this command are not
guaranteed: this means that command names, arguments and
responses can change or be removed at \s-1ANY\s0 time.  Applications
that rely on long term stability guarantees should \s-1NOT\s0
use this command.
.PP
Known limitations:
.IP "\(bu" 4
This command is stateless, this means that commands that depend
on state information (such as getfd) might not work
.IP "\(bu" 4
Commands that prompt the user for data don't currently work
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "human\-monitor\-command",
\&             "arguments": { "command\-line": "info kvm" } }
\&        <\- { "return": "kvm support: enabled\er\en" }
.Ve
.PP
\&\fBmigrate_cancel\fR  (Command)
Cancel the current executing migration process.
.PP
\&\fBReturns:\fR
nothing on success
.PP
\&\fBNotes:\fR
This command succeeds even if there is no migration process running.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "migrate_cancel" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBmigrate_set_downtime\fR  (Command)
Set maximum tolerated downtime for migration.
.PP
\&\fBArguments:\fR
.ie n .IP """value: number""" 4
.el .IP "\f(CWvalue: number\fR" 4
.IX Item "value: number"
maximum downtime in seconds
.PP
\&\fBReturns:\fR
nothing on success
.PP
\&\fBNotes:\fR
This command is deprecated in favor of 'migrate\-set\-parameters'
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "migrate_set_downtime", "arguments": { "value": 0.1 } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBmigrate_set_speed\fR  (Command)
Set maximum speed for migration.
.PP
\&\fBArguments:\fR
.ie n .IP """value: int""" 4
.el .IP "\f(CWvalue: int\fR" 4
.IX Item "value: int"
maximum speed in bytes per second.
.PP
\&\fBReturns:\fR
nothing on success
.PP
\&\fBNotes:\fR
This command is deprecated in favor of 'migrate\-set\-parameters'
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "migrate_set_speed", "arguments": { "value": 1024 } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBmigrate-set-cache-size\fR  (Command)
Set cache size to be used by \s-1XBZRLE\s0 migration
.PP
\&\fBArguments:\fR
.ie n .IP """value: int""" 4
.el .IP "\f(CWvalue: int\fR" 4
.IX Item "value: int"
cache size in bytes
.PP
The size will be rounded down to the nearest power of 2.
The cache size can be modified before and during ongoing migration
.PP
\&\fBReturns:\fR
nothing on success
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "migrate\-set\-cache\-size",
\&             "arguments": { "value": 536870912 } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBquery-migrate-cache-size\fR  (Command)
Query migration \s-1XBZRLE\s0 cache size
.PP
\&\fBReturns:\fR
\&\s-1XBZRLE\s0 cache size in bytes
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "query\-migrate\-cache\-size" }
\&        <\- { "return": 67108864 }
.Ve
.PP
\&\fBObjectPropertyInfo\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
the name of the property
.ie n .IP """type: string""" 4
.el .IP "\f(CWtype: string\fR" 4
.IX Item "type: string"
the type of the property.  This will typically come in one of four
forms:
.Sp
1) A primitive type such as 'u8', 'u16', 'bool', 'str', or 'double'.
These types are mapped to the appropriate \s-1JSON\s0 type.
.Sp
2) A child type in the form 'child<subtype>' where subtype is a qdev
device type name.  Child properties create the composition tree.
.Sp
3) A link type in the form 'link<subtype>' where subtype is a qdev
device type name.  Link properties form the device model graph.
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBqom-list\fR  (Command)
This command will list any properties of a object given a path in the object
model.
.PP
\&\fBArguments:\fR
.ie n .IP """path: string""" 4
.el .IP "\f(CWpath: string\fR" 4
.IX Item "path: string"
the path within the object model.  See \f(CW\*(C`qom\-get\*(C'\fR for a description of
this parameter.
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`ObjectPropertyInfo\*(C'\fR that describe the properties of the
object.
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBqom-get\fR  (Command)
This command will get a property from a object model path and return the
value.
.PP
\&\fBArguments:\fR
.ie n .IP """path: string""" 4
.el .IP "\f(CWpath: string\fR" 4
.IX Item "path: string"
The path within the object model.  There are two forms of supported
paths\*(--absolute and partial paths.
.Sp
Absolute paths are derived from the root object and can follow child<>
or link<> properties.  Since they can follow link<> properties, they
can be arbitrarily long.  Absolute paths look like absolute filenames
and are prefixed  with a leading slash.
.Sp
Partial paths look like relative filenames.  They do not begin
with a prefix.  The matching rules for partial paths are subtle but
designed to make specifying objects easy.  At each level of the
composition tree, the partial path is matched as an absolute path.
The first match is not returned.  At least two matches are searched
for.  A successful result is only returned if only one match is
found.  If more than one match is found, a flag is return to
indicate that the match was ambiguous.
.ie n .IP """property: string""" 4
.el .IP "\f(CWproperty: string\fR" 4
.IX Item "property: string"
The property name to read
.PP
\&\fBReturns:\fR
The property value.  The type depends on the property
type. child<> and link<> properties are returned as #str
pathnames.  All integer property types (u8, u16, etc) are
returned as #int.
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBqom-set\fR  (Command)
This command will set a property from a object model path.
.PP
\&\fBArguments:\fR
.ie n .IP """path: string""" 4
.el .IP "\f(CWpath: string\fR" 4
.IX Item "path: string"
see \f(CW\*(C`qom\-get\*(C'\fR for a description of this parameter
.ie n .IP """property: string""" 4
.el .IP "\f(CWproperty: string\fR" 4
.IX Item "property: string"
the property name to set
.ie n .IP """value: value""" 4
.el .IP "\f(CWvalue: value\fR" 4
.IX Item "value: value"
a value who's type is appropriate for the property type.  See \f(CW\*(C`qom\-get\*(C'\fR
for a description of type mapping.
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBset_password\fR  (Command)
Sets the password of a remote display session.
.PP
\&\fBArguments:\fR
.ie n .IP """protocol: string""" 4
.el .IP "\f(CWprotocol: string\fR" 4
.IX Item "protocol: string"
`vnc' to modify the \s-1VNC\s0 server password
`spice' to modify the Spice server password
.ie n .IP """password: string""" 4
.el .IP "\f(CWpassword: string\fR" 4
.IX Item "password: string"
the new password
.ie n .IP """connected: string"" (optional)" 4
.el .IP "\f(CWconnected: string\fR (optional)" 4
.IX Item "connected: string (optional)"
how to handle existing clients when changing the
password.  If nothing is specified, defaults to `keep'
`fail' to fail the command if clients are connected
`disconnect' to disconnect existing clients
`keep' to maintain existing clients
.PP
\&\fBReturns:\fR
Nothing on success
If Spice is not enabled, DeviceNotFound
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "set_password", "arguments": { "protocol": "vnc",
\&                                                       "password": "secret" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBexpire_password\fR  (Command)
Expire the password of a remote display server.
.PP
\&\fBArguments:\fR
.ie n .IP """protocol: string""" 4
.el .IP "\f(CWprotocol: string\fR" 4
.IX Item "protocol: string"
the name of the remote display protocol `vnc' or `spice'
.ie n .IP """time: string""" 4
.el .IP "\f(CWtime: string\fR" 4
.IX Item "time: string"
when to expire the password.
`now' to expire the password immediately
`never' to cancel password expiration
`+INT' where \s-1INT\s0 is the number of seconds from now (integer)
`\s-1INT\s0' where \s-1INT\s0 is the absolute time in seconds
.PP
\&\fBReturns:\fR
Nothing on success
If \f(CW\*(C`protocol\*(C'\fR is `spice' and Spice is not active, DeviceNotFound
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
Time is relative to the server and currently there is no way to
coordinate server time with client time.  It is not recommended to
use the absolute time version of the \f(CW\*(C`time\*(C'\fR parameter unless you're
sure you are on the same machine as the \s-1QEMU\s0 instance.
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "expire_password", "arguments": { "protocol": "vnc",
\&                                                          "time": "+60" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBchange-vnc-password\fR  (Command)
Change the \s-1VNC\s0 server password.
.PP
\&\fBArguments:\fR
.ie n .IP """password: string""" 4
.el .IP "\f(CWpassword: string\fR" 4
.IX Item "password: string"
the new password to use with \s-1VNC\s0 authentication
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBNotes:\fR
An empty password in this command will set the password to the empty
string.  Existing clients are unaffected by executing this command.
.PP
\&\fBchange\fR  (Command)
This command is multiple commands multiplexed together.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
This is normally the name of a block device but it may also be 'vnc'.
when it's 'vnc', then sub command depends on \f(CW\*(C`target\*(C'\fR
.ie n .IP """target: string""" 4
.el .IP "\f(CWtarget: string\fR" 4
.IX Item "target: string"
If \f(CW\*(C`device\*(C'\fR is a block device, then this is the new filename.
If \f(CW\*(C`device\*(C'\fR is 'vnc', then if the value 'password' selects the vnc
change password command.   Otherwise, this specifies a new server \s-1URI\s0
address to listen to for \s-1VNC\s0 connections.
.ie n .IP """arg: string"" (optional)" 4
.el .IP "\f(CWarg: string\fR (optional)" 4
.IX Item "arg: string (optional)"
If \f(CW\*(C`device\*(C'\fR is a block device, then this is an optional format to open
the device with.
If \f(CW\*(C`device\*(C'\fR is 'vnc' and \f(CW\*(C`target\*(C'\fR is 'password', this is the new \s-1VNC\s0
password to set.  See change-vnc-password for additional notes.
.PP
\&\fBReturns:\fR
Nothing on success.
If \f(CW\*(C`device\*(C'\fR is not a valid block device, DeviceNotFound
.PP
\&\fBNotes:\fR
This interface is deprecated, and it is strongly recommended that you
avoid using it.  For changing block devices, use
blockdev-change-medium; for changing \s-1VNC\s0 parameters, use
change-vnc-password.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&        1. Change a removable medium
\&        
\&        \-> { "execute": "change",
\&             "arguments": { "device": "ide1\-cd0",
\&                            "target": "/srv/images/Fedora\-12\-x86_64\-DVD.iso" } }
\&        <\- { "return": {} }
\&        
\&        2. Change VNC password
\&        
\&        \-> { "execute": "change",
\&             "arguments": { "device": "vnc", "target": "password",
\&                            "arg": "foobar1" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBObjectTypeInfo\fR (Object)
.PP
This structure describes a search result from \f(CW\*(C`qom\-list\-types\*(C'\fR
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
the type name found in the search
.ie n .IP """abstract: boolean"" (optional)" 4
.el .IP "\f(CWabstract: boolean\fR (optional)" 4
.IX Item "abstract: boolean (optional)"
the type is abstract and can't be directly instantiated.
Omitted if false. (since 2.10)
.ie n .IP """parent: string"" (optional)" 4
.el .IP "\f(CWparent: string\fR (optional)" 4
.IX Item "parent: string (optional)"
Name of parent type, if any (since 2.10)
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBqom-list-types\fR  (Command)
This command will return a list of types given search parameters
.PP
\&\fBArguments:\fR
.ie n .IP """implements: string"" (optional)" 4
.el .IP "\f(CWimplements: string\fR (optional)" 4
.IX Item "implements: string (optional)"
if specified, only return types that implement this type name
.ie n .IP """abstract: boolean"" (optional)" 4
.el .IP "\f(CWabstract: boolean\fR (optional)" 4
.IX Item "abstract: boolean (optional)"
if true, include abstract types in the results
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`ObjectTypeInfo\*(C'\fR or an empty list if no results are found
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBDevicePropertyInfo\fR (Object)
.PP
Information about device properties.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
the name of the property
.ie n .IP """type: string""" 4
.el .IP "\f(CWtype: string\fR" 4
.IX Item "type: string"
the typename of the property
.ie n .IP """description: string"" (optional)" 4
.el .IP "\f(CWdescription: string\fR (optional)" 4
.IX Item "description: string (optional)"
if specified, the description of the property.
(since 2.2)
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBdevice-list-properties\fR  (Command)
List properties associated with a device.
.PP
\&\fBArguments:\fR
.ie n .IP """typename: string""" 4
.el .IP "\f(CWtypename: string\fR" 4
.IX Item "typename: string"
the type name of a device
.PP
\&\fBReturns:\fR
a list of DevicePropertyInfo describing a devices properties
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBmigrate\fR  (Command)
Migrates the current running guest to another Virtual Machine.
.PP
\&\fBArguments:\fR
.ie n .IP """uri: string""" 4
.el .IP "\f(CWuri: string\fR" 4
.IX Item "uri: string"
the Uniform Resource Identifier of the destination \s-1VM\s0
.ie n .IP """blk: boolean"" (optional)" 4
.el .IP "\f(CWblk: boolean\fR (optional)" 4
.IX Item "blk: boolean (optional)"
do block migration (full disk copy)
.ie n .IP """inc: boolean"" (optional)" 4
.el .IP "\f(CWinc: boolean\fR (optional)" 4
.IX Item "inc: boolean (optional)"
incremental disk copy migration
.ie n .IP """detach: boolean"" (optional)" 4
.el .IP "\f(CWdetach: boolean\fR (optional)" 4
.IX Item "detach: boolean (optional)"
this argument exists only for compatibility reasons and
is ignored by \s-1QEMU\s0
.PP
\&\fBReturns:\fR
nothing on success
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
.IP "1." 4
The 'query\-migrate' command should be used to check migration's progress
and final result (this information is provided by the 'status' member)
.IP "2." 4
All boolean arguments default to false
.IP "3." 4
The user Monitor's \*(L"detach\*(R" argument is invalid in \s-1QMP\s0 and should not
be used
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "migrate", "arguments": { "uri": "tcp:0:4446" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBmigrate-incoming\fR  (Command)
Start an incoming migration, the qemu must have been started
with \-incoming defer
.PP
\&\fBArguments:\fR
.ie n .IP """uri: string""" 4
.el .IP "\f(CWuri: string\fR" 4
.IX Item "uri: string"
The Uniform Resource Identifier identifying the source or
address to listen on
.PP
\&\fBReturns:\fR
nothing on success
.PP
\&\fBSince:\fR
2.3
.PP
\&\fBNotes:\fR
.IP "1." 4
It's a bad idea to use a string for the uri, but it needs to stay
compatible with \-incoming and the format of the uri is already exposed
above libvirt.
.IP "2." 4
\&\s-1QEMU\s0 must be started with \-incoming defer to allow migrate-incoming to
be used.
.IP "3." 4
The uri format is the same as for \-incoming
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "migrate\-incoming",
\&             "arguments": { "uri": "tcp::4446" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBxen-save-devices-state\fR  (Command)
Save the state of all devices to file. The \s-1RAM\s0 and the block devices
of the \s-1VM\s0 are not saved by this command.
.PP
\&\fBArguments:\fR
.ie n .IP """filename: string""" 4
.el .IP "\f(CWfilename: string\fR" 4
.IX Item "filename: string"
the file to save the state of the devices to as binary
data. See xen\-save\-devices\-state.txt for a description of the binary
format.
.PP
\&\fBReturns:\fR
Nothing on success
.PP
\&\fBSince:\fR
1.1
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "xen\-save\-devices\-state",
\&             "arguments": { "filename": "/tmp/save" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBxen-set-global-dirty-log\fR  (Command)
Enable or disable the global dirty log mode.
.PP
\&\fBArguments:\fR
.ie n .IP """enable: boolean""" 4
.el .IP "\f(CWenable: boolean\fR" 4
.IX Item "enable: boolean"
true to enable, false to disable.
.PP
\&\fBReturns:\fR
nothing
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "xen\-set\-global\-dirty\-log",
\&             "arguments": { "enable": true } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBdevice_add\fR  (Command)
.PP
\&\fBArguments:\fR
.ie n .IP """driver: string""" 4
.el .IP "\f(CWdriver: string\fR" 4
.IX Item "driver: string"
the name of the new device's driver
.ie n .IP """bus: string"" (optional)" 4
.el .IP "\f(CWbus: string\fR (optional)" 4
.IX Item "bus: string (optional)"
the device's parent bus (device tree path)
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
the device's \s-1ID,\s0 must be unique
.PP
Additional arguments depend on the type.
.PP
Add a device.
.PP
\&\fBNotes:\fR
.IP "1." 4
For detailed information about this command, please refer to the
\&'docs/qdev\-device\-use.txt' file.
.IP "2." 4
It's possible to list device properties by running \s-1QEMU\s0 with the
\&\*(L"\-device \s-1DEVICE\s0,help\*(R" command-line argument, where \s-1DEVICE\s0 is the
device's name
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "device_add",
\&             "arguments": { "driver": "e1000", "id": "net1",
\&                            "bus": "pci.0",
\&                            "mac": "52:54:00:12:34:56" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fB\s-1TODO:\s0\fR
This command effectively bypasses \s-1QAPI\s0 completely due to its
\&\*(L"additional arguments\*(R" business.  It shouldn't have been added to
the schema in this form.  It should be qapified properly, or
replaced by a properly qapified command.
.PP
\&\fBSince:\fR
0.13
.PP
\&\fBdevice_del\fR  (Command)
Remove a device from a guest
.PP
\&\fBArguments:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
the device's \s-1ID\s0 or \s-1QOM\s0 path
.PP
\&\fBReturns:\fR
Nothing on success
If \f(CW\*(C`id\*(C'\fR is not a valid device, DeviceNotFound
.PP
\&\fBNotes:\fR
When this command completes, the device may not be removed from the
guest.  Hot removal is an operation that requires guest cooperation.
This command merely requests that the guest begin the hot removal
process.  Completion of the device removal process is signaled with a
\&\s-1DEVICE_DELETED\s0 event. Guest reset will automatically complete removal
for all devices.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "device_del",
\&             "arguments": { "id": "net1" } }
\&        <\- { "return": {} }
\&        
\&        \-> { "execute": "device_del",
\&             "arguments": { "id": "/machine/peripheral\-anon/device[0]" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBDumpGuestMemoryFormat\fR (Enum)
.PP
An enumeration of guest-memory-dump's format.
.PP
\&\fBValues:\fR
.ie n .IP """elf""" 4
.el .IP "\f(CWelf\fR" 4
.IX Item "elf"
elf format
.ie n .IP """kdump\-zlib""" 4
.el .IP "\f(CWkdump\-zlib\fR" 4
.IX Item "kdump-zlib"
kdump-compressed format with zlib-compressed
.ie n .IP """kdump\-lzo""" 4
.el .IP "\f(CWkdump\-lzo\fR" 4
.IX Item "kdump-lzo"
kdump-compressed format with lzo-compressed
.ie n .IP """kdump\-snappy""" 4
.el .IP "\f(CWkdump\-snappy\fR" 4
.IX Item "kdump-snappy"
kdump-compressed format with snappy-compressed
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBdump-guest-memory\fR  (Command)
Dump guest's memory to vmcore. It is a synchronous operation that can take
very long depending on the amount of guest memory.
.PP
\&\fBArguments:\fR
.ie n .IP """paging: boolean""" 4
.el .IP "\f(CWpaging: boolean\fR" 4
.IX Item "paging: boolean"
if true, do paging to get guest's memory mapping. This allows
using gdb to process the core file.
.Sp
\&\s-1IMPORTANT:\s0 this option can make \s-1QEMU\s0 allocate several gigabytes
of \s-1RAM.\s0 This can happen for a large guest, or a
malicious guest pretending to be large.
.Sp
Also, paging=true has the following limitations:
.RS 4
.IP "1." 4
The guest may be in a catastrophic state or can have corrupted
memory, which cannot be trusted
.IP "2." 4
The guest can be in real-mode even if paging is enabled. For
example, the guest uses \s-1ACPI\s0 to sleep, and \s-1ACPI\s0 sleep state
goes in real-mode
.IP "3." 4
Currently only supported on i386 and x86_64.
.RE
.RS 4
.RE
.ie n .IP """protocol: string""" 4
.el .IP "\f(CWprotocol: string\fR" 4
.IX Item "protocol: string"
the filename or file descriptor of the vmcore. The supported
protocols are:
.RS 4
.IP "1." 4
file: the protocol starts with \*(L"file:\*(R", and the following
string is the file's path.
.IP "2." 4
fd: the protocol starts with \*(L"fd:\*(R", and the following string
is the fd's name.
.RE
.RS 4
.RE
.ie n .IP """detach: boolean"" (optional)" 4
.el .IP "\f(CWdetach: boolean\fR (optional)" 4
.IX Item "detach: boolean (optional)"
if true, \s-1QMP\s0 will return immediately rather than
waiting for the dump to finish. The user can track progress
using \*(L"query-dump\*(R". (since 2.6).
.ie n .IP """begin: int"" (optional)" 4
.el .IP "\f(CWbegin: int\fR (optional)" 4
.IX Item "begin: int (optional)"
if specified, the starting physical address.
.ie n .IP """length: int"" (optional)" 4
.el .IP "\f(CWlength: int\fR (optional)" 4
.IX Item "length: int (optional)"
if specified, the memory size, in bytes. If you don't
want to dump all guest's memory, please specify the start \f(CW\*(C`begin\*(C'\fR
and \f(CW\*(C`length\*(C'\fR
.ie n .IP """format: DumpGuestMemoryFormat"" (optional)" 4
.el .IP "\f(CWformat: DumpGuestMemoryFormat\fR (optional)" 4
.IX Item "format: DumpGuestMemoryFormat (optional)"
if specified, the format of guest memory dump. But non-elf
format is conflict with paging and filter, ie. \f(CW\*(C`paging\*(C'\fR, \f(CW\*(C`begin\*(C'\fR and
\&\f(CW\*(C`length\*(C'\fR is not allowed to be specified with non-elf \f(CW\*(C`format\*(C'\fR at the
same time (since 2.0)
.PP
\&\fBNote:\fR
All boolean arguments default to false
.PP
\&\fBReturns:\fR
nothing on success
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "dump\-guest\-memory",
\&             "arguments": { "protocol": "fd:dump" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBDumpStatus\fR (Enum)
.PP
Describe the status of a long-running background guest memory dump.
.PP
\&\fBValues:\fR
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
no dump-guest-memory has started yet.
.ie n .IP """active""" 4
.el .IP "\f(CWactive\fR" 4
.IX Item "active"
there is one dump running in background.
.ie n .IP """completed""" 4
.el .IP "\f(CWcompleted\fR" 4
.IX Item "completed"
the last dump has finished successfully.
.ie n .IP """failed""" 4
.el .IP "\f(CWfailed\fR" 4
.IX Item "failed"
the last dump has failed.
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBDumpQueryResult\fR (Object)
.PP
The result format for 'query\-dump'.
.PP
\&\fBMembers:\fR
.ie n .IP """status: DumpStatus""" 4
.el .IP "\f(CWstatus: DumpStatus\fR" 4
.IX Item "status: DumpStatus"
enum of \f(CW\*(C`DumpStatus\*(C'\fR, which shows current dump status
.ie n .IP """completed: int""" 4
.el .IP "\f(CWcompleted: int\fR" 4
.IX Item "completed: int"
bytes written in latest dump (uncompressed)
.ie n .IP """total: int""" 4
.el .IP "\f(CWtotal: int\fR" 4
.IX Item "total: int"
total bytes to be written in latest dump (uncompressed)
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBquery-dump\fR  (Command)
Query latest dump status.
.PP
\&\fBReturns:\fR
A \f(CW\*(C`DumpStatus\*(C'\fR object showing the dump status.
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "query\-dump" }
\&        <\- { "return": { "status": "active", "completed": 1024000,
\&                         "total": 2048000 } }
.Ve
.PP
\&\fBDumpGuestMemoryCapability\fR (Object)
.PP
A list of the available formats for dump-guest-memory
.PP
\&\fBMembers:\fR
.ie n .IP """formats: array of DumpGuestMemoryFormat""" 4
.el .IP "\f(CWformats: array of DumpGuestMemoryFormat\fR" 4
.IX Item "formats: array of DumpGuestMemoryFormat"
Not documented
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBquery-dump-guest-memory-capability\fR  (Command)
Returns the available formats for dump-guest-memory
.PP
\&\fBReturns:\fR
A \f(CW\*(C`DumpGuestMemoryCapability\*(C'\fR object listing available formats for
dump-guest-memory
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "query\-dump\-guest\-memory\-capability" }
\&        <\- { "return": { "formats":
\&                         ["elf", "kdump\-zlib", "kdump\-lzo", "kdump\-snappy"] }
.Ve
.PP
\&\fBdump-skeys\fR  (Command)
Dump guest's storage keys
.PP
\&\fBArguments:\fR
.ie n .IP """filename: string""" 4
.el .IP "\f(CWfilename: string\fR" 4
.IX Item "filename: string"
the path to the file to dump to
.PP
This command is only supported on s390 architecture.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "dump\-skeys",
\&             "arguments": { "filename": "/tmp/skeys" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBnetdev_add\fR  (Command)
Add a network backend.
.PP
\&\fBArguments:\fR
.ie n .IP """type: string""" 4
.el .IP "\f(CWtype: string\fR" 4
.IX Item "type: string"
the type of network backend.  Current valid values are 'user', 'tap',
\&'vde', 'socket', 'dump' and 'bridge'
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
the name of the new network backend
.PP
Additional arguments depend on the type.
.PP
\&\fB\s-1TODO:\s0\fR
This command effectively bypasses \s-1QAPI\s0 completely due to its
\&\*(L"additional arguments\*(R" business.  It shouldn't have been added to
the schema in this form.  It should be qapified properly, or
replaced by a properly qapified command.
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBReturns:\fR
Nothing on success
If \f(CW\*(C`type\*(C'\fR is not a valid network backend, DeviceNotFound
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&        \-> { "execute": "netdev_add",
\&             "arguments": { "type": "user", "id": "netdev1",
\&                            "dnssearch": "example.org" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBnetdev_del\fR  (Command)
Remove a network backend.
.PP
\&\fBArguments:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
the name of the network backend to remove
.PP
\&\fBReturns:\fR
Nothing on success
If \f(CW\*(C`id\*(C'\fR is not a valid network backend, DeviceNotFound
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "netdev_del", "arguments": { "id": "netdev1" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBobject-add\fR  (Command)
Create a \s-1QOM\s0 object.
.PP
\&\fBArguments:\fR
.ie n .IP """qom\-type: string""" 4
.el .IP "\f(CWqom\-type: string\fR" 4
.IX Item "qom-type: string"
the class name for the object to be created
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
the name of the new object
.ie n .IP """props: value"" (optional)" 4
.el .IP "\f(CWprops: value\fR (optional)" 4
.IX Item "props: value (optional)"
a dictionary of properties to be passed to the backend
.PP
\&\fBReturns:\fR
Nothing on success
Error if \f(CW\*(C`qom\-type\*(C'\fR is not a valid class name
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&        \-> { "execute": "object\-add",
\&             "arguments": { "qom\-type": "rng\-random", "id": "rng1",
\&                            "props": { "filename": "/dev/hwrng" } } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBobject-del\fR  (Command)
Remove a \s-1QOM\s0 object.
.PP
\&\fBArguments:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
the name of the \s-1QOM\s0 object to remove
.PP
\&\fBReturns:\fR
Nothing on success
Error if \f(CW\*(C`id\*(C'\fR is not a valid id for a \s-1QOM\s0 object
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "object\-del", "arguments": { "id": "rng1" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBNetdevNoneOptions\fR (Object)
.PP
Use it alone to have zero network devices.
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetLegacyNicOptions\fR (Object)
.PP
Create a new Network Interface Card.
.PP
\&\fBMembers:\fR
.ie n .IP """netdev: string"" (optional)" 4
.el .IP "\f(CWnetdev: string\fR (optional)" 4
.IX Item "netdev: string (optional)"
id of \-netdev to connect to
.ie n .IP """macaddr: string"" (optional)" 4
.el .IP "\f(CWmacaddr: string\fR (optional)" 4
.IX Item "macaddr: string (optional)"
\&\s-1MAC\s0 address
.ie n .IP """model: string"" (optional)" 4
.el .IP "\f(CWmodel: string\fR (optional)" 4
.IX Item "model: string (optional)"
device model (e1000, rtl8139, virtio etc.)
.ie n .IP """addr: string"" (optional)" 4
.el .IP "\f(CWaddr: string\fR (optional)" 4
.IX Item "addr: string (optional)"
\&\s-1PCI\s0 device address
.ie n .IP """vectors: int"" (optional)" 4
.el .IP "\f(CWvectors: int\fR (optional)" 4
.IX Item "vectors: int (optional)"
number of MSI-x vectors, 0 to disable MSI-X
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBString\fR (Object)
.PP
A fat type wrapping 'str', to be embedded in lists.
.PP
\&\fBMembers:\fR
.ie n .IP """str: string""" 4
.el .IP "\f(CWstr: string\fR" 4
.IX Item "str: string"
Not documented
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetdevUserOptions\fR (Object)
.PP
Use the user mode network stack which requires no administrator privilege to
run.
.PP
\&\fBMembers:\fR
.ie n .IP """hostname: string"" (optional)" 4
.el .IP "\f(CWhostname: string\fR (optional)" 4
.IX Item "hostname: string (optional)"
client hostname reported by the builtin \s-1DHCP\s0 server
.ie n .IP """restrict: boolean"" (optional)" 4
.el .IP "\f(CWrestrict: boolean\fR (optional)" 4
.IX Item "restrict: boolean (optional)"
isolate the guest from the host
.ie n .IP """ipv4: boolean"" (optional)" 4
.el .IP "\f(CWipv4: boolean\fR (optional)" 4
.IX Item "ipv4: boolean (optional)"
whether to support IPv4, default true for enabled
(since 2.6)
.ie n .IP """ipv6: boolean"" (optional)" 4
.el .IP "\f(CWipv6: boolean\fR (optional)" 4
.IX Item "ipv6: boolean (optional)"
whether to support IPv6, default true for enabled
(since 2.6)
.ie n .IP """ip: string"" (optional)" 4
.el .IP "\f(CWip: string\fR (optional)" 4
.IX Item "ip: string (optional)"
legacy parameter, use net= instead
.ie n .IP """net: string"" (optional)" 4
.el .IP "\f(CWnet: string\fR (optional)" 4
.IX Item "net: string (optional)"
\&\s-1IP\s0 network address that the guest will see, in the
form addr[/netmask] The netmask is optional, and can be
either in the form a.b.c.d or as a number of valid top-most
bits. Default is 10.0.2.0/24.
.ie n .IP """host: string"" (optional)" 4
.el .IP "\f(CWhost: string\fR (optional)" 4
.IX Item "host: string (optional)"
guest-visible address of the host
.ie n .IP """tftp: string"" (optional)" 4
.el .IP "\f(CWtftp: string\fR (optional)" 4
.IX Item "tftp: string (optional)"
root directory of the built-in \s-1TFTP\s0 server
.ie n .IP """bootfile: string"" (optional)" 4
.el .IP "\f(CWbootfile: string\fR (optional)" 4
.IX Item "bootfile: string (optional)"
\&\s-1BOOTP\s0 filename, for use with tftp=
.ie n .IP """dhcpstart: string"" (optional)" 4
.el .IP "\f(CWdhcpstart: string\fR (optional)" 4
.IX Item "dhcpstart: string (optional)"
the first of the 16 IPs the built-in \s-1DHCP\s0 server can
assign
.ie n .IP """dns: string"" (optional)" 4
.el .IP "\f(CWdns: string\fR (optional)" 4
.IX Item "dns: string (optional)"
guest-visible address of the virtual nameserver
.ie n .IP """dnssearch: array of String"" (optional)" 4
.el .IP "\f(CWdnssearch: array of String\fR (optional)" 4
.IX Item "dnssearch: array of String (optional)"
list of \s-1DNS\s0 suffixes to search, passed as \s-1DHCP\s0 option
to the guest
.ie n .IP """ipv6\-prefix: string"" (optional)" 4
.el .IP "\f(CWipv6\-prefix: string\fR (optional)" 4
.IX Item "ipv6-prefix: string (optional)"
IPv6 network prefix (default is fec0::) (since
2.6). The network prefix is given in the usual
hexadecimal IPv6 address notation.
.ie n .IP """ipv6\-prefixlen: int"" (optional)" 4
.el .IP "\f(CWipv6\-prefixlen: int\fR (optional)" 4
.IX Item "ipv6-prefixlen: int (optional)"
IPv6 network prefix length (default is 64)
(since 2.6)
.ie n .IP """ipv6\-host: string"" (optional)" 4
.el .IP "\f(CWipv6\-host: string\fR (optional)" 4
.IX Item "ipv6-host: string (optional)"
guest-visible IPv6 address of the host (since 2.6)
.ie n .IP """ipv6\-dns: string"" (optional)" 4
.el .IP "\f(CWipv6\-dns: string\fR (optional)" 4
.IX Item "ipv6-dns: string (optional)"
guest-visible IPv6 address of the virtual
nameserver (since 2.6)
.ie n .IP """smb: string"" (optional)" 4
.el .IP "\f(CWsmb: string\fR (optional)" 4
.IX Item "smb: string (optional)"
root directory of the built-in \s-1SMB\s0 server
.ie n .IP """smbserver: string"" (optional)" 4
.el .IP "\f(CWsmbserver: string\fR (optional)" 4
.IX Item "smbserver: string (optional)"
\&\s-1IP\s0 address of the built-in \s-1SMB\s0 server
.ie n .IP """hostfwd: array of String"" (optional)" 4
.el .IP "\f(CWhostfwd: array of String\fR (optional)" 4
.IX Item "hostfwd: array of String (optional)"
redirect incoming \s-1TCP\s0 or \s-1UDP\s0 host connections to guest
endpoints
.ie n .IP """guestfwd: array of String"" (optional)" 4
.el .IP "\f(CWguestfwd: array of String\fR (optional)" 4
.IX Item "guestfwd: array of String (optional)"
forward guest \s-1TCP\s0 connections
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetdevTapOptions\fR (Object)
.PP
Connect the host \s-1TAP\s0 network interface name to the \s-1VLAN.\s0
.PP
\&\fBMembers:\fR
.ie n .IP """ifname: string"" (optional)" 4
.el .IP "\f(CWifname: string\fR (optional)" 4
.IX Item "ifname: string (optional)"
interface name
.ie n .IP """fd: string"" (optional)" 4
.el .IP "\f(CWfd: string\fR (optional)" 4
.IX Item "fd: string (optional)"
file descriptor of an already opened tap
.ie n .IP """fds: string"" (optional)" 4
.el .IP "\f(CWfds: string\fR (optional)" 4
.IX Item "fds: string (optional)"
multiple file descriptors of already opened multiqueue capable
tap
.ie n .IP """script: string"" (optional)" 4
.el .IP "\f(CWscript: string\fR (optional)" 4
.IX Item "script: string (optional)"
script to initialize the interface
.ie n .IP """downscript: string"" (optional)" 4
.el .IP "\f(CWdownscript: string\fR (optional)" 4
.IX Item "downscript: string (optional)"
script to shut down the interface
.ie n .IP """br: string"" (optional)" 4
.el .IP "\f(CWbr: string\fR (optional)" 4
.IX Item "br: string (optional)"
bridge name (since 2.8)
.ie n .IP """helper: string"" (optional)" 4
.el .IP "\f(CWhelper: string\fR (optional)" 4
.IX Item "helper: string (optional)"
command to execute to configure bridge
.ie n .IP """sndbuf: int"" (optional)" 4
.el .IP "\f(CWsndbuf: int\fR (optional)" 4
.IX Item "sndbuf: int (optional)"
send buffer limit. Understands [TGMKkb] suffixes.
.ie n .IP """vnet_hdr: boolean"" (optional)" 4
.el .IP "\f(CWvnet_hdr: boolean\fR (optional)" 4
.IX Item "vnet_hdr: boolean (optional)"
enable the \s-1IFF_VNET_HDR\s0 flag on the tap interface
.ie n .IP """vhost: boolean"" (optional)" 4
.el .IP "\f(CWvhost: boolean\fR (optional)" 4
.IX Item "vhost: boolean (optional)"
enable vhost-net network accelerator
.ie n .IP """vhostfd: string"" (optional)" 4
.el .IP "\f(CWvhostfd: string\fR (optional)" 4
.IX Item "vhostfd: string (optional)"
file descriptor of an already opened vhost net device
.ie n .IP """vhostfds: string"" (optional)" 4
.el .IP "\f(CWvhostfds: string\fR (optional)" 4
.IX Item "vhostfds: string (optional)"
file descriptors of multiple already opened vhost net
devices
.ie n .IP """vhostforce: boolean"" (optional)" 4
.el .IP "\f(CWvhostforce: boolean\fR (optional)" 4
.IX Item "vhostforce: boolean (optional)"
vhost on for non-MSIX virtio guests
.ie n .IP """queues: int"" (optional)" 4
.el .IP "\f(CWqueues: int\fR (optional)" 4
.IX Item "queues: int (optional)"
number of queues to be created for multiqueue capable tap
.ie n .IP """poll\-us: int"" (optional)" 4
.el .IP "\f(CWpoll\-us: int\fR (optional)" 4
.IX Item "poll-us: int (optional)"
maximum number of microseconds that could
be spent on busy polling for tap (since 2.7)
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetdevSocketOptions\fR (Object)
.PP
Connect the \s-1VLAN\s0 to a remote \s-1VLAN\s0 in another \s-1QEMU\s0 virtual machine using a \s-1TCP\s0
socket connection.
.PP
\&\fBMembers:\fR
.ie n .IP """fd: string"" (optional)" 4
.el .IP "\f(CWfd: string\fR (optional)" 4
.IX Item "fd: string (optional)"
file descriptor of an already opened socket
.ie n .IP """listen: string"" (optional)" 4
.el .IP "\f(CWlisten: string\fR (optional)" 4
.IX Item "listen: string (optional)"
port number, and optional hostname, to listen on
.ie n .IP """connect: string"" (optional)" 4
.el .IP "\f(CWconnect: string\fR (optional)" 4
.IX Item "connect: string (optional)"
port number, and optional hostname, to connect to
.ie n .IP """mcast: string"" (optional)" 4
.el .IP "\f(CWmcast: string\fR (optional)" 4
.IX Item "mcast: string (optional)"
\&\s-1UDP\s0 multicast address and port number
.ie n .IP """localaddr: string"" (optional)" 4
.el .IP "\f(CWlocaladdr: string\fR (optional)" 4
.IX Item "localaddr: string (optional)"
source address and port for multicast and udp packets
.ie n .IP """udp: string"" (optional)" 4
.el .IP "\f(CWudp: string\fR (optional)" 4
.IX Item "udp: string (optional)"
\&\s-1UDP\s0 unicast address and port number
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetdevL2TPv3Options\fR (Object)
.PP
Connect the \s-1VLAN\s0 to Ethernet over L2TPv3 Static tunnel
.PP
\&\fBMembers:\fR
.ie n .IP """src: string""" 4
.el .IP "\f(CWsrc: string\fR" 4
.IX Item "src: string"
source address
.ie n .IP """dst: string""" 4
.el .IP "\f(CWdst: string\fR" 4
.IX Item "dst: string"
destination address
.ie n .IP """srcport: string"" (optional)" 4
.el .IP "\f(CWsrcport: string\fR (optional)" 4
.IX Item "srcport: string (optional)"
source port \- mandatory for udp, optional for ip
.ie n .IP """dstport: string"" (optional)" 4
.el .IP "\f(CWdstport: string\fR (optional)" 4
.IX Item "dstport: string (optional)"
destination port \- mandatory for udp, optional for ip
.ie n .IP """ipv6: boolean"" (optional)" 4
.el .IP "\f(CWipv6: boolean\fR (optional)" 4
.IX Item "ipv6: boolean (optional)"
force the use of ipv6
.ie n .IP """udp: boolean"" (optional)" 4
.el .IP "\f(CWudp: boolean\fR (optional)" 4
.IX Item "udp: boolean (optional)"
use the udp version of l2tpv3 encapsulation
.ie n .IP """cookie64: boolean"" (optional)" 4
.el .IP "\f(CWcookie64: boolean\fR (optional)" 4
.IX Item "cookie64: boolean (optional)"
use 64 bit coookies
.ie n .IP """counter: boolean"" (optional)" 4
.el .IP "\f(CWcounter: boolean\fR (optional)" 4
.IX Item "counter: boolean (optional)"
have sequence counter
.ie n .IP """pincounter: boolean"" (optional)" 4
.el .IP "\f(CWpincounter: boolean\fR (optional)" 4
.IX Item "pincounter: boolean (optional)"
pin sequence counter to zero \-
workaround for buggy implementations or
networks with packet reorder
.ie n .IP """txcookie: int"" (optional)" 4
.el .IP "\f(CWtxcookie: int\fR (optional)" 4
.IX Item "txcookie: int (optional)"
32 or 64 bit transmit cookie
.ie n .IP """rxcookie: int"" (optional)" 4
.el .IP "\f(CWrxcookie: int\fR (optional)" 4
.IX Item "rxcookie: int (optional)"
32 or 64 bit receive cookie
.ie n .IP """txsession: int""" 4
.el .IP "\f(CWtxsession: int\fR" 4
.IX Item "txsession: int"
32 bit transmit session
.ie n .IP """rxsession: int"" (optional)" 4
.el .IP "\f(CWrxsession: int\fR (optional)" 4
.IX Item "rxsession: int (optional)"
32 bit receive session \- if not specified
set to the same value as transmit
.ie n .IP """offset: int"" (optional)" 4
.el .IP "\f(CWoffset: int\fR (optional)" 4
.IX Item "offset: int (optional)"
additional offset \- allows the insertion of
additional application-specific data before the packet payload
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBNetdevVdeOptions\fR (Object)
.PP
Connect the \s-1VLAN\s0 to a vde switch running on the host.
.PP
\&\fBMembers:\fR
.ie n .IP """sock: string"" (optional)" 4
.el .IP "\f(CWsock: string\fR (optional)" 4
.IX Item "sock: string (optional)"
socket path
.ie n .IP """port: int"" (optional)" 4
.el .IP "\f(CWport: int\fR (optional)" 4
.IX Item "port: int (optional)"
port number
.ie n .IP """group: string"" (optional)" 4
.el .IP "\f(CWgroup: string\fR (optional)" 4
.IX Item "group: string (optional)"
group owner of socket
.ie n .IP """mode: int"" (optional)" 4
.el .IP "\f(CWmode: int\fR (optional)" 4
.IX Item "mode: int (optional)"
permissions for socket
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetdevDumpOptions\fR (Object)
.PP
Dump \s-1VLAN\s0 network traffic to a file.
.PP
\&\fBMembers:\fR
.ie n .IP """len: int"" (optional)" 4
.el .IP "\f(CWlen: int\fR (optional)" 4
.IX Item "len: int (optional)"
per-packet size limit (64k default). Understands [TGMKkb]
suffixes.
.ie n .IP """file: string"" (optional)" 4
.el .IP "\f(CWfile: string\fR (optional)" 4
.IX Item "file: string (optional)"
dump file path (default is qemu\-vlan0.pcap)
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetdevBridgeOptions\fR (Object)
.PP
Connect a host \s-1TAP\s0 network interface to a host bridge device.
.PP
\&\fBMembers:\fR
.ie n .IP """br: string"" (optional)" 4
.el .IP "\f(CWbr: string\fR (optional)" 4
.IX Item "br: string (optional)"
bridge name
.ie n .IP """helper: string"" (optional)" 4
.el .IP "\f(CWhelper: string\fR (optional)" 4
.IX Item "helper: string (optional)"
command to execute to configure bridge
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetdevHubPortOptions\fR (Object)
.PP
Connect two or more net clients through a software hub.
.PP
\&\fBMembers:\fR
.ie n .IP """hubid: int""" 4
.el .IP "\f(CWhubid: int\fR" 4
.IX Item "hubid: int"
hub identifier number
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetdevNetmapOptions\fR (Object)
.PP
Connect a client to a netmap-enabled \s-1NIC\s0 or to a \s-1VALE\s0 switch port
.PP
\&\fBMembers:\fR
.ie n .IP """ifname: string""" 4
.el .IP "\f(CWifname: string\fR" 4
.IX Item "ifname: string"
Either the name of an existing network interface supported by
netmap, or the name of a \s-1VALE\s0 port (created on the fly).
A \s-1VALE\s0 port name is in the form 'valeXXX:YYY', where \s-1XXX\s0 and
\&\s-1YYY\s0 are non-negative integers. \s-1XXX\s0 identifies a switch and
\&\s-1YYY\s0 identifies a port of the switch. \s-1VALE\s0 ports having the
same \s-1XXX\s0 are therefore connected to the same switch.
.ie n .IP """devname: string"" (optional)" 4
.el .IP "\f(CWdevname: string\fR (optional)" 4
.IX Item "devname: string (optional)"
path of the netmap device (default: '/dev/netmap').
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBNetdevVhostUserOptions\fR (Object)
.PP
Vhost-user network backend
.PP
\&\fBMembers:\fR
.ie n .IP """chardev: string""" 4
.el .IP "\f(CWchardev: string\fR" 4
.IX Item "chardev: string"
name of a unix socket chardev
.ie n .IP """vhostforce: boolean"" (optional)" 4
.el .IP "\f(CWvhostforce: boolean\fR (optional)" 4
.IX Item "vhostforce: boolean (optional)"
vhost on for non-MSIX virtio guests (default: false).
.ie n .IP """queues: int"" (optional)" 4
.el .IP "\f(CWqueues: int\fR (optional)" 4
.IX Item "queues: int (optional)"
number of queues to be created for multiqueue vhost-user
(default: 1) (Since 2.5)
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBNetClientDriver\fR (Enum)
.PP
Available netdev drivers.
.PP
\&\fBValues:\fR
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
Not documented
.ie n .IP """nic""" 4
.el .IP "\f(CWnic\fR" 4
.IX Item "nic"
Not documented
.ie n .IP """user""" 4
.el .IP "\f(CWuser\fR" 4
.IX Item "user"
Not documented
.ie n .IP """tap""" 4
.el .IP "\f(CWtap\fR" 4
.IX Item "tap"
Not documented
.ie n .IP """l2tpv3""" 4
.el .IP "\f(CWl2tpv3\fR" 4
.IX Item "l2tpv3"
Not documented
.ie n .IP """socket""" 4
.el .IP "\f(CWsocket\fR" 4
.IX Item "socket"
Not documented
.ie n .IP """vde""" 4
.el .IP "\f(CWvde\fR" 4
.IX Item "vde"
Not documented
.ie n .IP """dump""" 4
.el .IP "\f(CWdump\fR" 4
.IX Item "dump"
Not documented
.ie n .IP """bridge""" 4
.el .IP "\f(CWbridge\fR" 4
.IX Item "bridge"
Not documented
.ie n .IP """hubport""" 4
.el .IP "\f(CWhubport\fR" 4
.IX Item "hubport"
Not documented
.ie n .IP """netmap""" 4
.el .IP "\f(CWnetmap\fR" 4
.IX Item "netmap"
Not documented
.ie n .IP """vhost\-user""" 4
.el .IP "\f(CWvhost\-user\fR" 4
.IX Item "vhost-user"
Not documented
.PP
\&\fBSince:\fR
2.7
.PP
\&\fBNetdev\fR (Object)
.PP
Captures the configuration of a network device.
.PP
\&\fBMembers:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
identifier for monitor commands.
.ie n .IP """type: NetClientDriver""" 4
.el .IP "\f(CWtype: NetClientDriver\fR" 4
.IX Item "type: NetClientDriver"
Specify the driver used for interpreting remaining arguments.
.ie n .IP "The members of ""NetdevNoneOptions"" when ""type"" is ""none""" 4
.el .IP "The members of \f(CWNetdevNoneOptions\fR when \f(CWtype\fR is ``none''" 4
.IX Item "The members of NetdevNoneOptions when type is none"
.PD 0
.ie n .IP "The members of ""NetLegacyNicOptions"" when ""type"" is ""nic""" 4
.el .IP "The members of \f(CWNetLegacyNicOptions\fR when \f(CWtype\fR is ``nic''" 4
.IX Item "The members of NetLegacyNicOptions when type is nic"
.ie n .IP "The members of ""NetdevUserOptions"" when ""type"" is ""user""" 4
.el .IP "The members of \f(CWNetdevUserOptions\fR when \f(CWtype\fR is ``user''" 4
.IX Item "The members of NetdevUserOptions when type is user"
.ie n .IP "The members of ""NetdevTapOptions"" when ""type"" is ""tap""" 4
.el .IP "The members of \f(CWNetdevTapOptions\fR when \f(CWtype\fR is ``tap''" 4
.IX Item "The members of NetdevTapOptions when type is tap"
.ie n .IP "The members of ""NetdevL2TPv3Options"" when ""type"" is ""l2tpv3""" 4
.el .IP "The members of \f(CWNetdevL2TPv3Options\fR when \f(CWtype\fR is ``l2tpv3''" 4
.IX Item "The members of NetdevL2TPv3Options when type is l2tpv3"
.ie n .IP "The members of ""NetdevSocketOptions"" when ""type"" is ""socket""" 4
.el .IP "The members of \f(CWNetdevSocketOptions\fR when \f(CWtype\fR is ``socket''" 4
.IX Item "The members of NetdevSocketOptions when type is socket"
.ie n .IP "The members of ""NetdevVdeOptions"" when ""type"" is ""vde""" 4
.el .IP "The members of \f(CWNetdevVdeOptions\fR when \f(CWtype\fR is ``vde''" 4
.IX Item "The members of NetdevVdeOptions when type is vde"
.ie n .IP "The members of ""NetdevDumpOptions"" when ""type"" is ""dump""" 4
.el .IP "The members of \f(CWNetdevDumpOptions\fR when \f(CWtype\fR is ``dump''" 4
.IX Item "The members of NetdevDumpOptions when type is dump"
.ie n .IP "The members of ""NetdevBridgeOptions"" when ""type"" is ""bridge""" 4
.el .IP "The members of \f(CWNetdevBridgeOptions\fR when \f(CWtype\fR is ``bridge''" 4
.IX Item "The members of NetdevBridgeOptions when type is bridge"
.ie n .IP "The members of ""NetdevHubPortOptions"" when ""type"" is ""hubport""" 4
.el .IP "The members of \f(CWNetdevHubPortOptions\fR when \f(CWtype\fR is ``hubport''" 4
.IX Item "The members of NetdevHubPortOptions when type is hubport"
.ie n .IP "The members of ""NetdevNetmapOptions"" when ""type"" is ""netmap""" 4
.el .IP "The members of \f(CWNetdevNetmapOptions\fR when \f(CWtype\fR is ``netmap''" 4
.IX Item "The members of NetdevNetmapOptions when type is netmap"
.ie n .IP "The members of ""NetdevVhostUserOptions"" when ""type"" is ""vhost-user""" 4
.el .IP "The members of \f(CWNetdevVhostUserOptions\fR when \f(CWtype\fR is ``vhost-user''" 4
.IX Item "The members of NetdevVhostUserOptions when type is vhost-user"
.PD
.PP
\&\fBSince:\fR
1.2
.PP
\&'l2tpv3' \- since 2.1
.PP
\&\fBNetLegacy\fR (Object)
.PP
Captures the configuration of a network device; legacy.
.PP
\&\fBMembers:\fR
.ie n .IP """vlan: int"" (optional)" 4
.el .IP "\f(CWvlan: int\fR (optional)" 4
.IX Item "vlan: int (optional)"
vlan number
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
identifier for monitor commands
.ie n .IP """name: string"" (optional)" 4
.el .IP "\f(CWname: string\fR (optional)" 4
.IX Item "name: string (optional)"
identifier for monitor commands, ignored if \f(CW\*(C`id\*(C'\fR is present
.ie n .IP """opts: NetLegacyOptions""" 4
.el .IP "\f(CWopts: NetLegacyOptions\fR" 4
.IX Item "opts: NetLegacyOptions"
device type specific properties (legacy)
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetLegacyOptionsType\fR (Enum)
.PP
\&\fBValues:\fR
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
Not documented
.ie n .IP """nic""" 4
.el .IP "\f(CWnic\fR" 4
.IX Item "nic"
Not documented
.ie n .IP """user""" 4
.el .IP "\f(CWuser\fR" 4
.IX Item "user"
Not documented
.ie n .IP """tap""" 4
.el .IP "\f(CWtap\fR" 4
.IX Item "tap"
Not documented
.ie n .IP """l2tpv3""" 4
.el .IP "\f(CWl2tpv3\fR" 4
.IX Item "l2tpv3"
Not documented
.ie n .IP """socket""" 4
.el .IP "\f(CWsocket\fR" 4
.IX Item "socket"
Not documented
.ie n .IP """vde""" 4
.el .IP "\f(CWvde\fR" 4
.IX Item "vde"
Not documented
.ie n .IP """dump""" 4
.el .IP "\f(CWdump\fR" 4
.IX Item "dump"
Not documented
.ie n .IP """bridge""" 4
.el .IP "\f(CWbridge\fR" 4
.IX Item "bridge"
Not documented
.ie n .IP """netmap""" 4
.el .IP "\f(CWnetmap\fR" 4
.IX Item "netmap"
Not documented
.ie n .IP """vhost\-user""" 4
.el .IP "\f(CWvhost\-user\fR" 4
.IX Item "vhost-user"
Not documented
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetLegacyOptions\fR (Object)
.PP
Like Netdev, but for use only by the legacy command line options
.PP
\&\fBMembers:\fR
.ie n .IP """type: NetLegacyOptionsType""" 4
.el .IP "\f(CWtype: NetLegacyOptionsType\fR" 4
.IX Item "type: NetLegacyOptionsType"
Not documented
.ie n .IP "The members of ""NetdevNoneOptions"" when ""type"" is ""none""" 4
.el .IP "The members of \f(CWNetdevNoneOptions\fR when \f(CWtype\fR is ``none''" 4
.IX Item "The members of NetdevNoneOptions when type is none"
.PD 0
.ie n .IP "The members of ""NetLegacyNicOptions"" when ""type"" is ""nic""" 4
.el .IP "The members of \f(CWNetLegacyNicOptions\fR when \f(CWtype\fR is ``nic''" 4
.IX Item "The members of NetLegacyNicOptions when type is nic"
.ie n .IP "The members of ""NetdevUserOptions"" when ""type"" is ""user""" 4
.el .IP "The members of \f(CWNetdevUserOptions\fR when \f(CWtype\fR is ``user''" 4
.IX Item "The members of NetdevUserOptions when type is user"
.ie n .IP "The members of ""NetdevTapOptions"" when ""type"" is ""tap""" 4
.el .IP "The members of \f(CWNetdevTapOptions\fR when \f(CWtype\fR is ``tap''" 4
.IX Item "The members of NetdevTapOptions when type is tap"
.ie n .IP "The members of ""NetdevL2TPv3Options"" when ""type"" is ""l2tpv3""" 4
.el .IP "The members of \f(CWNetdevL2TPv3Options\fR when \f(CWtype\fR is ``l2tpv3''" 4
.IX Item "The members of NetdevL2TPv3Options when type is l2tpv3"
.ie n .IP "The members of ""NetdevSocketOptions"" when ""type"" is ""socket""" 4
.el .IP "The members of \f(CWNetdevSocketOptions\fR when \f(CWtype\fR is ``socket''" 4
.IX Item "The members of NetdevSocketOptions when type is socket"
.ie n .IP "The members of ""NetdevVdeOptions"" when ""type"" is ""vde""" 4
.el .IP "The members of \f(CWNetdevVdeOptions\fR when \f(CWtype\fR is ``vde''" 4
.IX Item "The members of NetdevVdeOptions when type is vde"
.ie n .IP "The members of ""NetdevDumpOptions"" when ""type"" is ""dump""" 4
.el .IP "The members of \f(CWNetdevDumpOptions\fR when \f(CWtype\fR is ``dump''" 4
.IX Item "The members of NetdevDumpOptions when type is dump"
.ie n .IP "The members of ""NetdevBridgeOptions"" when ""type"" is ""bridge""" 4
.el .IP "The members of \f(CWNetdevBridgeOptions\fR when \f(CWtype\fR is ``bridge''" 4
.IX Item "The members of NetdevBridgeOptions when type is bridge"
.ie n .IP "The members of ""NetdevNetmapOptions"" when ""type"" is ""netmap""" 4
.el .IP "The members of \f(CWNetdevNetmapOptions\fR when \f(CWtype\fR is ``netmap''" 4
.IX Item "The members of NetdevNetmapOptions when type is netmap"
.ie n .IP "The members of ""NetdevVhostUserOptions"" when ""type"" is ""vhost-user""" 4
.el .IP "The members of \f(CWNetdevVhostUserOptions\fR when \f(CWtype\fR is ``vhost-user''" 4
.IX Item "The members of NetdevVhostUserOptions when type is vhost-user"
.PD
.PP
\&\fBSince:\fR
1.2
.PP
\&\fBNetFilterDirection\fR (Enum)
.PP
Indicates whether a netfilter is attached to a netdev's transmit queue or
receive queue or both.
.PP
\&\fBValues:\fR
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
the filter is attached both to the receive and the transmit
queue of the netdev (default).
.ie n .IP """rx""" 4
.el .IP "\f(CWrx\fR" 4
.IX Item "rx"
the filter is attached to the receive queue of the netdev,
where it will receive packets sent to the netdev.
.ie n .IP """tx""" 4
.el .IP "\f(CWtx\fR" 4
.IX Item "tx"
the filter is attached to the transmit queue of the netdev,
where it will receive packets sent by the netdev.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBInetSocketAddressBase\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """host: string""" 4
.el .IP "\f(CWhost: string\fR" 4
.IX Item "host: string"
host part of the address
.ie n .IP """port: string""" 4
.el .IP "\f(CWport: string\fR" 4
.IX Item "port: string"
port part of the address
.PP
\&\fBInetSocketAddress\fR (Object)
.PP
Captures a socket address or address range in the Internet namespace.
.PP
\&\fBMembers:\fR
.ie n .IP """numeric: boolean"" (optional)" 4
.el .IP "\f(CWnumeric: boolean\fR (optional)" 4
.IX Item "numeric: boolean (optional)"
true if the host/port are guaranteed to be numeric,
false if name resolution should be attempted. Defaults to false.
(Since 2.9)
.ie n .IP """to: int"" (optional)" 4
.el .IP "\f(CWto: int\fR (optional)" 4
.IX Item "to: int (optional)"
If present, this is range of possible addresses, with port
between \f(CW\*(C`port\*(C'\fR and \f(CW\*(C`to\*(C'\fR.
.ie n .IP """ipv4: boolean"" (optional)" 4
.el .IP "\f(CWipv4: boolean\fR (optional)" 4
.IX Item "ipv4: boolean (optional)"
whether to accept IPv4 addresses, default try both IPv4 and IPv6
.ie n .IP """ipv6: boolean"" (optional)" 4
.el .IP "\f(CWipv6: boolean\fR (optional)" 4
.IX Item "ipv6: boolean (optional)"
whether to accept IPv6 addresses, default try both IPv4 and IPv6
.ie n .IP "The members of ""InetSocketAddressBase""" 4
.el .IP "The members of \f(CWInetSocketAddressBase\fR" 4
.IX Item "The members of InetSocketAddressBase"
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBUnixSocketAddress\fR (Object)
.PP
Captures a socket address in the local (\*(L"Unix socket\*(R") namespace.
.PP
\&\fBMembers:\fR
.ie n .IP """path: string""" 4
.el .IP "\f(CWpath: string\fR" 4
.IX Item "path: string"
filesystem path to use
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBVsockSocketAddress\fR (Object)
.PP
Captures a socket address in the vsock namespace.
.PP
\&\fBMembers:\fR
.ie n .IP """cid: string""" 4
.el .IP "\f(CWcid: string\fR" 4
.IX Item "cid: string"
unique host identifier
.ie n .IP """port: string""" 4
.el .IP "\f(CWport: string\fR" 4
.IX Item "port: string"
port
.PP
\&\fBNote:\fR
string types are used to allow for possible future hostname or
service resolution support.
.PP
\&\fBSince:\fR
2.8
.PP
\&\fBSocketAddressLegacy\fR (Object)
.PP
Captures the address of a socket, which could also be a named file descriptor
.PP
\&\fBMembers:\fR
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
One of \*(L"inet\*(R", \*(L"unix\*(R", \*(L"vsock\*(R", \*(L"fd\*(R"
.ie n .IP """data: InetSocketAddress"" when ""type"" is ""inet""" 4
.el .IP "\f(CWdata: InetSocketAddress\fR when \f(CWtype\fR is ``inet''" 4
.IX Item "data: InetSocketAddress when type is inet"
.PD 0
.ie n .IP """data: UnixSocketAddress"" when ""type"" is ""unix""" 4
.el .IP "\f(CWdata: UnixSocketAddress\fR when \f(CWtype\fR is ``unix''" 4
.IX Item "data: UnixSocketAddress when type is unix"
.ie n .IP """data: VsockSocketAddress"" when ""type"" is ""vsock""" 4
.el .IP "\f(CWdata: VsockSocketAddress\fR when \f(CWtype\fR is ``vsock''" 4
.IX Item "data: VsockSocketAddress when type is vsock"
.ie n .IP """data: String"" when ""type"" is ""fd""" 4
.el .IP "\f(CWdata: String\fR when \f(CWtype\fR is ``fd''" 4
.IX Item "data: String when type is fd"
.PD
.PP
\&\fBNote:\fR
This type is deprecated in favor of SocketAddress.  The
difference between SocketAddressLegacy and SocketAddress is that the
latter is a flat union rather than a simple union. Flat is nicer
because it avoids nesting on the wire, i.e. that form has fewer {}.
.PP
\&\fBSince:\fR
1.3
.PP
\&\fBSocketAddressType\fR (Enum)
.PP
Available SocketAddress types
.PP
\&\fBValues:\fR
.ie n .IP """inet""" 4
.el .IP "\f(CWinet\fR" 4
.IX Item "inet"
Internet address
.ie n .IP """unix""" 4
.el .IP "\f(CWunix\fR" 4
.IX Item "unix"
Unix domain socket
.ie n .IP """vsock""" 4
.el .IP "\f(CWvsock\fR" 4
.IX Item "vsock"
Not documented
.ie n .IP """fd""" 4
.el .IP "\f(CWfd\fR" 4
.IX Item "fd"
Not documented
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBSocketAddress\fR (Object)
.PP
Captures the address of a socket, which could also be a named file
descriptor
.PP
\&\fBMembers:\fR
.ie n .IP """type: SocketAddressType""" 4
.el .IP "\f(CWtype: SocketAddressType\fR" 4
.IX Item "type: SocketAddressType"
Transport type
.ie n .IP "The members of ""InetSocketAddress"" when ""type"" is ""inet""" 4
.el .IP "The members of \f(CWInetSocketAddress\fR when \f(CWtype\fR is ``inet''" 4
.IX Item "The members of InetSocketAddress when type is inet"
.PD 0
.ie n .IP "The members of ""UnixSocketAddress"" when ""type"" is ""unix""" 4
.el .IP "The members of \f(CWUnixSocketAddress\fR when \f(CWtype\fR is ``unix''" 4
.IX Item "The members of UnixSocketAddress when type is unix"
.ie n .IP "The members of ""VsockSocketAddress"" when ""type"" is ""vsock""" 4
.el .IP "The members of \f(CWVsockSocketAddress\fR when \f(CWtype\fR is ``vsock''" 4
.IX Item "The members of VsockSocketAddress when type is vsock"
.ie n .IP "The members of ""String"" when ""type"" is ""fd""" 4
.el .IP "The members of \f(CWString\fR when \f(CWtype\fR is ``fd''" 4
.IX Item "The members of String when type is fd"
.PD
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBgetfd\fR  (Command)
Receive a file descriptor via \s-1SCM\s0 rights and assign it a name
.PP
\&\fBArguments:\fR
.ie n .IP """fdname: string""" 4
.el .IP "\f(CWfdname: string\fR" 4
.IX Item "fdname: string"
file descriptor name
.PP
\&\fBReturns:\fR
Nothing on success
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBNotes:\fR
If \f(CW\*(C`fdname\*(C'\fR already exists, the file descriptor assigned to
it will be closed and replaced by the received file
descriptor.
.PP
The 'closefd' command can be used to explicitly close the
file descriptor when it is no longer needed.
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "getfd", "arguments": { "fdname": "fd1" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBclosefd\fR  (Command)
Close a file descriptor previously passed via \s-1SCM\s0 rights
.PP
\&\fBArguments:\fR
.ie n .IP """fdname: string""" 4
.el .IP "\f(CWfdname: string\fR" 4
.IX Item "fdname: string"
file descriptor name
.PP
\&\fBReturns:\fR
Nothing on success
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "closefd", "arguments": { "fdname": "fd1" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBMachineInfo\fR (Object)
.PP
Information describing a machine.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
the name of the machine
.ie n .IP """alias: string"" (optional)" 4
.el .IP "\f(CWalias: string\fR (optional)" 4
.IX Item "alias: string (optional)"
an alias for the machine name
.ie n .IP """is\-default: boolean"" (optional)" 4
.el .IP "\f(CWis\-default: boolean\fR (optional)" 4
.IX Item "is-default: boolean (optional)"
whether the machine is default
.ie n .IP """cpu\-max: int""" 4
.el .IP "\f(CWcpu\-max: int\fR" 4
.IX Item "cpu-max: int"
maximum number of CPUs supported by the machine type
(since 1.5.0)
.ie n .IP """hotpluggable\-cpus: boolean""" 4
.el .IP "\f(CWhotpluggable\-cpus: boolean\fR" 4
.IX Item "hotpluggable-cpus: boolean"
cpu hotplug via \-device is supported (since 2.7.0)
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBquery-machines\fR  (Command)
Return a list of supported machines
.PP
\&\fBReturns:\fR
a list of MachineInfo
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBCpuDefinitionInfo\fR (Object)
.PP
Virtual \s-1CPU\s0 definition.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
the name of the \s-1CPU\s0 definition
.ie n .IP """migration\-safe: boolean"" (optional)" 4
.el .IP "\f(CWmigration\-safe: boolean\fR (optional)" 4
.IX Item "migration-safe: boolean (optional)"
whether a \s-1CPU\s0 definition can be safely used for
migration in combination with a \s-1QEMU\s0 compatibility machine
when migrating between different \s-1QMU\s0 versions and between
hosts with different sets of (hardware or software)
capabilities. If not provided, information is not available
and callers should not assume the \s-1CPU\s0 definition to be
migration-safe. (since 2.8)
.ie n .IP """static: boolean""" 4
.el .IP "\f(CWstatic: boolean\fR" 4
.IX Item "static: boolean"
whether a \s-1CPU\s0 definition is static and will not change depending on
\&\s-1QEMU\s0 version, machine type, machine options and accelerator options.
A static model is always migration-safe. (since 2.8)
.ie n .IP """unavailable\-features: array of string"" (optional)" 4
.el .IP "\f(CWunavailable\-features: array of string\fR (optional)" 4
.IX Item "unavailable-features: array of string (optional)"
List of properties that prevent
the \s-1CPU\s0 model from running in the current
host. (since 2.8)
.ie n .IP """typename: string""" 4
.el .IP "\f(CWtypename: string\fR" 4
.IX Item "typename: string"
Type name that can be used as argument to \f(CW\*(C`device\-list\-properties\*(C'\fR,
to introspect properties configurable using \-cpu or \-global.
(since 2.9)
.PP
\&\f(CW\*(C`unavailable\-features\*(C'\fR is a list of \s-1QOM\s0 property names that
represent \s-1CPU\s0 model attributes that prevent the \s-1CPU\s0 from running.
If the \s-1QOM\s0 property is read-only, that means there's no known
way to make the \s-1CPU\s0 model run in the current host. Implementations
that choose not to provide specific information return the
property name \*(L"type\*(R".
If the property is read-write, it means that it \s-1MAY\s0 be possible
to run the \s-1CPU\s0 model in the current host if that property is
changed. Management software can use it as hints to suggest or
choose an alternative for the user, or just to generate meaningful
error messages explaining why the \s-1CPU\s0 model can't be used.
If \f(CW\*(C`unavailable\-features\*(C'\fR is an empty list, the \s-1CPU\s0 model is
runnable using the current host and machine-type.
If \f(CW\*(C`unavailable\-features\*(C'\fR is not present, runnability
information for the \s-1CPU\s0 is not available.
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBquery-cpu-definitions\fR  (Command)
Return a list of supported virtual \s-1CPU\s0 definitions
.PP
\&\fBReturns:\fR
a list of CpuDefInfo
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBCpuModelInfo\fR (Object)
.PP
Virtual \s-1CPU\s0 model.
.PP
A \s-1CPU\s0 model consists of the name of a \s-1CPU\s0 definition, to which
delta changes are applied (e.g. features added/removed). Most magic values
that an architecture might require should be hidden behind the name.
However, if required, architectures can expose relevant properties.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
the name of the \s-1CPU\s0 definition the model is based on
.ie n .IP """props: value"" (optional)" 4
.el .IP "\f(CWprops: value\fR (optional)" 4
.IX Item "props: value (optional)"
a dictionary of \s-1QOM\s0 properties to be applied
.PP
\&\fBSince:\fR
2.8.0
.PP
\&\fBCpuModelExpansionType\fR (Enum)
.PP
An enumeration of \s-1CPU\s0 model expansion types.
.PP
\&\fBValues:\fR
.ie n .IP """static""" 4
.el .IP "\f(CWstatic\fR" 4
.IX Item "static"
Expand to a static \s-1CPU\s0 model, a combination of a static base
model name and property delta changes. As the static base model will
never change, the expanded \s-1CPU\s0 model will be the same, independant of
independent of \s-1QEMU\s0 version, machine type, machine options, and
accelerator options. Therefore, the resulting model can be used by
tooling without having to specify a compatibility machine \- e.g. when
displaying the \*(L"host\*(R" model. static \s-1CPU\s0 models are migration-safe.
.ie n .IP """full""" 4
.el .IP "\f(CWfull\fR" 4
.IX Item "full"
Expand all properties. The produced model is not guaranteed to be
migration-safe, but allows tooling to get an insight and work with
model details.
.PP
\&\fBNote:\fR
When a non-migration-safe \s-1CPU\s0 model is expanded in static mode, some
features enabled by the \s-1CPU\s0 model may be omitted, because they can't be
implemented by a static \s-1CPU\s0 model definition (e.g. cache info passthrough and
\&\s-1PMU\s0 passthrough in x86). If you need an accurate representation of the
features enabled by a non-migration-safe \s-1CPU\s0 model, use \f(CW\*(C`full\*(C'\fR. If you need a
static representation that will keep \s-1ABI\s0 compatibility even when changing \s-1QEMU\s0
version or machine-type, use \f(CW\*(C`static\*(C'\fR (but keep in mind that some features may
be omitted).
.PP
\&\fBSince:\fR
2.8.0
.PP
\&\fBCpuModelExpansionInfo\fR (Object)
.PP
The result of a cpu model expansion.
.PP
\&\fBMembers:\fR
.ie n .IP """model: CpuModelInfo""" 4
.el .IP "\f(CWmodel: CpuModelInfo\fR" 4
.IX Item "model: CpuModelInfo"
the expanded CpuModelInfo.
.PP
\&\fBSince:\fR
2.8.0
.PP
\&\fBquery-cpu-model-expansion\fR  (Command)
Expands a given \s-1CPU\s0 model (or a combination of \s-1CPU\s0 model + additional options)
to different granularities, allowing tooling to get an understanding what a
specific \s-1CPU\s0 model looks like in \s-1QEMU\s0 under a certain configuration.
.PP
This interface can be used to query the \*(L"host\*(R" \s-1CPU\s0 model.
.PP
The data returned by this command may be affected by:
.IP "\(bu" 4
\&\s-1QEMU\s0 version: \s-1CPU\s0 models may look different depending on the \s-1QEMU\s0 version.
(Except for \s-1CPU\s0 models reported as \*(L"static\*(R" in query-cpu-definitions.)
.IP "\(bu" 4
machine-type: \s-1CPU\s0 model  may look different depending on the machine-type.
(Except for \s-1CPU\s0 models reported as \*(L"static\*(R" in query-cpu-definitions.)
.IP "\(bu" 4
machine options (including accelerator): in some architectures, \s-1CPU\s0 models
may look different depending on machine and accelerator options. (Except for
\&\s-1CPU\s0 models reported as \*(L"static\*(R" in query-cpu-definitions.)
.IP "\(bu" 4
\&\*(L"\-cpu\*(R" arguments and global properties: arguments to the \-cpu option and
global properties may affect expansion of \s-1CPU\s0 models. Using
query-cpu-model-expansion while using these is not advised.
.PP
Some architectures may not support all expansion types. s390x supports
\&\*(L"full\*(R" and \*(L"static\*(R".
.PP
\&\fBArguments:\fR
.ie n .IP """type: CpuModelExpansionType""" 4
.el .IP "\f(CWtype: CpuModelExpansionType\fR" 4
.IX Item "type: CpuModelExpansionType"
Not documented
.ie n .IP """model: CpuModelInfo""" 4
.el .IP "\f(CWmodel: CpuModelInfo\fR" 4
.IX Item "model: CpuModelInfo"
Not documented
.PP
\&\fBReturns:\fR
a CpuModelExpansionInfo. Returns an error if expanding \s-1CPU\s0 models is
not supported, if the model cannot be expanded, if the model contains
an unknown \s-1CPU\s0 definition name, unknown properties or properties
with a wrong type. Also returns an error if an expansion type is
not supported.
.PP
\&\fBSince:\fR
2.8.0
.PP
\&\fBCpuModelCompareResult\fR (Enum)
.PP
An enumeration of \s-1CPU\s0 model comparation results. The result is usually
calculated using e.g. \s-1CPU\s0 features or \s-1CPU\s0 generations.
.PP
\&\fBValues:\fR
.ie n .IP """incompatible""" 4
.el .IP "\f(CWincompatible\fR" 4
.IX Item "incompatible"
If model A is incompatible to model B, model A is not
guaranteed to run where model B runs and the other way around.
.ie n .IP """identical""" 4
.el .IP "\f(CWidentical\fR" 4
.IX Item "identical"
If model A is identical to model B, model A is guaranteed to run
where model B runs and the other way around.
.ie n .IP """superset""" 4
.el .IP "\f(CWsuperset\fR" 4
.IX Item "superset"
If model A is a superset of model B, model B is guaranteed to run
where model A runs. There are no guarantees about the other way.
.ie n .IP """subset""" 4
.el .IP "\f(CWsubset\fR" 4
.IX Item "subset"
If model A is a subset of model B, model A is guaranteed to run
where model B runs. There are no guarantees about the other way.
.PP
\&\fBSince:\fR
2.8.0
.PP
\&\fBCpuModelCompareInfo\fR (Object)
.PP
The result of a \s-1CPU\s0 model comparison.
.PP
\&\fBMembers:\fR
.ie n .IP """result: CpuModelCompareResult""" 4
.el .IP "\f(CWresult: CpuModelCompareResult\fR" 4
.IX Item "result: CpuModelCompareResult"
The result of the compare operation.
.ie n .IP """responsible\-properties: array of string""" 4
.el .IP "\f(CWresponsible\-properties: array of string\fR" 4
.IX Item "responsible-properties: array of string"
List of properties that led to the comparison result
not being identical.
.PP
\&\f(CW\*(C`responsible\-properties\*(C'\fR is a list of \s-1QOM\s0 property names that led to
both CPUs not being detected as identical. For identical models, this
list is empty.
If a \s-1QOM\s0 property is read-only, that means there's no known way to make the
\&\s-1CPU\s0 models identical. If the special property name \*(L"type\*(R" is included, the
models are by definition not identical and cannot be made identical.
.PP
\&\fBSince:\fR
2.8.0
.PP
\&\fBquery-cpu-model-comparison\fR  (Command)
Compares two \s-1CPU\s0 models, returning how they compare in a specific
configuration. The results indicates how both models compare regarding
runnability. This result can be used by tooling to make decisions if a
certain \s-1CPU\s0 model will run in a certain configuration or if a compatible
\&\s-1CPU\s0 model has to be created by baselining.
.PP
Usually, a \s-1CPU\s0 model is compared against the maximum possible \s-1CPU\s0 model
of a certain configuration (e.g. the \*(L"host\*(R" model for \s-1KVM\s0). If that \s-1CPU\s0
model is identical or a subset, it will run in that configuration.
.PP
The result returned by this command may be affected by:
.IP "\(bu" 4
\&\s-1QEMU\s0 version: \s-1CPU\s0 models may look different depending on the \s-1QEMU\s0 version.
(Except for \s-1CPU\s0 models reported as \*(L"static\*(R" in query-cpu-definitions.)
.IP "\(bu" 4
machine-type: \s-1CPU\s0 model may look different depending on the machine-type.
(Except for \s-1CPU\s0 models reported as \*(L"static\*(R" in query-cpu-definitions.)
.IP "\(bu" 4
machine options (including accelerator): in some architectures, \s-1CPU\s0 models
may look different depending on machine and accelerator options. (Except for
\&\s-1CPU\s0 models reported as \*(L"static\*(R" in query-cpu-definitions.)
.IP "\(bu" 4
\&\*(L"\-cpu\*(R" arguments and global properties: arguments to the \-cpu option and
global properties may affect expansion of \s-1CPU\s0 models. Using
query-cpu-model-expansion while using these is not advised.
.PP
Some architectures may not support comparing \s-1CPU\s0 models. s390x supports
comparing \s-1CPU\s0 models.
.PP
\&\fBArguments:\fR
.ie n .IP """modela: CpuModelInfo""" 4
.el .IP "\f(CWmodela: CpuModelInfo\fR" 4
.IX Item "modela: CpuModelInfo"
Not documented
.ie n .IP """modelb: CpuModelInfo""" 4
.el .IP "\f(CWmodelb: CpuModelInfo\fR" 4
.IX Item "modelb: CpuModelInfo"
Not documented
.PP
\&\fBReturns:\fR
a CpuModelBaselineInfo. Returns an error if comparing \s-1CPU\s0 models is
not supported, if a model cannot be used, if a model contains
an unknown cpu definition name, unknown properties or properties
with wrong types.
.PP
\&\fBSince:\fR
2.8.0
.PP
\&\fBCpuModelBaselineInfo\fR (Object)
.PP
The result of a \s-1CPU\s0 model baseline.
.PP
\&\fBMembers:\fR
.ie n .IP """model: CpuModelInfo""" 4
.el .IP "\f(CWmodel: CpuModelInfo\fR" 4
.IX Item "model: CpuModelInfo"
the baselined CpuModelInfo.
.PP
\&\fBSince:\fR
2.8.0
.PP
\&\fBquery-cpu-model-baseline\fR  (Command)
Baseline two \s-1CPU\s0 models, creating a compatible third model. The created
model will always be a static, migration-safe \s-1CPU\s0 model (see \*(L"static\*(R"
\&\s-1CPU\s0 model expansion for details).
.PP
This interface can be used by tooling to create a compatible \s-1CPU\s0 model out
two \s-1CPU\s0 models. The created \s-1CPU\s0 model will be identical to or a subset of
both \s-1CPU\s0 models when comparing them. Therefore, the created \s-1CPU\s0 model is
guaranteed to run where the given \s-1CPU\s0 models run.
.PP
The result returned by this command may be affected by:
.IP "\(bu" 4
\&\s-1QEMU\s0 version: \s-1CPU\s0 models may look different depending on the \s-1QEMU\s0 version.
(Except for \s-1CPU\s0 models reported as \*(L"static\*(R" in query-cpu-definitions.)
.IP "\(bu" 4
machine-type: \s-1CPU\s0 model may look different depending on the machine-type.
(Except for \s-1CPU\s0 models reported as \*(L"static\*(R" in query-cpu-definitions.)
.IP "\(bu" 4
machine options (including accelerator): in some architectures, \s-1CPU\s0 models
may look different depending on machine and accelerator options. (Except for
\&\s-1CPU\s0 models reported as \*(L"static\*(R" in query-cpu-definitions.)
.IP "\(bu" 4
\&\*(L"\-cpu\*(R" arguments and global properties: arguments to the \-cpu option and
global properties may affect expansion of \s-1CPU\s0 models. Using
query-cpu-model-expansion while using these is not advised.
.PP
Some architectures may not support baselining \s-1CPU\s0 models. s390x supports
baselining \s-1CPU\s0 models.
.PP
\&\fBArguments:\fR
.ie n .IP """modela: CpuModelInfo""" 4
.el .IP "\f(CWmodela: CpuModelInfo\fR" 4
.IX Item "modela: CpuModelInfo"
Not documented
.ie n .IP """modelb: CpuModelInfo""" 4
.el .IP "\f(CWmodelb: CpuModelInfo\fR" 4
.IX Item "modelb: CpuModelInfo"
Not documented
.PP
\&\fBReturns:\fR
a CpuModelBaselineInfo. Returns an error if baselining \s-1CPU\s0 models is
not supported, if a model cannot be used, if a model contains
an unknown cpu definition name, unknown properties or properties
with wrong types.
.PP
\&\fBSince:\fR
2.8.0
.PP
\&\fBAddfdInfo\fR (Object)
.PP
Information about a file descriptor that was added to an fd set.
.PP
\&\fBMembers:\fR
.ie n .IP """fdset\-id: int""" 4
.el .IP "\f(CWfdset\-id: int\fR" 4
.IX Item "fdset-id: int"
The \s-1ID\s0 of the fd set that \f(CW\*(C`fd\*(C'\fR was added to.
.ie n .IP """fd: int""" 4
.el .IP "\f(CWfd: int\fR" 4
.IX Item "fd: int"
The file descriptor that was received via \s-1SCM\s0 rights and
added to the fd set.
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBadd-fd\fR  (Command)
Add a file descriptor, that was passed via \s-1SCM\s0 rights, to an fd set.
.PP
\&\fBArguments:\fR
.ie n .IP """fdset\-id: int"" (optional)" 4
.el .IP "\f(CWfdset\-id: int\fR (optional)" 4
.IX Item "fdset-id: int (optional)"
The \s-1ID\s0 of the fd set to add the file descriptor to.
.ie n .IP """opaque: string"" (optional)" 4
.el .IP "\f(CWopaque: string\fR (optional)" 4
.IX Item "opaque: string (optional)"
A free-form string that can be used to describe the fd.
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`AddfdInfo\*(C'\fR on success
.PP
If file descriptor was not received, FdNotSupplied
.PP
If \f(CW\*(C`fdset\-id\*(C'\fR is a negative value, InvalidParameterValue
.PP
\&\fBNotes:\fR
The list of fd sets is shared by all monitor connections.
.PP
If \f(CW\*(C`fdset\-id\*(C'\fR is not specified, a new fd set will be created.
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "add\-fd", "arguments": { "fdset\-id": 1 } }
\&        <\- { "return": { "fdset\-id": 1, "fd": 3 } }
.Ve
.PP
\&\fBremove-fd\fR  (Command)
Remove a file descriptor from an fd set.
.PP
\&\fBArguments:\fR
.ie n .IP """fdset\-id: int""" 4
.el .IP "\f(CWfdset\-id: int\fR" 4
.IX Item "fdset-id: int"
The \s-1ID\s0 of the fd set that the file descriptor belongs to.
.ie n .IP """fd: int"" (optional)" 4
.el .IP "\f(CWfd: int\fR (optional)" 4
.IX Item "fd: int (optional)"
The file descriptor that is to be removed.
.PP
\&\fBReturns:\fR
Nothing on success
If \f(CW\*(C`fdset\-id\*(C'\fR or \f(CW\*(C`fd\*(C'\fR is not found, FdNotFound
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBNotes:\fR
The list of fd sets is shared by all monitor connections.
.PP
If \f(CW\*(C`fd\*(C'\fR is not specified, all file descriptors in \f(CW\*(C`fdset\-id\*(C'\fR
will be removed.
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "remove\-fd", "arguments": { "fdset\-id": 1, "fd": 3 } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBFdsetFdInfo\fR (Object)
.PP
Information about a file descriptor that belongs to an fd set.
.PP
\&\fBMembers:\fR
.ie n .IP """fd: int""" 4
.el .IP "\f(CWfd: int\fR" 4
.IX Item "fd: int"
The file descriptor value.
.ie n .IP """opaque: string"" (optional)" 4
.el .IP "\f(CWopaque: string\fR (optional)" 4
.IX Item "opaque: string (optional)"
A free-form string that can be used to describe the fd.
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBFdsetInfo\fR (Object)
.PP
Information about an fd set.
.PP
\&\fBMembers:\fR
.ie n .IP """fdset\-id: int""" 4
.el .IP "\f(CWfdset\-id: int\fR" 4
.IX Item "fdset-id: int"
The \s-1ID\s0 of the fd set.
.ie n .IP """fds: array of FdsetFdInfo""" 4
.el .IP "\f(CWfds: array of FdsetFdInfo\fR" 4
.IX Item "fds: array of FdsetFdInfo"
A list of file descriptors that belong to this fd set.
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBquery-fdsets\fR  (Command)
Return information describing all fd sets.
.PP
\&\fBReturns:\fR
A list of \f(CW\*(C`FdsetInfo\*(C'\fR
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBNote:\fR
The list of fd sets is shared by all monitor connections.
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-fdsets" }
\&        <\- { "return": [
\&               {
\&                 "fds": [
\&                   {
\&                     "fd": 30,
\&                     "opaque": "rdonly:/path/to/file"
\&                   },
\&                   {
\&                     "fd": 24,
\&                     "opaque": "rdwr:/path/to/file"
\&                   }
\&                 ],
\&                 "fdset\-id": 1
\&               },
\&               {
\&                 "fds": [
\&                   {
\&                     "fd": 28
\&                   },
\&                   {
\&                     "fd": 29
\&                   }
\&                 ],
\&                 "fdset\-id": 0
\&               }
\&             ]
\&           }
.Ve
.PP
\&\fBTargetInfo\fR (Object)
.PP
Information describing the \s-1QEMU\s0 target.
.PP
\&\fBMembers:\fR
.ie n .IP """arch: string""" 4
.el .IP "\f(CWarch: string\fR" 4
.IX Item "arch: string"
the target architecture (eg \*(L"x86_64\*(R", \*(L"i386\*(R", etc)
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBquery-target\fR  (Command)
Return information about the target for this \s-1QEMU\s0
.PP
\&\fBReturns:\fR
TargetInfo
.PP
\&\fBSince:\fR
1.2.0
.PP
\&\fBQKeyCode\fR (Enum)
.PP
An enumeration of key name.
.PP
This is used by the \f(CW\*(C`send\-key\*(C'\fR command.
.PP
\&\fBValues:\fR
.ie n .IP """unmapped""" 4
.el .IP "\f(CWunmapped\fR" 4
.IX Item "unmapped"
since 2.0
.ie n .IP """pause""" 4
.el .IP "\f(CWpause\fR" 4
.IX Item "pause"
since 2.0
.ie n .IP """ro""" 4
.el .IP "\f(CWro\fR" 4
.IX Item "ro"
since 2.4
.ie n .IP """kp_comma""" 4
.el .IP "\f(CWkp_comma\fR" 4
.IX Item "kp_comma"
since 2.4
.ie n .IP """kp_equals""" 4
.el .IP "\f(CWkp_equals\fR" 4
.IX Item "kp_equals"
since 2.6
.ie n .IP """power""" 4
.el .IP "\f(CWpower\fR" 4
.IX Item "power"
since 2.6
.ie n .IP """hiragana""" 4
.el .IP "\f(CWhiragana\fR" 4
.IX Item "hiragana"
since 2.9
.ie n .IP """henkan""" 4
.el .IP "\f(CWhenkan\fR" 4
.IX Item "henkan"
since 2.9
.ie n .IP """yen""" 4
.el .IP "\f(CWyen\fR" 4
.IX Item "yen"
since 2.9
.ie n .IP """sleep""" 4
.el .IP "\f(CWsleep\fR" 4
.IX Item "sleep"
since 2.10
.ie n .IP """wake""" 4
.el .IP "\f(CWwake\fR" 4
.IX Item "wake"
since 2.10
.ie n .IP """audionext""" 4
.el .IP "\f(CWaudionext\fR" 4
.IX Item "audionext"
since 2.10
.ie n .IP """audioprev""" 4
.el .IP "\f(CWaudioprev\fR" 4
.IX Item "audioprev"
since 2.10
.ie n .IP """audiostop""" 4
.el .IP "\f(CWaudiostop\fR" 4
.IX Item "audiostop"
since 2.10
.ie n .IP """audioplay""" 4
.el .IP "\f(CWaudioplay\fR" 4
.IX Item "audioplay"
since 2.10
.ie n .IP """audiomute""" 4
.el .IP "\f(CWaudiomute\fR" 4
.IX Item "audiomute"
since 2.10
.ie n .IP """volumeup""" 4
.el .IP "\f(CWvolumeup\fR" 4
.IX Item "volumeup"
since 2.10
.ie n .IP """volumedown""" 4
.el .IP "\f(CWvolumedown\fR" 4
.IX Item "volumedown"
since 2.10
.ie n .IP """mediaselect""" 4
.el .IP "\f(CWmediaselect\fR" 4
.IX Item "mediaselect"
since 2.10
.ie n .IP """mail""" 4
.el .IP "\f(CWmail\fR" 4
.IX Item "mail"
since 2.10
.ie n .IP """calculator""" 4
.el .IP "\f(CWcalculator\fR" 4
.IX Item "calculator"
since 2.10
.ie n .IP """computer""" 4
.el .IP "\f(CWcomputer\fR" 4
.IX Item "computer"
since 2.10
.ie n .IP """ac_home""" 4
.el .IP "\f(CWac_home\fR" 4
.IX Item "ac_home"
since 2.10
.ie n .IP """ac_back""" 4
.el .IP "\f(CWac_back\fR" 4
.IX Item "ac_back"
since 2.10
.ie n .IP """ac_forward""" 4
.el .IP "\f(CWac_forward\fR" 4
.IX Item "ac_forward"
since 2.10
.ie n .IP """ac_refresh""" 4
.el .IP "\f(CWac_refresh\fR" 4
.IX Item "ac_refresh"
since 2.10
.ie n .IP """ac_bookmarks""" 4
.el .IP "\f(CWac_bookmarks\fR" 4
.IX Item "ac_bookmarks"
since 2.10
altgr, altgr_r: dropped in 2.10
.ie n .IP """shift""" 4
.el .IP "\f(CWshift\fR" 4
.IX Item "shift"
Not documented
.ie n .IP """shift_r""" 4
.el .IP "\f(CWshift_r\fR" 4
.IX Item "shift_r"
Not documented
.ie n .IP """alt""" 4
.el .IP "\f(CWalt\fR" 4
.IX Item "alt"
Not documented
.ie n .IP """alt_r""" 4
.el .IP "\f(CWalt_r\fR" 4
.IX Item "alt_r"
Not documented
.ie n .IP """ctrl""" 4
.el .IP "\f(CWctrl\fR" 4
.IX Item "ctrl"
Not documented
.ie n .IP """ctrl_r""" 4
.el .IP "\f(CWctrl_r\fR" 4
.IX Item "ctrl_r"
Not documented
.ie n .IP """menu""" 4
.el .IP "\f(CWmenu\fR" 4
.IX Item "menu"
Not documented
.ie n .IP """esc""" 4
.el .IP "\f(CWesc\fR" 4
.IX Item "esc"
Not documented
.ie n .IP "1" 4
.el .IP "\f(CW1\fR" 4
.IX Item "1"
Not documented
.ie n .IP "2" 4
.el .IP "\f(CW2\fR" 4
.IX Item "2"
Not documented
.ie n .IP "3" 4
.el .IP "\f(CW3\fR" 4
.IX Item "3"
Not documented
.ie n .IP "4" 4
.el .IP "\f(CW4\fR" 4
.IX Item "4"
Not documented
.ie n .IP "5" 4
.el .IP "\f(CW5\fR" 4
.IX Item "5"
Not documented
.ie n .IP "6" 4
.el .IP "\f(CW6\fR" 4
.IX Item "6"
Not documented
.ie n .IP "7" 4
.el .IP "\f(CW7\fR" 4
.IX Item "7"
Not documented
.ie n .IP "8" 4
.el .IP "\f(CW8\fR" 4
.IX Item "8"
Not documented
.ie n .IP "9" 4
.el .IP "\f(CW9\fR" 4
.IX Item "9"
Not documented
.ie n .IP "0" 4
.el .IP "\f(CW0\fR" 4
.IX Item "0"
Not documented
.ie n .IP """minus""" 4
.el .IP "\f(CWminus\fR" 4
.IX Item "minus"
Not documented
.ie n .IP """equal""" 4
.el .IP "\f(CWequal\fR" 4
.IX Item "equal"
Not documented
.ie n .IP """backspace""" 4
.el .IP "\f(CWbackspace\fR" 4
.IX Item "backspace"
Not documented
.ie n .IP """tab""" 4
.el .IP "\f(CWtab\fR" 4
.IX Item "tab"
Not documented
.ie n .IP """q""" 4
.el .IP "\f(CWq\fR" 4
.IX Item "q"
Not documented
.ie n .IP """w""" 4
.el .IP "\f(CWw\fR" 4
.IX Item "w"
Not documented
.ie n .IP """e""" 4
.el .IP "\f(CWe\fR" 4
.IX Item "e"
Not documented
.ie n .IP """r""" 4
.el .IP "\f(CWr\fR" 4
.IX Item "r"
Not documented
.ie n .IP """t""" 4
.el .IP "\f(CWt\fR" 4
.IX Item "t"
Not documented
.ie n .IP """y""" 4
.el .IP "\f(CWy\fR" 4
.IX Item "y"
Not documented
.ie n .IP """u""" 4
.el .IP "\f(CWu\fR" 4
.IX Item "u"
Not documented
.ie n .IP """i""" 4
.el .IP "\f(CWi\fR" 4
.IX Item "i"
Not documented
.ie n .IP """o""" 4
.el .IP "\f(CWo\fR" 4
.IX Item "o"
Not documented
.ie n .IP """p""" 4
.el .IP "\f(CWp\fR" 4
.IX Item "p"
Not documented
.ie n .IP """bracket_left""" 4
.el .IP "\f(CWbracket_left\fR" 4
.IX Item "bracket_left"
Not documented
.ie n .IP """bracket_right""" 4
.el .IP "\f(CWbracket_right\fR" 4
.IX Item "bracket_right"
Not documented
.ie n .IP """ret""" 4
.el .IP "\f(CWret\fR" 4
.IX Item "ret"
Not documented
.ie n .IP """a""" 4
.el .IP "\f(CWa\fR" 4
.IX Item "a"
Not documented
.ie n .IP """s""" 4
.el .IP "\f(CWs\fR" 4
.IX Item "s"
Not documented
.ie n .IP """d""" 4
.el .IP "\f(CWd\fR" 4
.IX Item "d"
Not documented
.ie n .IP """f""" 4
.el .IP "\f(CWf\fR" 4
.IX Item "f"
Not documented
.ie n .IP """g""" 4
.el .IP "\f(CWg\fR" 4
.IX Item "g"
Not documented
.ie n .IP """h""" 4
.el .IP "\f(CWh\fR" 4
.IX Item "h"
Not documented
.ie n .IP """j""" 4
.el .IP "\f(CWj\fR" 4
.IX Item "j"
Not documented
.ie n .IP """k""" 4
.el .IP "\f(CWk\fR" 4
.IX Item "k"
Not documented
.ie n .IP """l""" 4
.el .IP "\f(CWl\fR" 4
.IX Item "l"
Not documented
.ie n .IP """semicolon""" 4
.el .IP "\f(CWsemicolon\fR" 4
.IX Item "semicolon"
Not documented
.ie n .IP """apostrophe""" 4
.el .IP "\f(CWapostrophe\fR" 4
.IX Item "apostrophe"
Not documented
.ie n .IP """grave_accent""" 4
.el .IP "\f(CWgrave_accent\fR" 4
.IX Item "grave_accent"
Not documented
.ie n .IP """backslash""" 4
.el .IP "\f(CWbackslash\fR" 4
.IX Item "backslash"
Not documented
.ie n .IP """z""" 4
.el .IP "\f(CWz\fR" 4
.IX Item "z"
Not documented
.ie n .IP """x""" 4
.el .IP "\f(CWx\fR" 4
.IX Item "x"
Not documented
.ie n .IP """c""" 4
.el .IP "\f(CWc\fR" 4
.IX Item "c"
Not documented
.ie n .IP """v""" 4
.el .IP "\f(CWv\fR" 4
.IX Item "v"
Not documented
.ie n .IP """b""" 4
.el .IP "\f(CWb\fR" 4
.IX Item "b"
Not documented
.ie n .IP """n""" 4
.el .IP "\f(CWn\fR" 4
.IX Item "n"
Not documented
.ie n .IP """m""" 4
.el .IP "\f(CWm\fR" 4
.IX Item "m"
Not documented
.ie n .IP """comma""" 4
.el .IP "\f(CWcomma\fR" 4
.IX Item "comma"
Not documented
.ie n .IP """dot""" 4
.el .IP "\f(CWdot\fR" 4
.IX Item "dot"
Not documented
.ie n .IP """slash""" 4
.el .IP "\f(CWslash\fR" 4
.IX Item "slash"
Not documented
.ie n .IP """asterisk""" 4
.el .IP "\f(CWasterisk\fR" 4
.IX Item "asterisk"
Not documented
.ie n .IP """spc""" 4
.el .IP "\f(CWspc\fR" 4
.IX Item "spc"
Not documented
.ie n .IP """caps_lock""" 4
.el .IP "\f(CWcaps_lock\fR" 4
.IX Item "caps_lock"
Not documented
.ie n .IP """f1""" 4
.el .IP "\f(CWf1\fR" 4
.IX Item "f1"
Not documented
.ie n .IP """f2""" 4
.el .IP "\f(CWf2\fR" 4
.IX Item "f2"
Not documented
.ie n .IP """f3""" 4
.el .IP "\f(CWf3\fR" 4
.IX Item "f3"
Not documented
.ie n .IP """f4""" 4
.el .IP "\f(CWf4\fR" 4
.IX Item "f4"
Not documented
.ie n .IP """f5""" 4
.el .IP "\f(CWf5\fR" 4
.IX Item "f5"
Not documented
.ie n .IP """f6""" 4
.el .IP "\f(CWf6\fR" 4
.IX Item "f6"
Not documented
.ie n .IP """f7""" 4
.el .IP "\f(CWf7\fR" 4
.IX Item "f7"
Not documented
.ie n .IP """f8""" 4
.el .IP "\f(CWf8\fR" 4
.IX Item "f8"
Not documented
.ie n .IP """f9""" 4
.el .IP "\f(CWf9\fR" 4
.IX Item "f9"
Not documented
.ie n .IP """f10""" 4
.el .IP "\f(CWf10\fR" 4
.IX Item "f10"
Not documented
.ie n .IP """num_lock""" 4
.el .IP "\f(CWnum_lock\fR" 4
.IX Item "num_lock"
Not documented
.ie n .IP """scroll_lock""" 4
.el .IP "\f(CWscroll_lock\fR" 4
.IX Item "scroll_lock"
Not documented
.ie n .IP """kp_divide""" 4
.el .IP "\f(CWkp_divide\fR" 4
.IX Item "kp_divide"
Not documented
.ie n .IP """kp_multiply""" 4
.el .IP "\f(CWkp_multiply\fR" 4
.IX Item "kp_multiply"
Not documented
.ie n .IP """kp_subtract""" 4
.el .IP "\f(CWkp_subtract\fR" 4
.IX Item "kp_subtract"
Not documented
.ie n .IP """kp_add""" 4
.el .IP "\f(CWkp_add\fR" 4
.IX Item "kp_add"
Not documented
.ie n .IP """kp_enter""" 4
.el .IP "\f(CWkp_enter\fR" 4
.IX Item "kp_enter"
Not documented
.ie n .IP """kp_decimal""" 4
.el .IP "\f(CWkp_decimal\fR" 4
.IX Item "kp_decimal"
Not documented
.ie n .IP """sysrq""" 4
.el .IP "\f(CWsysrq\fR" 4
.IX Item "sysrq"
Not documented
.ie n .IP """kp_0""" 4
.el .IP "\f(CWkp_0\fR" 4
.IX Item "kp_0"
Not documented
.ie n .IP """kp_1""" 4
.el .IP "\f(CWkp_1\fR" 4
.IX Item "kp_1"
Not documented
.ie n .IP """kp_2""" 4
.el .IP "\f(CWkp_2\fR" 4
.IX Item "kp_2"
Not documented
.ie n .IP """kp_3""" 4
.el .IP "\f(CWkp_3\fR" 4
.IX Item "kp_3"
Not documented
.ie n .IP """kp_4""" 4
.el .IP "\f(CWkp_4\fR" 4
.IX Item "kp_4"
Not documented
.ie n .IP """kp_5""" 4
.el .IP "\f(CWkp_5\fR" 4
.IX Item "kp_5"
Not documented
.ie n .IP """kp_6""" 4
.el .IP "\f(CWkp_6\fR" 4
.IX Item "kp_6"
Not documented
.ie n .IP """kp_7""" 4
.el .IP "\f(CWkp_7\fR" 4
.IX Item "kp_7"
Not documented
.ie n .IP """kp_8""" 4
.el .IP "\f(CWkp_8\fR" 4
.IX Item "kp_8"
Not documented
.ie n .IP """kp_9""" 4
.el .IP "\f(CWkp_9\fR" 4
.IX Item "kp_9"
Not documented
.ie n .IP """less""" 4
.el .IP "\f(CWless\fR" 4
.IX Item "less"
Not documented
.ie n .IP """f11""" 4
.el .IP "\f(CWf11\fR" 4
.IX Item "f11"
Not documented
.ie n .IP """f12""" 4
.el .IP "\f(CWf12\fR" 4
.IX Item "f12"
Not documented
.ie n .IP """print""" 4
.el .IP "\f(CWprint\fR" 4
.IX Item "print"
Not documented
.ie n .IP """home""" 4
.el .IP "\f(CWhome\fR" 4
.IX Item "home"
Not documented
.ie n .IP """pgup""" 4
.el .IP "\f(CWpgup\fR" 4
.IX Item "pgup"
Not documented
.ie n .IP """pgdn""" 4
.el .IP "\f(CWpgdn\fR" 4
.IX Item "pgdn"
Not documented
.ie n .IP """end""" 4
.el .IP "\f(CWend\fR" 4
.IX Item "end"
Not documented
.ie n .IP """left""" 4
.el .IP "\f(CWleft\fR" 4
.IX Item "left"
Not documented
.ie n .IP """up""" 4
.el .IP "\f(CWup\fR" 4
.IX Item "up"
Not documented
.ie n .IP """down""" 4
.el .IP "\f(CWdown\fR" 4
.IX Item "down"
Not documented
.ie n .IP """right""" 4
.el .IP "\f(CWright\fR" 4
.IX Item "right"
Not documented
.ie n .IP """insert""" 4
.el .IP "\f(CWinsert\fR" 4
.IX Item "insert"
Not documented
.ie n .IP """delete""" 4
.el .IP "\f(CWdelete\fR" 4
.IX Item "delete"
Not documented
.ie n .IP """stop""" 4
.el .IP "\f(CWstop\fR" 4
.IX Item "stop"
Not documented
.ie n .IP """again""" 4
.el .IP "\f(CWagain\fR" 4
.IX Item "again"
Not documented
.ie n .IP """props""" 4
.el .IP "\f(CWprops\fR" 4
.IX Item "props"
Not documented
.ie n .IP """undo""" 4
.el .IP "\f(CWundo\fR" 4
.IX Item "undo"
Not documented
.ie n .IP """front""" 4
.el .IP "\f(CWfront\fR" 4
.IX Item "front"
Not documented
.ie n .IP """copy""" 4
.el .IP "\f(CWcopy\fR" 4
.IX Item "copy"
Not documented
.ie n .IP """open""" 4
.el .IP "\f(CWopen\fR" 4
.IX Item "open"
Not documented
.ie n .IP """paste""" 4
.el .IP "\f(CWpaste\fR" 4
.IX Item "paste"
Not documented
.ie n .IP """find""" 4
.el .IP "\f(CWfind\fR" 4
.IX Item "find"
Not documented
.ie n .IP """cut""" 4
.el .IP "\f(CWcut\fR" 4
.IX Item "cut"
Not documented
.ie n .IP """lf""" 4
.el .IP "\f(CWlf\fR" 4
.IX Item "lf"
Not documented
.ie n .IP """help""" 4
.el .IP "\f(CWhelp\fR" 4
.IX Item "help"
Not documented
.ie n .IP """meta_l""" 4
.el .IP "\f(CWmeta_l\fR" 4
.IX Item "meta_l"
Not documented
.ie n .IP """meta_r""" 4
.el .IP "\f(CWmeta_r\fR" 4
.IX Item "meta_r"
Not documented
.ie n .IP """compose""" 4
.el .IP "\f(CWcompose\fR" 4
.IX Item "compose"
Not documented
.PP
\&\fBSince:\fR
1.3.0
.PP
\&\fBKeyValue\fR (Object)
.PP
Represents a keyboard key.
.PP
\&\fBMembers:\fR
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
One of \*(L"number\*(R", \*(L"qcode\*(R"
.ie n .IP """data: int"" when ""type"" is ""number""" 4
.el .IP "\f(CWdata: int\fR when \f(CWtype\fR is ``number''" 4
.IX Item "data: int when type is number"
.PD 0
.ie n .IP """data: QKeyCode"" when ""type"" is ""qcode""" 4
.el .IP "\f(CWdata: QKeyCode\fR when \f(CWtype\fR is ``qcode''" 4
.IX Item "data: QKeyCode when type is qcode"
.PD
.PP
\&\fBSince:\fR
1.3.0
.PP
\&\fBsend-key\fR  (Command)
Send keys to guest.
.PP
\&\fBArguments:\fR
.ie n .IP """keys: array of KeyValue""" 4
.el .IP "\f(CWkeys: array of KeyValue\fR" 4
.IX Item "keys: array of KeyValue"
An array of \f(CW\*(C`KeyValue\*(C'\fR elements. All \f(CW\*(C`KeyValues\*(C'\fR in this array are
simultaneously sent to the guest. A \f(CW\*(C`KeyValue\*(C'\fR.number value is sent
directly to the guest, while \f(CW\*(C`KeyValue\*(C'\fR.qcode must be a valid
\&\f(CW\*(C`QKeyCode\*(C'\fR value
.ie n .IP """hold\-time: int"" (optional)" 4
.el .IP "\f(CWhold\-time: int\fR (optional)" 4
.IX Item "hold-time: int (optional)"
time to delay key up events, milliseconds. Defaults
to 100
.PP
\&\fBReturns:\fR
Nothing on success
If key is unknown or redundant, InvalidParameter
.PP
\&\fBSince:\fR
1.3.0
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&        \-> { "execute": "send\-key",
\&             "arguments": { "keys": [ { "type": "qcode", "data": "ctrl" },
\&                                      { "type": "qcode", "data": "alt" },
\&                                      { "type": "qcode", "data": "delete" } ] } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBscreendump\fR  (Command)
Write a \s-1PPM\s0 of the \s-1VGA\s0 screen to a file.
.PP
\&\fBArguments:\fR
.ie n .IP """filename: string""" 4
.el .IP "\f(CWfilename: string\fR" 4
.IX Item "filename: string"
the path of a new \s-1PPM\s0 file to store the image
.PP
\&\fBReturns:\fR
Nothing on success
.PP
\&\fBSince:\fR
0.14.0
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "screendump",
\&             "arguments": { "filename": "/tmp/image" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBChardevCommon\fR (Object)
.PP
Configuration shared across all chardev backends
.PP
\&\fBMembers:\fR
.ie n .IP """logfile: string"" (optional)" 4
.el .IP "\f(CWlogfile: string\fR (optional)" 4
.IX Item "logfile: string (optional)"
The name of a logfile to save output
.ie n .IP """logappend: boolean"" (optional)" 4
.el .IP "\f(CWlogappend: boolean\fR (optional)" 4
.IX Item "logappend: boolean (optional)"
true to append instead of truncate
(default to false to truncate)
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBChardevFile\fR (Object)
.PP
Configuration info for file chardevs.
.PP
\&\fBMembers:\fR
.ie n .IP """in: string"" (optional)" 4
.el .IP "\f(CWin: string\fR (optional)" 4
.IX Item "in: string (optional)"
The name of the input file
.ie n .IP """out: string""" 4
.el .IP "\f(CWout: string\fR" 4
.IX Item "out: string"
The name of the output file
.ie n .IP """append: boolean"" (optional)" 4
.el .IP "\f(CWappend: boolean\fR (optional)" 4
.IX Item "append: boolean (optional)"
Open the file in append mode (default false to
truncate) (Since 2.6)
.ie n .IP "The members of ""ChardevCommon""" 4
.el .IP "The members of \f(CWChardevCommon\fR" 4
.IX Item "The members of ChardevCommon"
.PP
\&\fBSince:\fR
1.4
.PP
\&\fBChardevHostdev\fR (Object)
.PP
Configuration info for device and pipe chardevs.
.PP
\&\fBMembers:\fR
.ie n .IP """device: string""" 4
.el .IP "\f(CWdevice: string\fR" 4
.IX Item "device: string"
The name of the special file for the device,
i.e. /dev/ttyS0 on Unix or \s-1COM1:\s0 on Windows
.ie n .IP "The members of ""ChardevCommon""" 4
.el .IP "The members of \f(CWChardevCommon\fR" 4
.IX Item "The members of ChardevCommon"
.PP
\&\fBSince:\fR
1.4
.PP
\&\fBChardevSocket\fR (Object)
.PP
Configuration info for (stream) socket chardevs.
.PP
\&\fBMembers:\fR
.ie n .IP """addr: SocketAddressLegacy""" 4
.el .IP "\f(CWaddr: SocketAddressLegacy\fR" 4
.IX Item "addr: SocketAddressLegacy"
socket address to listen on (server=true)
or connect to (server=false)
.ie n .IP """tls\-creds: string"" (optional)" 4
.el .IP "\f(CWtls\-creds: string\fR (optional)" 4
.IX Item "tls-creds: string (optional)"
the \s-1ID\s0 of the \s-1TLS\s0 credentials object (since 2.6)
.ie n .IP """server: boolean"" (optional)" 4
.el .IP "\f(CWserver: boolean\fR (optional)" 4
.IX Item "server: boolean (optional)"
create server socket (default: true)
.ie n .IP """wait: boolean"" (optional)" 4
.el .IP "\f(CWwait: boolean\fR (optional)" 4
.IX Item "wait: boolean (optional)"
wait for incoming connection on server
sockets (default: false).
.ie n .IP """nodelay: boolean"" (optional)" 4
.el .IP "\f(CWnodelay: boolean\fR (optional)" 4
.IX Item "nodelay: boolean (optional)"
set \s-1TCP_NODELAY\s0 socket option (default: false)
.ie n .IP """telnet: boolean"" (optional)" 4
.el .IP "\f(CWtelnet: boolean\fR (optional)" 4
.IX Item "telnet: boolean (optional)"
enable telnet protocol on server
sockets (default: false)
.ie n .IP """tn3270: boolean"" (optional)" 4
.el .IP "\f(CWtn3270: boolean\fR (optional)" 4
.IX Item "tn3270: boolean (optional)"
enable tn3270 protocol on server
sockets (default: false) (Since: 2.10)
.ie n .IP """reconnect: int"" (optional)" 4
.el .IP "\f(CWreconnect: int\fR (optional)" 4
.IX Item "reconnect: int (optional)"
For a client socket, if a socket is disconnected,
then attempt a reconnect after the given number of seconds.
Setting this to zero disables this function. (default: 0)
(Since: 2.2)
.ie n .IP "The members of ""ChardevCommon""" 4
.el .IP "The members of \f(CWChardevCommon\fR" 4
.IX Item "The members of ChardevCommon"
.PP
\&\fBSince:\fR
1.4
.PP
\&\fBChardevUdp\fR (Object)
.PP
Configuration info for datagram socket chardevs.
.PP
\&\fBMembers:\fR
.ie n .IP """remote: SocketAddressLegacy""" 4
.el .IP "\f(CWremote: SocketAddressLegacy\fR" 4
.IX Item "remote: SocketAddressLegacy"
remote address
.ie n .IP """local: SocketAddressLegacy"" (optional)" 4
.el .IP "\f(CWlocal: SocketAddressLegacy\fR (optional)" 4
.IX Item "local: SocketAddressLegacy (optional)"
local address
.ie n .IP "The members of ""ChardevCommon""" 4
.el .IP "The members of \f(CWChardevCommon\fR" 4
.IX Item "The members of ChardevCommon"
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBChardevMux\fR (Object)
.PP
Configuration info for mux chardevs.
.PP
\&\fBMembers:\fR
.ie n .IP """chardev: string""" 4
.el .IP "\f(CWchardev: string\fR" 4
.IX Item "chardev: string"
name of the base chardev.
.ie n .IP "The members of ""ChardevCommon""" 4
.el .IP "The members of \f(CWChardevCommon\fR" 4
.IX Item "The members of ChardevCommon"
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBChardevStdio\fR (Object)
.PP
Configuration info for stdio chardevs.
.PP
\&\fBMembers:\fR
.ie n .IP """signal: boolean"" (optional)" 4
.el .IP "\f(CWsignal: boolean\fR (optional)" 4
.IX Item "signal: boolean (optional)"
Allow signals (such as \s-1SIGINT\s0 triggered by ^C)
be delivered to qemu.  Default: true in \-nographic mode,
false otherwise.
.ie n .IP "The members of ""ChardevCommon""" 4
.el .IP "The members of \f(CWChardevCommon\fR" 4
.IX Item "The members of ChardevCommon"
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBChardevSpiceChannel\fR (Object)
.PP
Configuration info for spice vm channel chardevs.
.PP
\&\fBMembers:\fR
.ie n .IP """type: string""" 4
.el .IP "\f(CWtype: string\fR" 4
.IX Item "type: string"
kind of channel (for example vdagent).
.ie n .IP "The members of ""ChardevCommon""" 4
.el .IP "The members of \f(CWChardevCommon\fR" 4
.IX Item "The members of ChardevCommon"
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBChardevSpicePort\fR (Object)
.PP
Configuration info for spice port chardevs.
.PP
\&\fBMembers:\fR
.ie n .IP """fqdn: string""" 4
.el .IP "\f(CWfqdn: string\fR" 4
.IX Item "fqdn: string"
name of the channel (see docs/spice\-port\-fqdn.txt)
.ie n .IP "The members of ""ChardevCommon""" 4
.el .IP "The members of \f(CWChardevCommon\fR" 4
.IX Item "The members of ChardevCommon"
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBChardevVC\fR (Object)
.PP
Configuration info for virtual console chardevs.
.PP
\&\fBMembers:\fR
.ie n .IP """width: int"" (optional)" 4
.el .IP "\f(CWwidth: int\fR (optional)" 4
.IX Item "width: int (optional)"
console width,  in pixels
.ie n .IP """height: int"" (optional)" 4
.el .IP "\f(CWheight: int\fR (optional)" 4
.IX Item "height: int (optional)"
console height, in pixels
.ie n .IP """cols: int"" (optional)" 4
.el .IP "\f(CWcols: int\fR (optional)" 4
.IX Item "cols: int (optional)"
console width,  in chars
.ie n .IP """rows: int"" (optional)" 4
.el .IP "\f(CWrows: int\fR (optional)" 4
.IX Item "rows: int (optional)"
console height, in chars
.ie n .IP "The members of ""ChardevCommon""" 4
.el .IP "The members of \f(CWChardevCommon\fR" 4
.IX Item "The members of ChardevCommon"
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBChardevRingbuf\fR (Object)
.PP
Configuration info for ring buffer chardevs.
.PP
\&\fBMembers:\fR
.ie n .IP """size: int"" (optional)" 4
.el .IP "\f(CWsize: int\fR (optional)" 4
.IX Item "size: int (optional)"
ring buffer size, must be power of two, default is 65536
.ie n .IP "The members of ""ChardevCommon""" 4
.el .IP "The members of \f(CWChardevCommon\fR" 4
.IX Item "The members of ChardevCommon"
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBChardevBackend\fR (Object)
.PP
Configuration info for the new chardev backend.
.PP
\&\fBMembers:\fR
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
One of \*(L"file\*(R", \*(L"serial\*(R", \*(L"parallel\*(R", \*(L"pipe\*(R", \*(L"socket\*(R", \*(L"udp\*(R", \*(L"pty\*(R", \*(L"null\*(R", \*(L"mux\*(R", \*(L"msmouse\*(R", \*(L"wctablet\*(R", \*(L"braille\*(R", \*(L"testdev\*(R", \*(L"stdio\*(R", \*(L"console\*(R", \*(L"spicevmc\*(R", \*(L"spiceport\*(R", \*(L"vc\*(R", \*(L"ringbuf\*(R", \*(L"memory\*(R"
.ie n .IP """data: ChardevFile"" when ""type"" is ""file""" 4
.el .IP "\f(CWdata: ChardevFile\fR when \f(CWtype\fR is ``file''" 4
.IX Item "data: ChardevFile when type is file"
.PD 0
.ie n .IP """data: ChardevHostdev"" when ""type"" is ""serial""" 4
.el .IP "\f(CWdata: ChardevHostdev\fR when \f(CWtype\fR is ``serial''" 4
.IX Item "data: ChardevHostdev when type is serial"
.ie n .IP """data: ChardevHostdev"" when ""type"" is ""parallel""" 4
.el .IP "\f(CWdata: ChardevHostdev\fR when \f(CWtype\fR is ``parallel''" 4
.IX Item "data: ChardevHostdev when type is parallel"
.ie n .IP """data: ChardevHostdev"" when ""type"" is ""pipe""" 4
.el .IP "\f(CWdata: ChardevHostdev\fR when \f(CWtype\fR is ``pipe''" 4
.IX Item "data: ChardevHostdev when type is pipe"
.ie n .IP """data: ChardevSocket"" when ""type"" is ""socket""" 4
.el .IP "\f(CWdata: ChardevSocket\fR when \f(CWtype\fR is ``socket''" 4
.IX Item "data: ChardevSocket when type is socket"
.ie n .IP """data: ChardevUdp"" when ""type"" is ""udp""" 4
.el .IP "\f(CWdata: ChardevUdp\fR when \f(CWtype\fR is ``udp''" 4
.IX Item "data: ChardevUdp when type is udp"
.ie n .IP """data: ChardevCommon"" when ""type"" is ""pty""" 4
.el .IP "\f(CWdata: ChardevCommon\fR when \f(CWtype\fR is ``pty''" 4
.IX Item "data: ChardevCommon when type is pty"
.ie n .IP """data: ChardevCommon"" when ""type"" is ""null""" 4
.el .IP "\f(CWdata: ChardevCommon\fR when \f(CWtype\fR is ``null''" 4
.IX Item "data: ChardevCommon when type is null"
.ie n .IP """data: ChardevMux"" when ""type"" is ""mux""" 4
.el .IP "\f(CWdata: ChardevMux\fR when \f(CWtype\fR is ``mux''" 4
.IX Item "data: ChardevMux when type is mux"
.ie n .IP """data: ChardevCommon"" when ""type"" is ""msmouse""" 4
.el .IP "\f(CWdata: ChardevCommon\fR when \f(CWtype\fR is ``msmouse''" 4
.IX Item "data: ChardevCommon when type is msmouse"
.ie n .IP """data: ChardevCommon"" when ""type"" is ""wctablet""" 4
.el .IP "\f(CWdata: ChardevCommon\fR when \f(CWtype\fR is ``wctablet''" 4
.IX Item "data: ChardevCommon when type is wctablet"
.ie n .IP """data: ChardevCommon"" when ""type"" is ""braille""" 4
.el .IP "\f(CWdata: ChardevCommon\fR when \f(CWtype\fR is ``braille''" 4
.IX Item "data: ChardevCommon when type is braille"
.ie n .IP """data: ChardevCommon"" when ""type"" is ""testdev""" 4
.el .IP "\f(CWdata: ChardevCommon\fR when \f(CWtype\fR is ``testdev''" 4
.IX Item "data: ChardevCommon when type is testdev"
.ie n .IP """data: ChardevStdio"" when ""type"" is ""stdio""" 4
.el .IP "\f(CWdata: ChardevStdio\fR when \f(CWtype\fR is ``stdio''" 4
.IX Item "data: ChardevStdio when type is stdio"
.ie n .IP """data: ChardevCommon"" when ""type"" is ""console""" 4
.el .IP "\f(CWdata: ChardevCommon\fR when \f(CWtype\fR is ``console''" 4
.IX Item "data: ChardevCommon when type is console"
.ie n .IP """data: ChardevSpiceChannel"" when ""type"" is ""spicevmc""" 4
.el .IP "\f(CWdata: ChardevSpiceChannel\fR when \f(CWtype\fR is ``spicevmc''" 4
.IX Item "data: ChardevSpiceChannel when type is spicevmc"
.ie n .IP """data: ChardevSpicePort"" when ""type"" is ""spiceport""" 4
.el .IP "\f(CWdata: ChardevSpicePort\fR when \f(CWtype\fR is ``spiceport''" 4
.IX Item "data: ChardevSpicePort when type is spiceport"
.ie n .IP """data: ChardevVC"" when ""type"" is ""vc""" 4
.el .IP "\f(CWdata: ChardevVC\fR when \f(CWtype\fR is ``vc''" 4
.IX Item "data: ChardevVC when type is vc"
.ie n .IP """data: ChardevRingbuf"" when ""type"" is ""ringbuf""" 4
.el .IP "\f(CWdata: ChardevRingbuf\fR when \f(CWtype\fR is ``ringbuf''" 4
.IX Item "data: ChardevRingbuf when type is ringbuf"
.ie n .IP """data: ChardevRingbuf"" when ""type"" is ""memory""" 4
.el .IP "\f(CWdata: ChardevRingbuf\fR when \f(CWtype\fR is ``memory''" 4
.IX Item "data: ChardevRingbuf when type is memory"
.PD
.PP
\&\fBSince:\fR
1.4 (testdev since 2.2, wctablet since 2.9)
.PP
\&\fBChardevReturn\fR (Object)
.PP
Return info about the chardev backend just created.
.PP
\&\fBMembers:\fR
.ie n .IP """pty: string"" (optional)" 4
.el .IP "\f(CWpty: string\fR (optional)" 4
.IX Item "pty: string (optional)"
name of the slave pseudoterminal device, present if
and only if a chardev of type 'pty' was created
.PP
\&\fBSince:\fR
1.4
.PP
\&\fBchardev-add\fR  (Command)
Add a character device backend
.PP
\&\fBArguments:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
the chardev's \s-1ID,\s0 must be unique
.ie n .IP """backend: ChardevBackend""" 4
.el .IP "\f(CWbackend: ChardevBackend\fR" 4
.IX Item "backend: ChardevBackend"
backend type and parameters
.PP
\&\fBReturns:\fR
ChardevReturn.
.PP
\&\fBSince:\fR
1.4
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&        \-> { "execute" : "chardev\-add",
\&             "arguments" : { "id" : "foo",
\&                             "backend" : { "type" : "null", "data" : {} } } }
\&        <\- { "return": {} }
\&        
\&        \-> { "execute" : "chardev\-add",
\&             "arguments" : { "id" : "bar",
\&                             "backend" : { "type" : "file",
\&                                           "data" : { "out" : "/tmp/bar.log" } } } }
\&        <\- { "return": {} }
\&        
\&        \-> { "execute" : "chardev\-add",
\&             "arguments" : { "id" : "baz",
\&                             "backend" : { "type" : "pty", "data" : {} } } }
\&        <\- { "return": { "pty" : "/dev/pty/42" } }
.Ve
.PP
\&\fBchardev-change\fR  (Command)
Change a character device backend
.PP
\&\fBArguments:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
the chardev's \s-1ID,\s0 must exist
.ie n .IP """backend: ChardevBackend""" 4
.el .IP "\f(CWbackend: ChardevBackend\fR" 4
.IX Item "backend: ChardevBackend"
new backend type and parameters
.PP
\&\fBReturns:\fR
ChardevReturn.
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&        \-> { "execute" : "chardev\-change",
\&             "arguments" : { "id" : "baz",
\&                             "backend" : { "type" : "pty", "data" : {} } } }
\&        <\- { "return": { "pty" : "/dev/pty/42" } }
\&        
\&        \-> {"execute" : "chardev\-change",
\&            "arguments" : {
\&                "id" : "charchannel2",
\&                "backend" : {
\&                    "type" : "socket",
\&                    "data" : {
\&                        "addr" : {
\&                            "type" : "unix" ,
\&                            "data" : {
\&                                "path" : "/tmp/charchannel2.socket"
\&                            }
\&                         },
\&                         "server" : true,
\&                         "wait" : false }}}}
\&        <\- {"return": {}}
.Ve
.PP
\&\fBchardev-remove\fR  (Command)
Remove a character device backend
.PP
\&\fBArguments:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
the chardev's \s-1ID,\s0 must exist and not be in use
.PP
\&\fBReturns:\fR
Nothing on success
.PP
\&\fBSince:\fR
1.4
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "chardev\-remove", "arguments": { "id" : "foo" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBchardev-send-break\fR  (Command)
Send a break to a character device
.PP
\&\fBArguments:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
the chardev's \s-1ID,\s0 must exist
.PP
\&\fBReturns:\fR
Nothing on success
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "chardev\-send\-break", "arguments": { "id" : "foo" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBTpmModel\fR (Enum)
.PP
An enumeration of \s-1TPM\s0 models
.PP
\&\fBValues:\fR
.ie n .IP """tpm\-tis""" 4
.el .IP "\f(CWtpm\-tis\fR" 4
.IX Item "tpm-tis"
\&\s-1TPM TIS\s0 model
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBquery-tpm-models\fR  (Command)
Return a list of supported \s-1TPM\s0 models
.PP
\&\fBReturns:\fR
a list of TpmModel
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "query\-tpm\-models" }
\&        <\- { "return": [ "tpm\-tis" ] }
.Ve
.PP
\&\fBTpmType\fR (Enum)
.PP
An enumeration of \s-1TPM\s0 types
.PP
\&\fBValues:\fR
.ie n .IP """passthrough""" 4
.el .IP "\f(CWpassthrough\fR" 4
.IX Item "passthrough"
\&\s-1TPM\s0 passthrough type
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBquery-tpm-types\fR  (Command)
Return a list of supported \s-1TPM\s0 types
.PP
\&\fBReturns:\fR
a list of TpmType
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "query\-tpm\-types" }
\&        <\- { "return": [ "passthrough" ] }
.Ve
.PP
\&\fBTPMPassthroughOptions\fR (Object)
.PP
Information about the \s-1TPM\s0 passthrough type
.PP
\&\fBMembers:\fR
.ie n .IP """path: string"" (optional)" 4
.el .IP "\f(CWpath: string\fR (optional)" 4
.IX Item "path: string (optional)"
string describing the path used for accessing the \s-1TPM\s0 device
.ie n .IP """cancel\-path: string"" (optional)" 4
.el .IP "\f(CWcancel\-path: string\fR (optional)" 4
.IX Item "cancel-path: string (optional)"
string showing the \s-1TPM\s0's sysfs cancel file
for cancellation of \s-1TPM\s0 commands while they are executing
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBTpmTypeOptions\fR (Object)
.PP
A union referencing different \s-1TPM\s0 backend types' configuration options
.PP
\&\fBMembers:\fR
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
\&'passthrough' The configuration options for the \s-1TPM\s0 passthrough type
.ie n .IP """data: TPMPassthroughOptions"" when ""type"" is ""passthrough""" 4
.el .IP "\f(CWdata: TPMPassthroughOptions\fR when \f(CWtype\fR is ``passthrough''" 4
.IX Item "data: TPMPassthroughOptions when type is passthrough"
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBTPMInfo\fR (Object)
.PP
Information about the \s-1TPM\s0
.PP
\&\fBMembers:\fR
.ie n .IP """id: string""" 4
.el .IP "\f(CWid: string\fR" 4
.IX Item "id: string"
The Id of the \s-1TPM\s0
.ie n .IP """model: TpmModel""" 4
.el .IP "\f(CWmodel: TpmModel\fR" 4
.IX Item "model: TpmModel"
The \s-1TPM\s0 frontend model
.ie n .IP """options: TpmTypeOptions""" 4
.el .IP "\f(CWoptions: TpmTypeOptions\fR" 4
.IX Item "options: TpmTypeOptions"
The \s-1TPM \s0(backend) type configuration options
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBquery-tpm\fR  (Command)
Return information about the \s-1TPM\s0 device
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`TPMInfo\*(C'\fR on success
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-tpm" }
\&        <\- { "return":
\&             [
\&               { "model": "tpm\-tis",
\&                 "options":
\&                   { "type": "passthrough",
\&                     "data":
\&                       { "cancel\-path": "/sys/class/misc/tpm0/device/cancel",
\&                         "path": "/dev/tpm0"
\&                       }
\&                   },
\&                 "id": "tpm0"
\&               }
\&             ]
\&           }
.Ve
.PP
\&\fBAcpiTableOptions\fR (Object)
.PP
Specify an \s-1ACPI\s0 table on the command line to load.
.PP
At most one of \f(CW\*(C`file\*(C'\fR and \f(CW\*(C`data\*(C'\fR can be specified. The list of files specified
by any one of them is loaded and concatenated in order. If both are omitted,
\&\f(CW\*(C`data\*(C'\fR is implied.
.PP
Other fields / optargs can be used to override fields of the generic \s-1ACPI\s0
table header; refer to the \s-1ACPI\s0 specification 5.0, section 5.2.6 System
Description Table Header. If a header field is not overridden, then the
corresponding value from the concatenated blob is used (in case of \f(CW\*(C`file\*(C'\fR), or
it is filled in with a hard-coded value (in case of \f(CW\*(C`data\*(C'\fR).
.PP
String fields are copied into the matching \s-1ACPI\s0 member from lowest address
upwards, and silently truncated / NUL-padded to length.
.PP
\&\fBMembers:\fR
.ie n .IP """sig: string"" (optional)" 4
.el .IP "\f(CWsig: string\fR (optional)" 4
.IX Item "sig: string (optional)"
table signature / identifier (4 bytes)
.ie n .IP """rev: int"" (optional)" 4
.el .IP "\f(CWrev: int\fR (optional)" 4
.IX Item "rev: int (optional)"
table revision number (dependent on signature, 1 byte)
.ie n .IP """oem_id: string"" (optional)" 4
.el .IP "\f(CWoem_id: string\fR (optional)" 4
.IX Item "oem_id: string (optional)"
\&\s-1OEM\s0 identifier (6 bytes)
.ie n .IP """oem_table_id: string"" (optional)" 4
.el .IP "\f(CWoem_table_id: string\fR (optional)" 4
.IX Item "oem_table_id: string (optional)"
\&\s-1OEM\s0 table identifier (8 bytes)
.ie n .IP """oem_rev: int"" (optional)" 4
.el .IP "\f(CWoem_rev: int\fR (optional)" 4
.IX Item "oem_rev: int (optional)"
OEM-supplied revision number (4 bytes)
.ie n .IP """asl_compiler_id: string"" (optional)" 4
.el .IP "\f(CWasl_compiler_id: string\fR (optional)" 4
.IX Item "asl_compiler_id: string (optional)"
identifier of the utility that created the table
(4 bytes)
.ie n .IP """asl_compiler_rev: int"" (optional)" 4
.el .IP "\f(CWasl_compiler_rev: int\fR (optional)" 4
.IX Item "asl_compiler_rev: int (optional)"
revision number of the utility that created the
table (4 bytes)
.ie n .IP """file: string"" (optional)" 4
.el .IP "\f(CWfile: string\fR (optional)" 4
.IX Item "file: string (optional)"
colon (:) separated list of pathnames to load and
concatenate as table data. The resultant binary blob is expected to
have an \s-1ACPI\s0 table header. At least one file is required. This field
excludes \f(CW\*(C`data\*(C'\fR.
.ie n .IP """data: string"" (optional)" 4
.el .IP "\f(CWdata: string\fR (optional)" 4
.IX Item "data: string (optional)"
colon (:) separated list of pathnames to load and
concatenate as table data. The resultant binary blob must not have an
\&\s-1ACPI\s0 table header. At least one file is required. This field excludes
\&\f(CW\*(C`file\*(C'\fR.
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBCommandLineParameterType\fR (Enum)
.PP
Possible types for an option parameter.
.PP
\&\fBValues:\fR
.ie n .IP """string""" 4
.el .IP "\f(CWstring\fR" 4
.IX Item "string"
accepts a character string
.ie n .IP """boolean""" 4
.el .IP "\f(CWboolean\fR" 4
.IX Item "boolean"
accepts \*(L"on\*(R" or \*(L"off\*(R"
.ie n .IP """number""" 4
.el .IP "\f(CWnumber\fR" 4
.IX Item "number"
accepts a number
.ie n .IP """size""" 4
.el .IP "\f(CWsize\fR" 4
.IX Item "size"
accepts a number followed by an optional suffix (K)ilo,
(M)ega, (G)iga, (T)era
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBCommandLineParameterInfo\fR (Object)
.PP
Details about a single parameter of a command line option.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
parameter name
.ie n .IP """type: CommandLineParameterType""" 4
.el .IP "\f(CWtype: CommandLineParameterType\fR" 4
.IX Item "type: CommandLineParameterType"
parameter \f(CW\*(C`CommandLineParameterType\*(C'\fR
.ie n .IP """help: string"" (optional)" 4
.el .IP "\f(CWhelp: string\fR (optional)" 4
.IX Item "help: string (optional)"
human readable text string, not suitable for parsing.
.ie n .IP """default: string"" (optional)" 4
.el .IP "\f(CWdefault: string\fR (optional)" 4
.IX Item "default: string (optional)"
default value string (since 2.1)
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBCommandLineOptionInfo\fR (Object)
.PP
Details about a command line option, including its list of parameter details
.PP
\&\fBMembers:\fR
.ie n .IP """option: string""" 4
.el .IP "\f(CWoption: string\fR" 4
.IX Item "option: string"
option name
.ie n .IP """parameters: array of CommandLineParameterInfo""" 4
.el .IP "\f(CWparameters: array of CommandLineParameterInfo\fR" 4
.IX Item "parameters: array of CommandLineParameterInfo"
an array of \f(CW\*(C`CommandLineParameterInfo\*(C'\fR
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBquery-command-line-options\fR  (Command)
Query command line option schema.
.PP
\&\fBArguments:\fR
.ie n .IP """option: string"" (optional)" 4
.el .IP "\f(CWoption: string\fR (optional)" 4
.IX Item "option: string (optional)"
option name
.PP
\&\fBReturns:\fR
list of \f(CW\*(C`CommandLineOptionInfo\*(C'\fR for all options (or for the given
\&\f(CW\*(C`option\*(C'\fR).  Returns an error if the given \f(CW\*(C`option\*(C'\fR doesn't exist.
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-command\-line\-options",
\&             "arguments": { "option": "option\-rom" } }
\&        <\- { "return": [
\&                {
\&                    "parameters": [
\&                        {
\&                            "name": "romfile",
\&                            "type": "string"
\&                        },
\&                        {
\&                            "name": "bootindex",
\&                            "type": "number"
\&                        }
\&                    ],
\&                    "option": "option\-rom"
\&                }
\&             ]
\&           }
.Ve
.PP
\&\fBX86CPURegister32\fR (Enum)
.PP
A X86 32\-bit register
.PP
\&\fBValues:\fR
.ie n .IP """EAX""" 4
.el .IP "\f(CWEAX\fR" 4
.IX Item "EAX"
Not documented
.ie n .IP """EBX""" 4
.el .IP "\f(CWEBX\fR" 4
.IX Item "EBX"
Not documented
.ie n .IP """ECX""" 4
.el .IP "\f(CWECX\fR" 4
.IX Item "ECX"
Not documented
.ie n .IP """EDX""" 4
.el .IP "\f(CWEDX\fR" 4
.IX Item "EDX"
Not documented
.ie n .IP """ESP""" 4
.el .IP "\f(CWESP\fR" 4
.IX Item "ESP"
Not documented
.ie n .IP """EBP""" 4
.el .IP "\f(CWEBP\fR" 4
.IX Item "EBP"
Not documented
.ie n .IP """ESI""" 4
.el .IP "\f(CWESI\fR" 4
.IX Item "ESI"
Not documented
.ie n .IP """EDI""" 4
.el .IP "\f(CWEDI\fR" 4
.IX Item "EDI"
Not documented
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBX86CPUFeatureWordInfo\fR (Object)
.PP
Information about a X86 \s-1CPU\s0 feature word
.PP
\&\fBMembers:\fR
.ie n .IP """cpuid\-input\-eax: int""" 4
.el .IP "\f(CWcpuid\-input\-eax: int\fR" 4
.IX Item "cpuid-input-eax: int"
Input \s-1EAX\s0 value for \s-1CPUID\s0 instruction for that feature word
.ie n .IP """cpuid\-input\-ecx: int"" (optional)" 4
.el .IP "\f(CWcpuid\-input\-ecx: int\fR (optional)" 4
.IX Item "cpuid-input-ecx: int (optional)"
Input \s-1ECX\s0 value for \s-1CPUID\s0 instruction for that
feature word
.ie n .IP """cpuid\-register: X86CPURegister32""" 4
.el .IP "\f(CWcpuid\-register: X86CPURegister32\fR" 4
.IX Item "cpuid-register: X86CPURegister32"
Output register containing the feature bits
.ie n .IP """features: int""" 4
.el .IP "\f(CWfeatures: int\fR" 4
.IX Item "features: int"
value of output register, containing the feature bits
.PP
\&\fBSince:\fR
1.5
.PP
\&\fBDummyForceArrays\fR (Object)
.PP
Not used by \s-1QMP\s0; hack to let us use X86CPUFeatureWordInfoList internally
.PP
\&\fBMembers:\fR
.ie n .IP """unused: array of X86CPUFeatureWordInfo""" 4
.el .IP "\f(CWunused: array of X86CPUFeatureWordInfo\fR" 4
.IX Item "unused: array of X86CPUFeatureWordInfo"
Not documented
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBRxState\fR (Enum)
.PP
Packets receiving state
.PP
\&\fBValues:\fR
.ie n .IP """normal""" 4
.el .IP "\f(CWnormal\fR" 4
.IX Item "normal"
filter assigned packets according to the mac-table
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
don't receive any assigned packet
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
receive all assigned packets
.PP
\&\fBSince:\fR
1.6
.PP
\&\fBRxFilterInfo\fR (Object)
.PP
Rx-filter information for a \s-1NIC.\s0
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
net client name
.ie n .IP """promiscuous: boolean""" 4
.el .IP "\f(CWpromiscuous: boolean\fR" 4
.IX Item "promiscuous: boolean"
whether promiscuous mode is enabled
.ie n .IP """multicast: RxState""" 4
.el .IP "\f(CWmulticast: RxState\fR" 4
.IX Item "multicast: RxState"
multicast receive state
.ie n .IP """unicast: RxState""" 4
.el .IP "\f(CWunicast: RxState\fR" 4
.IX Item "unicast: RxState"
unicast receive state
.ie n .IP """vlan: RxState""" 4
.el .IP "\f(CWvlan: RxState\fR" 4
.IX Item "vlan: RxState"
vlan receive state (Since 2.0)
.ie n .IP """broadcast\-allowed: boolean""" 4
.el .IP "\f(CWbroadcast\-allowed: boolean\fR" 4
.IX Item "broadcast-allowed: boolean"
whether to receive broadcast
.ie n .IP """multicast\-overflow: boolean""" 4
.el .IP "\f(CWmulticast\-overflow: boolean\fR" 4
.IX Item "multicast-overflow: boolean"
multicast table is overflowed or not
.ie n .IP """unicast\-overflow: boolean""" 4
.el .IP "\f(CWunicast\-overflow: boolean\fR" 4
.IX Item "unicast-overflow: boolean"
unicast table is overflowed or not
.ie n .IP """main\-mac: string""" 4
.el .IP "\f(CWmain\-mac: string\fR" 4
.IX Item "main-mac: string"
the main macaddr string
.ie n .IP """vlan\-table: array of int""" 4
.el .IP "\f(CWvlan\-table: array of int\fR" 4
.IX Item "vlan-table: array of int"
a list of active vlan id
.ie n .IP """unicast\-table: array of string""" 4
.el .IP "\f(CWunicast\-table: array of string\fR" 4
.IX Item "unicast-table: array of string"
a list of unicast macaddr string
.ie n .IP """multicast\-table: array of string""" 4
.el .IP "\f(CWmulticast\-table: array of string\fR" 4
.IX Item "multicast-table: array of string"
a list of multicast macaddr string
.PP
\&\fBSince:\fR
1.6
.PP
\&\fBquery-rx-filter\fR  (Command)
Return rx-filter information for all NICs (or for the given \s-1NIC\s0).
.PP
\&\fBArguments:\fR
.ie n .IP """name: string"" (optional)" 4
.el .IP "\f(CWname: string\fR (optional)" 4
.IX Item "name: string (optional)"
net client name
.PP
\&\fBReturns:\fR
list of \f(CW\*(C`RxFilterInfo\*(C'\fR for all NICs (or for the given \s-1NIC\s0).
Returns an error if the given \f(CW\*(C`name\*(C'\fR doesn't exist, or given
\&\s-1NIC\s0 doesn't support rx-filter querying, or given net client
isn't a \s-1NIC.\s0
.PP
\&\fBSince:\fR
1.6
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-rx\-filter", "arguments": { "name": "vnet0" } }
\&        <\- { "return": [
\&                {
\&                    "promiscuous": true,
\&                    "name": "vnet0",
\&                    "main\-mac": "52:54:00:12:34:56",
\&                    "unicast": "normal",
\&                    "vlan": "normal",
\&                    "vlan\-table": [
\&                        4,
\&                        0
\&                    ],
\&                    "unicast\-table": [
\&                    ],
\&                    "multicast": "normal",
\&                    "multicast\-overflow": false,
\&                    "unicast\-overflow": false,
\&                    "multicast\-table": [
\&                        "01:00:5e:00:00:01",
\&                        "33:33:00:00:00:01",
\&                        "33:33:ff:12:34:56"
\&                    ],
\&                    "broadcast\-allowed": false
\&                }
\&              ]
\&           }
.Ve
.PP
\&\fBInputButton\fR (Enum)
.PP
Button of a pointer input device (mouse, tablet).
.PP
\&\fBValues:\fR
.ie n .IP """side""" 4
.el .IP "\f(CWside\fR" 4
.IX Item "side"
front side button of a 5\-button mouse (since 2.9)
.ie n .IP """extra""" 4
.el .IP "\f(CWextra\fR" 4
.IX Item "extra"
rear side button of a 5\-button mouse (since 2.9)
.ie n .IP """left""" 4
.el .IP "\f(CWleft\fR" 4
.IX Item "left"
Not documented
.ie n .IP """middle""" 4
.el .IP "\f(CWmiddle\fR" 4
.IX Item "middle"
Not documented
.ie n .IP """right""" 4
.el .IP "\f(CWright\fR" 4
.IX Item "right"
Not documented
.ie n .IP """wheel\-up""" 4
.el .IP "\f(CWwheel\-up\fR" 4
.IX Item "wheel-up"
Not documented
.ie n .IP """wheel\-down""" 4
.el .IP "\f(CWwheel\-down\fR" 4
.IX Item "wheel-down"
Not documented
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBInputAxis\fR (Enum)
.PP
Position axis of a pointer input device (mouse, tablet).
.PP
\&\fBValues:\fR
.ie n .IP """x""" 4
.el .IP "\f(CWx\fR" 4
.IX Item "x"
Not documented
.ie n .IP """y""" 4
.el .IP "\f(CWy\fR" 4
.IX Item "y"
Not documented
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBInputKeyEvent\fR (Object)
.PP
Keyboard input event.
.PP
\&\fBMembers:\fR
.ie n .IP """key: KeyValue""" 4
.el .IP "\f(CWkey: KeyValue\fR" 4
.IX Item "key: KeyValue"
Which key this event is for.
.ie n .IP """down: boolean""" 4
.el .IP "\f(CWdown: boolean\fR" 4
.IX Item "down: boolean"
True for key-down and false for key-up events.
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBInputBtnEvent\fR (Object)
.PP
Pointer button input event.
.PP
\&\fBMembers:\fR
.ie n .IP """button: InputButton""" 4
.el .IP "\f(CWbutton: InputButton\fR" 4
.IX Item "button: InputButton"
Which button this event is for.
.ie n .IP """down: boolean""" 4
.el .IP "\f(CWdown: boolean\fR" 4
.IX Item "down: boolean"
True for key-down and false for key-up events.
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBInputMoveEvent\fR (Object)
.PP
Pointer motion input event.
.PP
\&\fBMembers:\fR
.ie n .IP """axis: InputAxis""" 4
.el .IP "\f(CWaxis: InputAxis\fR" 4
.IX Item "axis: InputAxis"
Which axis is referenced by \f(CW\*(C`value\*(C'\fR.
.ie n .IP """value: int""" 4
.el .IP "\f(CWvalue: int\fR" 4
.IX Item "value: int"
Pointer position.  For absolute coordinates the
valid range is 0 \-> 0x7ffff
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBInputEvent\fR (Object)
.PP
Input event union.
.PP
\&\fBMembers:\fR
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
the input type, one of:
.RS 4
.IP "\-" 4
\&'key': Input event of Keyboard
.IP "\-" 4
\&'btn': Input event of pointer buttons
.IP "\-" 4
\&'rel': Input event of relative pointer motion
.IP "\-" 4
\&'abs': Input event of absolute pointer motion
.RE
.RS 4
.RE
.ie n .IP """data: InputKeyEvent"" when ""type"" is ""key""" 4
.el .IP "\f(CWdata: InputKeyEvent\fR when \f(CWtype\fR is ``key''" 4
.IX Item "data: InputKeyEvent when type is key"
.PD 0
.ie n .IP """data: InputBtnEvent"" when ""type"" is ""btn""" 4
.el .IP "\f(CWdata: InputBtnEvent\fR when \f(CWtype\fR is ``btn''" 4
.IX Item "data: InputBtnEvent when type is btn"
.ie n .IP """data: InputMoveEvent"" when ""type"" is ""rel""" 4
.el .IP "\f(CWdata: InputMoveEvent\fR when \f(CWtype\fR is ``rel''" 4
.IX Item "data: InputMoveEvent when type is rel"
.ie n .IP """data: InputMoveEvent"" when ""type"" is ""abs""" 4
.el .IP "\f(CWdata: InputMoveEvent\fR when \f(CWtype\fR is ``abs''" 4
.IX Item "data: InputMoveEvent when type is abs"
.PD
.PP
\&\fBSince:\fR
2.0
.PP
\&\fBinput-send-event\fR  (Command)
Send input event(s) to guest.
.PP
\&\fBArguments:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
display device to send event(s) to.
.ie n .IP """head: int"" (optional)" 4
.el .IP "\f(CWhead: int\fR (optional)" 4
.IX Item "head: int (optional)"
head to send event(s) to, in case the
display device supports multiple scanouts.
.ie n .IP """events: array of InputEvent""" 4
.el .IP "\f(CWevents: array of InputEvent\fR" 4
.IX Item "events: array of InputEvent"
List of InputEvent union.
.PP
\&\fBReturns:\fR
Nothing on success.
.PP
The \f(CW\*(C`device\*(C'\fR and \f(CW\*(C`head\*(C'\fR parameters can be used to send the input event
to specific input devices in case (a) multiple input devices of the
same kind are added to the virtual machine and (b) you have
configured input routing (see docs/multiseat.txt) for those input
devices.  The parameters work exactly like the device and head
properties of input devices.  If \f(CW\*(C`device\*(C'\fR is missing, only devices
that have no input routing config are admissible.  If \f(CW\*(C`device\*(C'\fR is
specified, both input devices with and without input routing config
are admissible, but devices with input routing config take
precedence.
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBNote:\fR
The consoles are visible in the qom tree, under
/backend/console[$index]. They have a device link and head property,
so it is possible to map which console belongs to which device and
display.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&        1. Press left mouse button.
\&        
\&        \-> { "execute": "input\-send\-event",
\&            "arguments": { "device": "video0",
\&                           "events": [ { "type": "btn",
\&                           "data" : { "down": true, "button": "left" } } ] } }
\&        <\- { "return": {} }
\&        
\&        \-> { "execute": "input\-send\-event",
\&            "arguments": { "device": "video0",
\&                           "events": [ { "type": "btn",
\&                           "data" : { "down": false, "button": "left" } } ] } }
\&        <\- { "return": {} }
\&        
\&        2. Press ctrl\-alt\-del.
\&        
\&        \-> { "execute": "input\-send\-event",
\&             "arguments": { "events": [
\&                { "type": "key", "data" : { "down": true,
\&                  "key": {"type": "qcode", "data": "ctrl" } } },
\&                { "type": "key", "data" : { "down": true,
\&                  "key": {"type": "qcode", "data": "alt" } } },
\&                { "type": "key", "data" : { "down": true,
\&                  "key": {"type": "qcode", "data": "delete" } } } ] } }
\&        <\- { "return": {} }
\&        
\&        3. Move mouse pointer to absolute coordinates (20000, 400).
\&        
\&        \-> { "execute": "input\-send\-event" ,
\&          "arguments": { "events": [
\&                       { "type": "abs", "data" : { "axis": "x", "value" : 20000 } },
\&                       { "type": "abs", "data" : { "axis": "y", "value" : 400 } } ] } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBNumaOptionsType\fR (Enum)
.PP
\&\fBValues:\fR
.ie n .IP """node""" 4
.el .IP "\f(CWnode\fR" 4
.IX Item "node"
\&\s-1NUMA\s0 nodes configuration
.ie n .IP """dist""" 4
.el .IP "\f(CWdist\fR" 4
.IX Item "dist"
\&\s-1NUMA\s0 distance configuration (since 2.10)
.ie n .IP """cpu""" 4
.el .IP "\f(CWcpu\fR" 4
.IX Item "cpu"
property based \s-1CPU\s0(s) to node mapping (Since: 2.10)
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBNumaOptions\fR (Object)
.PP
A discriminated record of \s-1NUMA\s0 options. (for OptsVisitor)
.PP
\&\fBMembers:\fR
.ie n .IP """type: NumaOptionsType""" 4
.el .IP "\f(CWtype: NumaOptionsType\fR" 4
.IX Item "type: NumaOptionsType"
Not documented
.ie n .IP "The members of ""NumaNodeOptions"" when ""type"" is ""node""" 4
.el .IP "The members of \f(CWNumaNodeOptions\fR when \f(CWtype\fR is ``node''" 4
.IX Item "The members of NumaNodeOptions when type is node"
.PD 0
.ie n .IP "The members of ""NumaDistOptions"" when ""type"" is ""dist""" 4
.el .IP "The members of \f(CWNumaDistOptions\fR when \f(CWtype\fR is ``dist''" 4
.IX Item "The members of NumaDistOptions when type is dist"
.ie n .IP "The members of ""NumaCpuOptions"" when ""type"" is ""cpu""" 4
.el .IP "The members of \f(CWNumaCpuOptions\fR when \f(CWtype\fR is ``cpu''" 4
.IX Item "The members of NumaCpuOptions when type is cpu"
.PD
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBNumaNodeOptions\fR (Object)
.PP
Create a guest \s-1NUMA\s0 node. (for OptsVisitor)
.PP
\&\fBMembers:\fR
.ie n .IP """nodeid: int"" (optional)" 4
.el .IP "\f(CWnodeid: int\fR (optional)" 4
.IX Item "nodeid: int (optional)"
\&\s-1NUMA\s0 node \s-1ID \s0(increase by 1 from 0 if omitted)
.ie n .IP """cpus: array of int"" (optional)" 4
.el .IP "\f(CWcpus: array of int\fR (optional)" 4
.IX Item "cpus: array of int (optional)"
VCPUs belonging to this node (assign \s-1VCPUS\s0 round-robin
if omitted)
.ie n .IP """mem: int"" (optional)" 4
.el .IP "\f(CWmem: int\fR (optional)" 4
.IX Item "mem: int (optional)"
memory size of this node; mutually exclusive with \f(CW\*(C`memdev\*(C'\fR.
Equally divide total memory among nodes if both \f(CW\*(C`mem\*(C'\fR and \f(CW\*(C`memdev\*(C'\fR are
omitted.
.ie n .IP """memdev: string"" (optional)" 4
.el .IP "\f(CWmemdev: string\fR (optional)" 4
.IX Item "memdev: string (optional)"
memory backend object.  If specified for one node,
it must be specified for all nodes.
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBNumaDistOptions\fR (Object)
.PP
Set the distance between 2 \s-1NUMA\s0 nodes.
.PP
\&\fBMembers:\fR
.ie n .IP """src: int""" 4
.el .IP "\f(CWsrc: int\fR" 4
.IX Item "src: int"
source \s-1NUMA\s0 node.
.ie n .IP """dst: int""" 4
.el .IP "\f(CWdst: int\fR" 4
.IX Item "dst: int"
destination \s-1NUMA\s0 node.
.ie n .IP """val: int""" 4
.el .IP "\f(CWval: int\fR" 4
.IX Item "val: int"
\&\s-1NUMA\s0 distance from source node to destination node.
When a node is unreachable from another node, set the distance
between them to 255.
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBNumaCpuOptions\fR (Object)
.PP
Option \*(L"\-numa cpu\*(R" overrides default cpu to node mapping.
It accepts the same set of cpu properties as returned by
query\-hotpluggable\-cpus[].props, where node-id could be used to
override default node mapping.
.PP
\&\fBMembers:\fR
.ie n .IP "The members of ""CpuInstanceProperties""" 4
.el .IP "The members of \f(CWCpuInstanceProperties\fR" 4
.IX Item "The members of CpuInstanceProperties"
.PP
\&\fBSince:\fR
2.10
.PP
\&\fBHostMemPolicy\fR (Enum)
.PP
Host memory policy types
.PP
\&\fBValues:\fR
.ie n .IP """default""" 4
.el .IP "\f(CWdefault\fR" 4
.IX Item "default"
restore default policy, remove any nondefault policy
.ie n .IP """preferred""" 4
.el .IP "\f(CWpreferred\fR" 4
.IX Item "preferred"
set the preferred host nodes for allocation
.ie n .IP """bind""" 4
.el .IP "\f(CWbind\fR" 4
.IX Item "bind"
a strict policy that restricts memory allocation to the
host nodes specified
.ie n .IP """interleave""" 4
.el .IP "\f(CWinterleave\fR" 4
.IX Item "interleave"
memory allocations are interleaved across the set
of host nodes specified
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBMemdev\fR (Object)
.PP
Information about memory backend
.PP
\&\fBMembers:\fR
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
backend's \s-1ID\s0 if backend has 'id' property (since 2.9)
.ie n .IP """size: int""" 4
.el .IP "\f(CWsize: int\fR" 4
.IX Item "size: int"
memory backend size
.ie n .IP """merge: boolean""" 4
.el .IP "\f(CWmerge: boolean\fR" 4
.IX Item "merge: boolean"
enables or disables memory merge support
.ie n .IP """dump: boolean""" 4
.el .IP "\f(CWdump: boolean\fR" 4
.IX Item "dump: boolean"
includes memory backend's memory in a core dump or not
.ie n .IP """prealloc: boolean""" 4
.el .IP "\f(CWprealloc: boolean\fR" 4
.IX Item "prealloc: boolean"
enables or disables memory preallocation
.ie n .IP """host\-nodes: array of int""" 4
.el .IP "\f(CWhost\-nodes: array of int\fR" 4
.IX Item "host-nodes: array of int"
host nodes for its memory policy
.ie n .IP """policy: HostMemPolicy""" 4
.el .IP "\f(CWpolicy: HostMemPolicy\fR" 4
.IX Item "policy: HostMemPolicy"
memory policy of memory backend
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBquery-memdev\fR  (Command)
Returns information for all memory backends.
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`Memdev\*(C'\fR.
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-memdev" }
\&        <\- { "return": [
\&               {
\&                 "id": "mem1",
\&                 "size": 536870912,
\&                 "merge": false,
\&                 "dump": true,
\&                 "prealloc": false,
\&                 "host\-nodes": [0, 1],
\&                 "policy": "bind"
\&               },
\&               {
\&                 "size": 536870912,
\&                 "merge": false,
\&                 "dump": true,
\&                 "prealloc": true,
\&                 "host\-nodes": [2, 3],
\&                 "policy": "preferred"
\&               }
\&             ]
\&           }
.Ve
.PP
\&\fBPCDIMMDeviceInfo\fR (Object)
.PP
PCDIMMDevice state information
.PP
\&\fBMembers:\fR
.ie n .IP """id: string"" (optional)" 4
.el .IP "\f(CWid: string\fR (optional)" 4
.IX Item "id: string (optional)"
device's \s-1ID\s0
.ie n .IP """addr: int""" 4
.el .IP "\f(CWaddr: int\fR" 4
.IX Item "addr: int"
physical address, where device is mapped
.ie n .IP """size: int""" 4
.el .IP "\f(CWsize: int\fR" 4
.IX Item "size: int"
size of memory that the device provides
.ie n .IP """slot: int""" 4
.el .IP "\f(CWslot: int\fR" 4
.IX Item "slot: int"
slot number at which device is plugged in
.ie n .IP """node: int""" 4
.el .IP "\f(CWnode: int\fR" 4
.IX Item "node: int"
\&\s-1NUMA\s0 node number where device is plugged in
.ie n .IP """memdev: string""" 4
.el .IP "\f(CWmemdev: string\fR" 4
.IX Item "memdev: string"
memory backend linked with device
.ie n .IP """hotplugged: boolean""" 4
.el .IP "\f(CWhotplugged: boolean\fR" 4
.IX Item "hotplugged: boolean"
true if device was hotplugged
.ie n .IP """hotpluggable: boolean""" 4
.el .IP "\f(CWhotpluggable: boolean\fR" 4
.IX Item "hotpluggable: boolean"
true if device if could be added/removed while machine is running
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBMemoryDeviceInfo\fR (Object)
.PP
Union containing information about a memory device
.PP
\&\fBMembers:\fR
.ie n .IP """type""" 4
.el .IP "\f(CWtype\fR" 4
.IX Item "type"
One of \*(L"dimm\*(R"
.ie n .IP """data: PCDIMMDeviceInfo"" when ""type"" is ""dimm""" 4
.el .IP "\f(CWdata: PCDIMMDeviceInfo\fR when \f(CWtype\fR is ``dimm''" 4
.IX Item "data: PCDIMMDeviceInfo when type is dimm"
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBquery-memory-devices\fR  (Command)
Lists available memory devices and their state
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBExample:\fR
.PP
.Vb 12
\&        \-> { "execute": "query\-memory\-devices" }
\&        <\- { "return": [ { "data":
\&                              { "addr": 5368709120,
\&                                "hotpluggable": true,
\&                                "hotplugged": true,
\&                                "id": "d1",
\&                                "memdev": "/objects/memX",
\&                                "node": 0,
\&                                "size": 1073741824,
\&                                "slot": 0},
\&                           "type": "dimm"
\&                         } ] }
.Ve
.PP
\&\fBACPISlotType\fR (Enum)
.PP
\&\fBValues:\fR
.ie n .IP """DIMM""" 4
.el .IP "\f(CWDIMM\fR" 4
.IX Item "DIMM"
memory slot
.ie n .IP """CPU""" 4
.el .IP "\f(CWCPU\fR" 4
.IX Item "CPU"
logical \s-1CPU\s0 slot (since 2.7)
.PP
\&\fBACPIOSTInfo\fR (Object)
.PP
\&\s-1OSPM\s0 Status Indication for a device
For description of possible values of \f(CW\*(C`source\*(C'\fR and \f(CW\*(C`status\*(C'\fR fields
see \*(L"_OST (\s-1OSPM\s0 Status Indication)\*(R" chapter of \s-1ACPI5.0\s0 spec.
.PP
\&\fBMembers:\fR
.ie n .IP """device: string"" (optional)" 4
.el .IP "\f(CWdevice: string\fR (optional)" 4
.IX Item "device: string (optional)"
device \s-1ID\s0 associated with slot
.ie n .IP """slot: string""" 4
.el .IP "\f(CWslot: string\fR" 4
.IX Item "slot: string"
slot \s-1ID,\s0 unique per slot of a given \f(CW\*(C`slot\-type\*(C'\fR
.ie n .IP """slot\-type: ACPISlotType""" 4
.el .IP "\f(CWslot\-type: ACPISlotType\fR" 4
.IX Item "slot-type: ACPISlotType"
type of the slot
.ie n .IP """source: int""" 4
.el .IP "\f(CWsource: int\fR" 4
.IX Item "source: int"
an integer containing the source event
.ie n .IP """status: int""" 4
.el .IP "\f(CWstatus: int\fR" 4
.IX Item "status: int"
an integer containing the status code
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBquery-acpi-ospm-status\fR  (Command)
Return a list of ACPIOSTInfo for devices that support status
reporting via \s-1ACPI _OST\s0 method.
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&        \-> { "execute": "query\-acpi\-ospm\-status" }
\&        <\- { "return": [ { "device": "d1", "slot": "0", "slot\-type": "DIMM", "source": 1, "status": 0},
\&                         { "slot": "1", "slot\-type": "DIMM", "source": 0, "status": 0},
\&                         { "slot": "2", "slot\-type": "DIMM", "source": 0, "status": 0},
\&                         { "slot": "3", "slot\-type": "DIMM", "source": 0, "status": 0}
\&           ]}
.Ve
.PP
\&\fBWatchdogExpirationAction\fR (Enum)
.PP
An enumeration of the actions taken when the watchdog device's timer is
expired
.PP
\&\fBValues:\fR
.ie n .IP """reset""" 4
.el .IP "\f(CWreset\fR" 4
.IX Item "reset"
system resets
.ie n .IP """shutdown""" 4
.el .IP "\f(CWshutdown\fR" 4
.IX Item "shutdown"
system shutdown, note that it is similar to \f(CW\*(C`powerdown\*(C'\fR, which
tries to set to system status and notify guest
.ie n .IP """poweroff""" 4
.el .IP "\f(CWpoweroff\fR" 4
.IX Item "poweroff"
system poweroff, the emulator program exits
.ie n .IP """pause""" 4
.el .IP "\f(CWpause\fR" 4
.IX Item "pause"
system pauses, similar to \f(CW\*(C`stop\*(C'\fR
.ie n .IP """debug""" 4
.el .IP "\f(CWdebug\fR" 4
.IX Item "debug"
system enters debug state
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
nothing is done
.ie n .IP """inject\-nmi""" 4
.el .IP "\f(CWinject\-nmi\fR" 4
.IX Item "inject-nmi"
a non-maskable interrupt is injected into the first \s-1VCPU \s0(all
\&\s-1VCPUS\s0 on x86) (since 2.4)
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBIoOperationType\fR (Enum)
.PP
An enumeration of the I/O operation types
.PP
\&\fBValues:\fR
.ie n .IP """read""" 4
.el .IP "\f(CWread\fR" 4
.IX Item "read"
read operation
.ie n .IP """write""" 4
.el .IP "\f(CWwrite\fR" 4
.IX Item "write"
write operation
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBGuestPanicAction\fR (Enum)
.PP
An enumeration of the actions taken when guest \s-1OS\s0 panic is detected
.PP
\&\fBValues:\fR
.ie n .IP """pause""" 4
.el .IP "\f(CWpause\fR" 4
.IX Item "pause"
system pauses
.ie n .IP """poweroff""" 4
.el .IP "\f(CWpoweroff\fR" 4
.IX Item "poweroff"
Not documented
.PP
\&\fBSince:\fR
2.1 (poweroff since 2.8)
.PP
\&\fBGuestPanicInformationType\fR (Enum)
.PP
An enumeration of the guest panic information types
.PP
\&\fBValues:\fR
.ie n .IP """hyper\-v""" 4
.el .IP "\f(CWhyper\-v\fR" 4
.IX Item "hyper-v"
Not documented
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBGuestPanicInformation\fR (Object)
.PP
Information about a guest panic
.PP
\&\fBMembers:\fR
.ie n .IP """type: GuestPanicInformationType""" 4
.el .IP "\f(CWtype: GuestPanicInformationType\fR" 4
.IX Item "type: GuestPanicInformationType"
Not documented
.ie n .IP "The members of ""GuestPanicInformationHyperV"" when ""type"" is ""hyper-v""" 4
.el .IP "The members of \f(CWGuestPanicInformationHyperV\fR when \f(CWtype\fR is ``hyper-v''" 4
.IX Item "The members of GuestPanicInformationHyperV when type is hyper-v"
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBGuestPanicInformationHyperV\fR (Object)
.PP
Hyper-V specific guest panic information (\s-1HV\s0 crash MSRs)
.PP
\&\fBMembers:\fR
.ie n .IP """arg1: int""" 4
.el .IP "\f(CWarg1: int\fR" 4
.IX Item "arg1: int"
Not documented
.ie n .IP """arg2: int""" 4
.el .IP "\f(CWarg2: int\fR" 4
.IX Item "arg2: int"
Not documented
.ie n .IP """arg3: int""" 4
.el .IP "\f(CWarg3: int\fR" 4
.IX Item "arg3: int"
Not documented
.ie n .IP """arg4: int""" 4
.el .IP "\f(CWarg4: int\fR" 4
.IX Item "arg4: int"
Not documented
.ie n .IP """arg5: int""" 4
.el .IP "\f(CWarg5: int\fR" 4
.IX Item "arg5: int"
Not documented
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBrtc-reset-reinjection\fR  (Command)
This command will reset the \s-1RTC\s0 interrupt reinjection backlog.
Can be used if another mechanism to synchronize guest time
is in effect, for example \s-1QEMU\s0 guest agent's guest-set-time
command.
.PP
\&\fBSince:\fR
2.1
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "rtc\-reset\-reinjection" }
\&        <\- { "return": {} }
.Ve
.SS "Rocker switch device"
.IX Subsection "Rocker switch device"
\&\fBRockerSwitch\fR (Object)
.PP
Rocker switch information.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
switch name
.ie n .IP """id: int""" 4
.el .IP "\f(CWid: int\fR" 4
.IX Item "id: int"
switch \s-1ID\s0
.ie n .IP """ports: int""" 4
.el .IP "\f(CWports: int\fR" 4
.IX Item "ports: int"
number of front-panel ports
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBquery-rocker\fR  (Command)
Return rocker switch information.
.PP
\&\fBArguments:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
Not documented
.PP
\&\fBReturns:\fR
\&\f(CW\*(C`Rocker\*(C'\fR information
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "query\-rocker", "arguments": { "name": "sw1" } }
\&        <\- { "return": {"name": "sw1", "ports": 2, "id": 1327446905938}}
.Ve
.PP
\&\fBRockerPortDuplex\fR (Enum)
.PP
An eumeration of port duplex states.
.PP
\&\fBValues:\fR
.ie n .IP """half""" 4
.el .IP "\f(CWhalf\fR" 4
.IX Item "half"
half duplex
.ie n .IP """full""" 4
.el .IP "\f(CWfull\fR" 4
.IX Item "full"
full duplex
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBRockerPortAutoneg\fR (Enum)
.PP
An eumeration of port autoneg states.
.PP
\&\fBValues:\fR
.ie n .IP """off""" 4
.el .IP "\f(CWoff\fR" 4
.IX Item "off"
autoneg is off
.ie n .IP """on""" 4
.el .IP "\f(CWon\fR" 4
.IX Item "on"
autoneg is on
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBRockerPort\fR (Object)
.PP
Rocker switch port information.
.PP
\&\fBMembers:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
port name
.ie n .IP """enabled: boolean""" 4
.el .IP "\f(CWenabled: boolean\fR" 4
.IX Item "enabled: boolean"
port is enabled for I/O
.ie n .IP """link\-up: boolean""" 4
.el .IP "\f(CWlink\-up: boolean\fR" 4
.IX Item "link-up: boolean"
physical link is \s-1UP\s0 on port
.ie n .IP """speed: int""" 4
.el .IP "\f(CWspeed: int\fR" 4
.IX Item "speed: int"
port link speed in Mbps
.ie n .IP """duplex: RockerPortDuplex""" 4
.el .IP "\f(CWduplex: RockerPortDuplex\fR" 4
.IX Item "duplex: RockerPortDuplex"
port link duplex
.ie n .IP """autoneg: RockerPortAutoneg""" 4
.el .IP "\f(CWautoneg: RockerPortAutoneg\fR" 4
.IX Item "autoneg: RockerPortAutoneg"
port link autoneg
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBquery-rocker-ports\fR  (Command)
Return rocker switch port information.
.PP
\&\fBArguments:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
Not documented
.PP
\&\fBReturns:\fR
a list of \f(CW\*(C`RockerPort\*(C'\fR information
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&        \-> { "execute": "query\-rocker\-ports", "arguments": { "name": "sw1" } }
\&        <\- { "return": [ {"duplex": "full", "enabled": true, "name": "sw1.1",
\&                          "autoneg": "off", "link\-up": true, "speed": 10000},
\&                         {"duplex": "full", "enabled": true, "name": "sw1.2",
\&                          "autoneg": "off", "link\-up": true, "speed": 10000}
\&           ]}
.Ve
.PP
\&\fBRockerOfDpaFlowKey\fR (Object)
.PP
Rocker switch OF-DPA flow key
.PP
\&\fBMembers:\fR
.ie n .IP """priority: int""" 4
.el .IP "\f(CWpriority: int\fR" 4
.IX Item "priority: int"
key priority, 0 being lowest priority
.ie n .IP """tbl\-id: int""" 4
.el .IP "\f(CWtbl\-id: int\fR" 4
.IX Item "tbl-id: int"
flow table \s-1ID\s0
.ie n .IP """in\-pport: int"" (optional)" 4
.el .IP "\f(CWin\-pport: int\fR (optional)" 4
.IX Item "in-pport: int (optional)"
physical input port
.ie n .IP """tunnel\-id: int"" (optional)" 4
.el .IP "\f(CWtunnel\-id: int\fR (optional)" 4
.IX Item "tunnel-id: int (optional)"
tunnel \s-1ID\s0
.ie n .IP """vlan\-id: int"" (optional)" 4
.el .IP "\f(CWvlan\-id: int\fR (optional)" 4
.IX Item "vlan-id: int (optional)"
\&\s-1VLAN ID\s0
.ie n .IP """eth\-type: int"" (optional)" 4
.el .IP "\f(CWeth\-type: int\fR (optional)" 4
.IX Item "eth-type: int (optional)"
Ethernet header type
.ie n .IP """eth\-src: string"" (optional)" 4
.el .IP "\f(CWeth\-src: string\fR (optional)" 4
.IX Item "eth-src: string (optional)"
Ethernet header source \s-1MAC\s0 address
.ie n .IP """eth\-dst: string"" (optional)" 4
.el .IP "\f(CWeth\-dst: string\fR (optional)" 4
.IX Item "eth-dst: string (optional)"
Ethernet header destination \s-1MAC\s0 address
.ie n .IP """ip\-proto: int"" (optional)" 4
.el .IP "\f(CWip\-proto: int\fR (optional)" 4
.IX Item "ip-proto: int (optional)"
\&\s-1IP\s0 Header protocol field
.ie n .IP """ip\-tos: int"" (optional)" 4
.el .IP "\f(CWip\-tos: int\fR (optional)" 4
.IX Item "ip-tos: int (optional)"
\&\s-1IP\s0 header \s-1TOS\s0 field
.ie n .IP """ip\-dst: string"" (optional)" 4
.el .IP "\f(CWip\-dst: string\fR (optional)" 4
.IX Item "ip-dst: string (optional)"
\&\s-1IP\s0 header destination address
.PP
\&\fBNote:\fR
optional members may or may not appear in the flow key
depending if they're relevant to the flow key.
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBRockerOfDpaFlowMask\fR (Object)
.PP
Rocker switch OF-DPA flow mask
.PP
\&\fBMembers:\fR
.ie n .IP """in\-pport: int"" (optional)" 4
.el .IP "\f(CWin\-pport: int\fR (optional)" 4
.IX Item "in-pport: int (optional)"
physical input port
.ie n .IP """tunnel\-id: int"" (optional)" 4
.el .IP "\f(CWtunnel\-id: int\fR (optional)" 4
.IX Item "tunnel-id: int (optional)"
tunnel \s-1ID\s0
.ie n .IP """vlan\-id: int"" (optional)" 4
.el .IP "\f(CWvlan\-id: int\fR (optional)" 4
.IX Item "vlan-id: int (optional)"
\&\s-1VLAN ID\s0
.ie n .IP """eth\-src: string"" (optional)" 4
.el .IP "\f(CWeth\-src: string\fR (optional)" 4
.IX Item "eth-src: string (optional)"
Ethernet header source \s-1MAC\s0 address
.ie n .IP """eth\-dst: string"" (optional)" 4
.el .IP "\f(CWeth\-dst: string\fR (optional)" 4
.IX Item "eth-dst: string (optional)"
Ethernet header destination \s-1MAC\s0 address
.ie n .IP """ip\-proto: int"" (optional)" 4
.el .IP "\f(CWip\-proto: int\fR (optional)" 4
.IX Item "ip-proto: int (optional)"
\&\s-1IP\s0 Header protocol field
.ie n .IP """ip\-tos: int"" (optional)" 4
.el .IP "\f(CWip\-tos: int\fR (optional)" 4
.IX Item "ip-tos: int (optional)"
\&\s-1IP\s0 header \s-1TOS\s0 field
.PP
\&\fBNote:\fR
optional members may or may not appear in the flow mask
depending if they're relevant to the flow mask.
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBRockerOfDpaFlowAction\fR (Object)
.PP
Rocker switch OF-DPA flow action
.PP
\&\fBMembers:\fR
.ie n .IP """goto\-tbl: int"" (optional)" 4
.el .IP "\f(CWgoto\-tbl: int\fR (optional)" 4
.IX Item "goto-tbl: int (optional)"
next table \s-1ID\s0
.ie n .IP """group\-id: int"" (optional)" 4
.el .IP "\f(CWgroup\-id: int\fR (optional)" 4
.IX Item "group-id: int (optional)"
group \s-1ID\s0
.ie n .IP """tunnel\-lport: int"" (optional)" 4
.el .IP "\f(CWtunnel\-lport: int\fR (optional)" 4
.IX Item "tunnel-lport: int (optional)"
tunnel logical port \s-1ID\s0
.ie n .IP """vlan\-id: int"" (optional)" 4
.el .IP "\f(CWvlan\-id: int\fR (optional)" 4
.IX Item "vlan-id: int (optional)"
\&\s-1VLAN ID\s0
.ie n .IP """new\-vlan\-id: int"" (optional)" 4
.el .IP "\f(CWnew\-vlan\-id: int\fR (optional)" 4
.IX Item "new-vlan-id: int (optional)"
new \s-1VLAN ID\s0
.ie n .IP """out\-pport: int"" (optional)" 4
.el .IP "\f(CWout\-pport: int\fR (optional)" 4
.IX Item "out-pport: int (optional)"
physical output port
.PP
\&\fBNote:\fR
optional members may or may not appear in the flow action
depending if they're relevant to the flow action.
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBRockerOfDpaFlow\fR (Object)
.PP
Rocker switch OF-DPA flow
.PP
\&\fBMembers:\fR
.ie n .IP """cookie: int""" 4
.el .IP "\f(CWcookie: int\fR" 4
.IX Item "cookie: int"
flow unique cookie \s-1ID\s0
.ie n .IP """hits: int""" 4
.el .IP "\f(CWhits: int\fR" 4
.IX Item "hits: int"
count of matches (hits) on flow
.ie n .IP """key: RockerOfDpaFlowKey""" 4
.el .IP "\f(CWkey: RockerOfDpaFlowKey\fR" 4
.IX Item "key: RockerOfDpaFlowKey"
flow key
.ie n .IP """mask: RockerOfDpaFlowMask""" 4
.el .IP "\f(CWmask: RockerOfDpaFlowMask\fR" 4
.IX Item "mask: RockerOfDpaFlowMask"
flow mask
.ie n .IP """action: RockerOfDpaFlowAction""" 4
.el .IP "\f(CWaction: RockerOfDpaFlowAction\fR" 4
.IX Item "action: RockerOfDpaFlowAction"
flow action
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBquery-rocker-of-dpa-flows\fR  (Command)
Return rocker OF-DPA flow information.
.PP
\&\fBArguments:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
switch name
.ie n .IP """tbl\-id: int"" (optional)" 4
.el .IP "\f(CWtbl\-id: int\fR (optional)" 4
.IX Item "tbl-id: int (optional)"
flow table \s-1ID. \s0 If tbl-id is not specified, returns
flow information for all tables.
.PP
\&\fBReturns:\fR
rocker OF-DPA flow information
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-rocker\-of\-dpa\-flows",
\&             "arguments": { "name": "sw1" } }
\&        <\- { "return": [ {"key": {"in\-pport": 0, "priority": 1, "tbl\-id": 0},
\&                          "hits": 138,
\&                          "cookie": 0,
\&                          "action": {"goto\-tbl": 10},
\&                          "mask": {"in\-pport": 4294901760}
\&                         },
\&                         {...more...},
\&           ]}
.Ve
.PP
\&\fBRockerOfDpaGroup\fR (Object)
.PP
Rocker switch OF-DPA group
.PP
\&\fBMembers:\fR
.ie n .IP """id: int""" 4
.el .IP "\f(CWid: int\fR" 4
.IX Item "id: int"
group unique \s-1ID\s0
.ie n .IP """type: int""" 4
.el .IP "\f(CWtype: int\fR" 4
.IX Item "type: int"
group type
.ie n .IP """vlan\-id: int"" (optional)" 4
.el .IP "\f(CWvlan\-id: int\fR (optional)" 4
.IX Item "vlan-id: int (optional)"
\&\s-1VLAN ID\s0
.ie n .IP """pport: int"" (optional)" 4
.el .IP "\f(CWpport: int\fR (optional)" 4
.IX Item "pport: int (optional)"
physical port number
.ie n .IP """index: int"" (optional)" 4
.el .IP "\f(CWindex: int\fR (optional)" 4
.IX Item "index: int (optional)"
group index, unique with group type
.ie n .IP """out\-pport: int"" (optional)" 4
.el .IP "\f(CWout\-pport: int\fR (optional)" 4
.IX Item "out-pport: int (optional)"
output physical port number
.ie n .IP """group\-id: int"" (optional)" 4
.el .IP "\f(CWgroup\-id: int\fR (optional)" 4
.IX Item "group-id: int (optional)"
next group \s-1ID\s0
.ie n .IP """set\-vlan\-id: int"" (optional)" 4
.el .IP "\f(CWset\-vlan\-id: int\fR (optional)" 4
.IX Item "set-vlan-id: int (optional)"
\&\s-1VLAN ID\s0 to set
.ie n .IP """pop\-vlan: int"" (optional)" 4
.el .IP "\f(CWpop\-vlan: int\fR (optional)" 4
.IX Item "pop-vlan: int (optional)"
pop \s-1VLAN\s0 headr from packet
.ie n .IP """group\-ids: array of int"" (optional)" 4
.el .IP "\f(CWgroup\-ids: array of int\fR (optional)" 4
.IX Item "group-ids: array of int (optional)"
list of next group IDs
.ie n .IP """set\-eth\-src: string"" (optional)" 4
.el .IP "\f(CWset\-eth\-src: string\fR (optional)" 4
.IX Item "set-eth-src: string (optional)"
set source \s-1MAC\s0 address in Ethernet header
.ie n .IP """set\-eth\-dst: string"" (optional)" 4
.el .IP "\f(CWset\-eth\-dst: string\fR (optional)" 4
.IX Item "set-eth-dst: string (optional)"
set destination \s-1MAC\s0 address in Ethernet header
.ie n .IP """ttl\-check: int"" (optional)" 4
.el .IP "\f(CWttl\-check: int\fR (optional)" 4
.IX Item "ttl-check: int (optional)"
perform \s-1TTL\s0 check
.PP
\&\fBNote:\fR
optional members may or may not appear in the group depending
if they're relevant to the group type.
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBquery-rocker-of-dpa-groups\fR  (Command)
Return rocker OF-DPA group information.
.PP
\&\fBArguments:\fR
.ie n .IP """name: string""" 4
.el .IP "\f(CWname: string\fR" 4
.IX Item "name: string"
switch name
.ie n .IP """type: int"" (optional)" 4
.el .IP "\f(CWtype: int\fR (optional)" 4
.IX Item "type: int (optional)"
group type.  If type is not specified, returns
group information for all group types.
.PP
\&\fBReturns:\fR
rocker OF-DPA group information
.PP
\&\fBSince:\fR
2.4
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&        \-> { "execute": "query\-rocker\-of\-dpa\-groups",
\&             "arguments": { "name": "sw1" } }
\&        <\- { "return": [ {"type": 0, "out\-pport": 2,
\&                          "pport": 2, "vlan\-id": 3841,
\&                          "pop\-vlan": 1, "id": 251723778},
\&                         {"type": 0, "out\-pport": 0,
\&                          "pport": 0, "vlan\-id": 3841,
\&                          "pop\-vlan": 1, "id": 251723776},
\&                         {"type": 0, "out\-pport": 1,
\&                          "pport": 1, "vlan\-id": 3840,
\&                          "pop\-vlan": 1, "id": 251658241},
\&                         {"type": 0, "out\-pport": 0,
\&                          "pport": 0, "vlan\-id": 3840,
\&                          "pop\-vlan": 1, "id": 251658240}
\&           ]}
.Ve
.PP
\&\fBReplayMode\fR (Enum)
.PP
Mode of the replay subsystem.
.PP
\&\fBValues:\fR
.ie n .IP """none""" 4
.el .IP "\f(CWnone\fR" 4
.IX Item "none"
normal execution mode. Replay or record are not enabled.
.ie n .IP """record""" 4
.el .IP "\f(CWrecord\fR" 4
.IX Item "record"
record mode. All non-deterministic data is written into the
replay log.
.ie n .IP """play""" 4
.el .IP "\f(CWplay\fR" 4
.IX Item "play"
replay mode. Non-deterministic data required for system execution
is read from the log.
.PP
\&\fBSince:\fR
2.5
.PP
\&\fBxen-load-devices-state\fR  (Command)
Load the state of all devices from file. The \s-1RAM\s0 and the block devices
of the \s-1VM\s0 are not loaded by this command.
.PP
\&\fBArguments:\fR
.ie n .IP """filename: string""" 4
.el .IP "\f(CWfilename: string\fR" 4
.IX Item "filename: string"
the file to load the state of the devices from as binary
data. See xen\-save\-devices\-state.txt for a description of the binary
format.
.PP
\&\fBSince:\fR
2.7
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "xen\-load\-devices\-state",
\&             "arguments": { "filename": "/tmp/resume" } }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBxen-set-replication\fR  (Command)
Enable or disable replication.
.PP
\&\fBArguments:\fR
.ie n .IP """enable: boolean""" 4
.el .IP "\f(CWenable: boolean\fR" 4
.IX Item "enable: boolean"
true to enable, false to disable.
.ie n .IP """primary: boolean""" 4
.el .IP "\f(CWprimary: boolean\fR" 4
.IX Item "primary: boolean"
true for primary or false for secondary.
.ie n .IP """failover: boolean"" (optional)" 4
.el .IP "\f(CWfailover: boolean\fR (optional)" 4
.IX Item "failover: boolean (optional)"
true to do failover, false to stop. but cannot be
specified if 'enable' is true. default value is false.
.PP
\&\fBReturns:\fR
nothing.
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "xen\-set\-replication",
\&             "arguments": {"enable": true, "primary": false} }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBReplicationStatus\fR (Object)
.PP
The result format for 'query\-xen\-replication\-status'.
.PP
\&\fBMembers:\fR
.ie n .IP """error: boolean""" 4
.el .IP "\f(CWerror: boolean\fR" 4
.IX Item "error: boolean"
true if an error happened, false if replication is normal.
.ie n .IP """desc: string"" (optional)" 4
.el .IP "\f(CWdesc: string\fR (optional)" 4
.IX Item "desc: string (optional)"
the human readable error description string, when
\&\f(CW\*(C`error\*(C'\fR is 'true'.
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBquery-xen-replication-status\fR  (Command)
Query replication status while the vm is running.
.PP
\&\fBReturns:\fR
A \f(CW\*(C`ReplicationResult\*(C'\fR object showing the status.
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "query\-xen\-replication\-status" }
\&        <\- { "return": { "error": false } }
.Ve
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBxen-colo-do-checkpoint\fR  (Command)
Xen uses this command to notify replication to trigger a checkpoint.
.PP
\&\fBReturns:\fR
nothing.
.PP
\&\fBExample:\fR
.PP
.Vb 2
\&        \-> { "execute": "xen\-colo\-do\-checkpoint" }
\&        <\- { "return": {} }
.Ve
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBGICCapability\fR (Object)
.PP
The struct describes capability for a specific \s-1GIC \s0(Generic
Interrupt Controller) version. These bits are not only decided by
\&\s-1QEMU/KVM\s0 software version, but also decided by the hardware that
the program is running upon.
.PP
\&\fBMembers:\fR
.ie n .IP """version: int""" 4
.el .IP "\f(CWversion: int\fR" 4
.IX Item "version: int"
version of \s-1GIC\s0 to be described. Currently, only 2 and 3
are supported.
.ie n .IP """emulated: boolean""" 4
.el .IP "\f(CWemulated: boolean\fR" 4
.IX Item "emulated: boolean"
whether current QEMU/hardware supports emulated \s-1GIC\s0
device in user space.
.ie n .IP """kernel: boolean""" 4
.el .IP "\f(CWkernel: boolean\fR" 4
.IX Item "kernel: boolean"
whether current QEMU/hardware supports hardware
accelerated \s-1GIC\s0 device in kernel.
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBquery-gic-capabilities\fR  (Command)
This command is ARM-only. It will return a list of GICCapability
objects that describe its capability bits.
.PP
\&\fBReturns:\fR
a list of GICCapability objects.
.PP
\&\fBSince:\fR
2.6
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&        \-> { "execute": "query\-gic\-capabilities" }
\&        <\- { "return": [{ "version": 2, "emulated": true, "kernel": false },
\&                        { "version": 3, "emulated": false, "kernel": true } ] }
.Ve
.PP
\&\fBCpuInstanceProperties\fR (Object)
.PP
List of properties to be used for hotplugging a \s-1CPU\s0 instance,
it should be passed by management with device_add command when
a \s-1CPU\s0 is being hotplugged.
.PP
\&\fBMembers:\fR
.ie n .IP """node\-id: int"" (optional)" 4
.el .IP "\f(CWnode\-id: int\fR (optional)" 4
.IX Item "node-id: int (optional)"
\&\s-1NUMA\s0 node \s-1ID\s0 the \s-1CPU\s0 belongs to
.ie n .IP """socket\-id: int"" (optional)" 4
.el .IP "\f(CWsocket\-id: int\fR (optional)" 4
.IX Item "socket-id: int (optional)"
socket number within node/board the \s-1CPU\s0 belongs to
.ie n .IP """core\-id: int"" (optional)" 4
.el .IP "\f(CWcore\-id: int\fR (optional)" 4
.IX Item "core-id: int (optional)"
core number within socket the \s-1CPU\s0 belongs to
.ie n .IP """thread\-id: int"" (optional)" 4
.el .IP "\f(CWthread\-id: int\fR (optional)" 4
.IX Item "thread-id: int (optional)"
thread number within core the \s-1CPU\s0 belongs to
.PP
\&\fBNote:\fR
currently there are 4 properties that could be present
but management should be prepared to pass through other
properties with device_add command to allow for future
interface extension. This also requires the filed names to be kept in
sync with the properties passed to \-device/device_add.
.PP
\&\fBSince:\fR
2.7
.PP
\&\fBHotpluggableCPU\fR (Object)
.PP
\&\fBMembers:\fR
.ie n .IP """type: string""" 4
.el .IP "\f(CWtype: string\fR" 4
.IX Item "type: string"
\&\s-1CPU\s0 object type for usage with device_add command
.ie n .IP """props: CpuInstanceProperties""" 4
.el .IP "\f(CWprops: CpuInstanceProperties\fR" 4
.IX Item "props: CpuInstanceProperties"
list of properties to be used for hotplugging \s-1CPU\s0
.ie n .IP """vcpus\-count: int""" 4
.el .IP "\f(CWvcpus\-count: int\fR" 4
.IX Item "vcpus-count: int"
number of logical \s-1VCPU\s0 threads \f(CW\*(C`HotpluggableCPU\*(C'\fR provides
.ie n .IP """qom\-path: string"" (optional)" 4
.el .IP "\f(CWqom\-path: string\fR (optional)" 4
.IX Item "qom-path: string (optional)"
link to existing \s-1CPU\s0 object if \s-1CPU\s0 is present or
omitted if \s-1CPU\s0 is not present.
.PP
\&\fBSince:\fR
2.7
.PP
\&\fBquery-hotpluggable-cpus\fR  (Command)
.PP
\&\fBReturns:\fR
a list of HotpluggableCPU objects.
.PP
\&\fBSince:\fR
2.7
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&        For pseries machine type started with \-smp 2,cores=2,maxcpus=4 \-cpu POWER8:
\&        
\&        \-> { "execute": "query\-hotpluggable\-cpus" }
\&        <\- {"return": [
\&             { "props": { "core": 8 }, "type": "POWER8\-spapr\-cpu\-core",
\&               "vcpus\-count": 1 },
\&             { "props": { "core": 0 }, "type": "POWER8\-spapr\-cpu\-core",
\&               "vcpus\-count": 1, "qom\-path": "/machine/unattached/device[0]"}
\&           ]}\*(Aq
\&        
\&        For pc machine type started with \-smp 1,maxcpus=2:
\&        
\&        \-> { "execute": "query\-hotpluggable\-cpus" }
\&        <\- {"return": [
\&             {
\&                "type": "qemu64\-x86_64\-cpu", "vcpus\-count": 1,
\&                "props": {"core\-id": 0, "socket\-id": 1, "thread\-id": 0}
\&             },
\&             {
\&                "qom\-path": "/machine/unattached/device[0]",
\&                "type": "qemu64\-x86_64\-cpu", "vcpus\-count": 1,
\&                "props": {"core\-id": 0, "socket\-id": 0, "thread\-id": 0}
\&             }
\&           ]}
.Ve
.PP
\&\fBGuidInfo\fR (Object)
.PP
\&\s-1GUID\s0 information.
.PP
\&\fBMembers:\fR
.ie n .IP """guid: string""" 4
.el .IP "\f(CWguid: string\fR" 4
.IX Item "guid: string"
the globally unique identifier
.PP
\&\fBSince:\fR
2.9
.PP
\&\fBquery-vm-generation-id\fR  (Command)
Show Virtual Machine Generation \s-1ID\s0
.PP
Since 2.9
